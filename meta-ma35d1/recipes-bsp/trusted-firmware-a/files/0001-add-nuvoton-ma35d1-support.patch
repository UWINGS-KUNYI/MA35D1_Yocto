From c696f4f5f3936c760102c6a67707b264863a5189 Mon Sep 17 00:00:00 2001
From: KunYi Chen <kunyi.chen@gmail.com>
Date: Tue, 22 Nov 2022 22:53:54 +0800
Subject: [PATCH 1/2] copy ma35d1 support files from tf-a-ma35d1 v2.3

---
 .gitignore                                    |    1 +
 docs/plat/ma35d1.rst                          |  137 +
 drivers/nuvoton/ddr/ma35d1_ddr.c              | 2221 +++++++++++++++++
 drivers/nuvoton/nand/ma35d1_nand.c            |  604 +++++
 drivers/nuvoton/pmic/ma35d1_pmic.c            |  339 +++
 drivers/nuvoton/qspi/ma35d1_qspi.c            |  737 ++++++
 drivers/nuvoton/sdhc/ma35d1_sdhc.c            |  727 ++++++
 drivers/nuvoton/uart/ma35d1_console.S         |  235 ++
 fdts/ma35d1-cpu1g-issi-1g.dts                 |   32 +
 fdts/ma35d1-cpu1g-mc-1g.dts                   |   32 +
 fdts/ma35d1-cpu1g-wb-256m.dts                 |   37 +
 fdts/ma35d1-cpu1g-wb-512m.dts                 |   32 +
 fdts/ma35d1-cpu1g-zt-1g.dts                   |   32 +
 fdts/ma35d1-cpu800-issi-1g.dts                |   22 +
 fdts/ma35d1-cpu800-mc-1g.dts                  |   22 +
 fdts/ma35d1-cpu800-wb-128m.dts                |   27 +
 fdts/ma35d1-cpu800-wb-256m.dts                |   26 +
 fdts/ma35d1-cpu800-wb-512m.dts                |   22 +
 fdts/ma35d1-cpu800-zt-1g.dts                  |   22 +
 fdts/ma35d1.dtsi                              |  105 +
 include/drivers/auth/crypto_mod.h             |   19 +
 include/drivers/nuvoton/ma35d1_nand.h         |  105 +
 include/drivers/nuvoton/ma35d1_pmic.h         |   64 +
 include/drivers/nuvoton/ma35d1_qspi.h         |   55 +
 include/drivers/nuvoton/ma35d1_sdhc.h         |  143 ++
 include/drivers/nuvoton/uart_ma35d1.h         |   85 +
 include/dt-bindings/clock/ma35d1-clk.h        |   78 +
 include/dt-bindings/pinctrl/ma35d1-pinfunc.h  | 1617 ++++++++++++
 .../dt-bindings/reset/nuvoton,ma35d1-reset.h  |  107 +
 plat/nuvoton/ma35d1/aarch64/ma35d1_helpers.S  |  216 ++
 plat/nuvoton/ma35d1/drivers/ma35d1_crypto.c   |  899 +++++++
 plat/nuvoton/ma35d1/drivers/tsi_cmd.c         |  719 ++++++
 plat/nuvoton/ma35d1/include/ma35d1_crypto.h   |  268 ++
 plat/nuvoton/ma35d1/include/ma35d1_sip_svc.h  |   35 +
 plat/nuvoton/ma35d1/include/plat_macros.S     |   27 +
 plat/nuvoton/ma35d1/include/platform_def.h    |  251 ++
 plat/nuvoton/ma35d1/include/sspcc.h           |  852 +++++++
 plat/nuvoton/ma35d1/include/tsi_cmd.h         |  187 ++
 plat/nuvoton/ma35d1/include/whc.h             |  289 +++
 plat/nuvoton/ma35d1/ma35d1_bl2_el3_setup.c    |   32 +
 .../ma35d1/ma35d1_bl2_mem_params_desc.c       |  137 +
 plat/nuvoton/ma35d1/ma35d1_bl2_setup.c        |  195 ++
 plat/nuvoton/ma35d1/ma35d1_bl31_setup.c       |  168 ++
 plat/nuvoton/ma35d1/ma35d1_common.c           |  382 +++
 plat/nuvoton/ma35d1/ma35d1_def.h              |  241 ++
 plat/nuvoton/ma35d1/ma35d1_image_load.c       |   47 +
 plat/nuvoton/ma35d1/ma35d1_io_storage.c       |  373 +++
 plat/nuvoton/ma35d1/ma35d1_platform.c         |   98 +
 plat/nuvoton/ma35d1/ma35d1_pm.c               |  522 ++++
 plat/nuvoton/ma35d1/ma35d1_private.c          |   62 +
 plat/nuvoton/ma35d1/ma35d1_private.h          |   59 +
 plat/nuvoton/ma35d1/ma35d1_rotpk.S            |   15 +
 plat/nuvoton/ma35d1/ma35d1_security.c         |  154 ++
 plat/nuvoton/ma35d1/ma35d1_sip_svc.c          |  224 ++
 plat/nuvoton/ma35d1/ma35d1_topology.c         |   87 +
 plat/nuvoton/ma35d1/ma35d1_trusted_boot.c     |   36 +
 plat/nuvoton/ma35d1/platform.mk               |  255 ++
 57 files changed, 14515 insertions(+)
 create mode 100644 docs/plat/ma35d1.rst
 create mode 100644 drivers/nuvoton/ddr/ma35d1_ddr.c
 create mode 100644 drivers/nuvoton/nand/ma35d1_nand.c
 create mode 100644 drivers/nuvoton/pmic/ma35d1_pmic.c
 create mode 100644 drivers/nuvoton/qspi/ma35d1_qspi.c
 create mode 100644 drivers/nuvoton/sdhc/ma35d1_sdhc.c
 create mode 100644 drivers/nuvoton/uart/ma35d1_console.S
 create mode 100644 fdts/ma35d1-cpu1g-issi-1g.dts
 create mode 100644 fdts/ma35d1-cpu1g-mc-1g.dts
 create mode 100644 fdts/ma35d1-cpu1g-wb-256m.dts
 create mode 100644 fdts/ma35d1-cpu1g-wb-512m.dts
 create mode 100644 fdts/ma35d1-cpu1g-zt-1g.dts
 create mode 100644 fdts/ma35d1-cpu800-issi-1g.dts
 create mode 100644 fdts/ma35d1-cpu800-mc-1g.dts
 create mode 100644 fdts/ma35d1-cpu800-wb-128m.dts
 create mode 100644 fdts/ma35d1-cpu800-wb-256m.dts
 create mode 100644 fdts/ma35d1-cpu800-wb-512m.dts
 create mode 100644 fdts/ma35d1-cpu800-zt-1g.dts
 create mode 100644 fdts/ma35d1.dtsi
 create mode 100644 include/drivers/nuvoton/ma35d1_nand.h
 create mode 100644 include/drivers/nuvoton/ma35d1_pmic.h
 create mode 100644 include/drivers/nuvoton/ma35d1_qspi.h
 create mode 100644 include/drivers/nuvoton/ma35d1_sdhc.h
 create mode 100644 include/drivers/nuvoton/uart_ma35d1.h
 create mode 100644 include/dt-bindings/clock/ma35d1-clk.h
 create mode 100644 include/dt-bindings/pinctrl/ma35d1-pinfunc.h
 create mode 100644 include/dt-bindings/reset/nuvoton,ma35d1-reset.h
 create mode 100644 plat/nuvoton/ma35d1/aarch64/ma35d1_helpers.S
 create mode 100644 plat/nuvoton/ma35d1/drivers/ma35d1_crypto.c
 create mode 100644 plat/nuvoton/ma35d1/drivers/tsi_cmd.c
 create mode 100644 plat/nuvoton/ma35d1/include/ma35d1_crypto.h
 create mode 100644 plat/nuvoton/ma35d1/include/ma35d1_sip_svc.h
 create mode 100644 plat/nuvoton/ma35d1/include/plat_macros.S
 create mode 100644 plat/nuvoton/ma35d1/include/platform_def.h
 create mode 100644 plat/nuvoton/ma35d1/include/sspcc.h
 create mode 100644 plat/nuvoton/ma35d1/include/tsi_cmd.h
 create mode 100644 plat/nuvoton/ma35d1/include/whc.h
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_bl2_el3_setup.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_bl2_mem_params_desc.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_bl2_setup.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_bl31_setup.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_common.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_def.h
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_image_load.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_io_storage.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_platform.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_pm.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_private.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_private.h
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_rotpk.S
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_security.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_sip_svc.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_topology.c
 create mode 100644 plat/nuvoton/ma35d1/ma35d1_trusted_boot.c
 create mode 100644 plat/nuvoton/ma35d1/platform.mk

diff --git a/.gitignore b/.gitignore
index 98a27bb..1005aa6 100644
--- a/.gitignore
+++ b/.gitignore
@@ -94,3 +94,4 @@ tags
 
 # Node.js
 node_modules/
+.vscode
diff --git a/docs/plat/ma35d1.rst b/docs/plat/ma35d1.rst
new file mode 100644
index 0000000..0173ec2
--- /dev/null
+++ b/docs/plat/ma35d1.rst
@@ -0,0 +1,137 @@
+NUVOTON ma35d1
+=================
+
+Trusted Firmware-A supports Nuvoton ARM SoC AARCH64 fields.
+ma35d1: dual-core Cortex-A35
+
+
+Memory mapping
+~~~~~~~~~~~~~~
+
+::
+
+    0x00000000 +-----------------+
+               |                 |
+    0x20000000 +-----------------+
+               |                 |
+    0x24000000 +-----------------+ \
+               |                 | |
+               |                 | |
+    0x28000000 +-----------------+ |
+               |       BL2       | | Embedded SRAM
+    0x28010000 +-----------------+ |
+               |       BL31      | |
+    0x30000000 +-----------------+ /
+               |                 |
+               |                 |
+    0x40000000 +-----------------+
+               |                 |
+               |                 |   Peripheral
+               |                 |
+    0x50000000 +-----------------+
+               |                 |
+               |                 |   BootRom, GIC
+               |                 |
+    0x60000000 +-----------------+
+               |                 |
+               |                 |
+    0x80000000 +-----------------+ \
+               |                 | |
+               |       BL33      | | Non-secure RAM (DDR)
+               |       ...       | |
+               |                 | |
+    0x8F800000 +-----------------+ /\
+               |                 |  |
+               |       BL32      |  | Secure RAM (DDR)
+    0x8FFFFFFF +-----------------+  /
+
+
+Boot Sequence
+-------------
+
+Bootrom -> BL2 (compiled with BL2_AT_EL3) -> BL31 -> OP-TEE -> BL31 --> BL33(u-boot)
+
+How to build
+------------
+
+Build Procedure
+~~~~~~~~~~~~~~~
+
+-  Prepare AARCH64 toolchain.
+
+-  Build optee (BL32) and u-boot (BL33) firstly, and get binary images: tee-pager_v2.bin and u-boot.bin
+
+-  Build TF-A
+
+   Build bl2 and bl31:
+
+   .. code:: shell
+
+   normal built command:
+
+       CROSS_COMPILE=aarch64-linux-gnu- make PLAT=ma35d1  (bl2, bl31, DTB)
+
+	CROSS_COMPILE=aarch64-linux-gnu- make PLAT=ma35d1 \
+		NEED_BL31=yes bl31 NEED_BL32=yes BL32=fiptool_images/tee-header_v2.bin \
+		BL32_EXTRA1=fiptool_images/tee-pager_v2.bin BL33=fiptool_images/u-boot.bin \
+		all fip
+
+	CROSS_COMPILE=aarch64-linux-gnu- make PLAT=ma35d1 \
+		NEED_BL31=yes bl31 NEED_SCP_BL2=yes SCP_BL2=fiptool_images/cm4.bin \
+		NEED_BL32=yes BL32=fiptool_images/tee-header_v2.bin \
+		BL32_EXTRA1=fiptool_images/tee-pager_v2.bin BL33=fiptool_images/u-boot.bin \
+		all fip
+
+
+   enable TRUSTED_BOARD_BOOT
+
+	CROSS_COMPILE=aarch64-linux-gnu- make PLAT=ma35d1 \
+		NEED_BL31=yes bl31 NEED_BL32=yes BL32=fiptool_images/tee-header_v2.bin \
+		BL32_EXTRA1=fiptool_images/tee-pager_v2.bin BL33=fiptool_images/u-boot.bin \
+		certificates all fip
+
+   tools:
+	./tools/cert_create/cert_create -n --rot-key "build/ma35d1/release/rot_key.pem" \
+		--tfw-nvctr 0 \
+		--ntfw-nvctr 0 \
+		--trusted-key-cert fiptool_images/trusted-key-cert.key-crt \
+		--soc-fw=build/ma35d1/release/bl31.bin \
+		--soc-fw-cert fiptool_images/trusted-boot-fw.crt \
+		--soc-fw-key-cert fiptool_images/trusted-boot-fw.key-crt \
+		--tos-fw fiptool_images/tee-header_v2.bin \
+		--tos-fw-cert fiptool_images/tee-header_v2.bin.crt \
+		--tos-fw-key-cert fiptool_images/tee-header_v2.bin.key-crt \
+		--tos-fw-extra1 fiptool_images/tee-pager_v2.bin \
+		--nt-fw fiptool_images/u-boot.bin \
+		--nt-fw-cert fiptool_images/u-boot.bin.crt \
+		--nt-fw-key-cert fiptool_images/u-boot.bin.key-crt
+
+       CROSS_COMPILE=aarch64-linux-gnu- make PLAT=ma35d1 fiptool
+
+	./tools/fiptool/fiptool create \
+		--soc-fw build/ma35d1/release/bl31.bin \
+		--tos-fw fiptool_images/tee-header_v2.bin \
+		--tos-fw-extra1 fiptool_images/tee-pager_v2.bin \
+		--nt-fw fiptool_images/u-boot.bin \
+		fip.bin
+
+	./tools/fiptool/fiptool create \
+		--soc-fw build/ma35d1/release/bl31.bin \
+		--tos-fw fiptool_images/tee-header_v2.bin \
+		--tos-fw-extra1 fiptool_images/tee-pager_v2.bin \
+		--nt-fw fiptool_images/u-boot.bin \
+		--soc-fw-key-cert fiptool_images/trusted-boot-fw.key-crt \
+		--tos-fw-cert fiptool_images/tee-header_v2.bin.crt \
+		--tos-fw-key-cert fiptool_images/tee-header_v2.bin.key-crt \
+		--nt-fw-cert fiptool_images/u-boot.bin.crt \
+		--nt-fw-key-cert fiptool_images/u-boot.bin.key-crt \
+		--trusted-key-cert fiptool_images/trusted-key-cert.key-crt \
+		fip.bin
+
+How to deploy
+-------------
+
+Both upstream U-Boot and OPTEE projects contain instructions on where
+to put the built images during their respective build process.
+So after successfully building TF-A just follow their build instructions
+to continue.
diff --git a/drivers/nuvoton/ddr/ma35d1_ddr.c b/drivers/nuvoton/ddr/ma35d1_ddr.c
new file mode 100644
index 0000000..1d733af
--- /dev/null
+++ b/drivers/nuvoton/ddr/ma35d1_ddr.c
@@ -0,0 +1,2221 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <stdint.h>
+#include <string.h>
+
+#include <lib/mmio.h>
+#include <libfdt.h>
+
+#include <plat/common/platform.h>
+#include <platform_def.h>
+
+
+/* DDR3_256MB_1066MBPS_WINBOND_INIT_BY_DDR32PHY */
+void ma35d1_wb_ddr3_256mb(void)
+{
+
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000001);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000001);
+
+	//polling to 0x00000000
+	//while((inp32((void *)UMCTL2_BA + 0x004) & 0x00000003) != 0x00000000);
+
+	//set MSTR
+	outp32((void *)UMCTL2_BA + 0x000,0x01040001);
+
+	//set MRCTRL0
+	outp32((void *)UMCTL2_BA + 0x010,0x0000d010);
+
+	//set MRCTRL1
+	outp32((void *)UMCTL2_BA + 0x014,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000000);  //add
+
+	//set PWRTMG
+	outp32((void *)UMCTL2_BA + 0x034,0x00400010);  //mod 20200421
+
+	//set HWLPCTL
+	outp32((void *)UMCTL2_BA + 0x038,0x000a0003);  //mod 20200121
+
+	//set RFSHCTL0
+	outp32((void *)UMCTL2_BA + 0x050,0x00210000);
+
+	//set RFSHCTL1
+	outp32((void *)UMCTL2_BA + 0x054,0x003c003c);
+
+	//set RFSHCTL3
+	outp32((void *)UMCTL2_BA + 0x060,0x00000000);  //mod 20191211
+
+	//set RFSHTMG
+	outp32((void *)UMCTL2_BA + 0x064,0x0010002b);  //mod 20210106
+
+	//set CRCPARCTL0
+	outp32((void *)UMCTL2_BA + 0x0c0,0x00000000);
+
+	//set INIT0
+	outp32((void *)UMCTL2_BA + 0x0d0,0x40020083);  //mod 20200505
+
+	//set INIT1
+	outp32((void *)UMCTL2_BA + 0x0d4,0x00350002);  //mod 20200505
+
+	//set INIT3
+	outp32((void *)UMCTL2_BA + 0x0dc,0x1b400006);  //mod 20201109
+
+	//set INIT4
+	outp32((void *)UMCTL2_BA + 0x0e0,0x00480000);  //mod 20200822
+
+	//set INIT5
+	outp32((void *)UMCTL2_BA + 0x0e4,0x00090000);
+
+	//set DIMMCTL
+	outp32((void *)UMCTL2_BA + 0x0f0,0x00000000);
+
+	//set RANKCTL
+	outp32((void *)UMCTL2_BA + 0x0f4,0x0000032f);
+
+	//set DRAMTMG0
+	outp32((void *)UMCTL2_BA + 0x100,0x090d040a);  //mod 20210108
+
+	//set DRAMTMG1
+	outp32((void *)UMCTL2_BA + 0x104,0x0003020e);  //mod 20200103
+
+	//set DRAMTMG2
+	outp32((void *)UMCTL2_BA + 0x108,0x00000408);  //mod 20200103
+
+	//set DRAMTMG3
+	outp32((void *)UMCTL2_BA + 0x10c,0x00003007);  //mod 20201208
+
+	//set DRAMTMG4
+	outp32((void *)UMCTL2_BA + 0x110,0x04020205);  //mod 20200103
+
+	//set DRAMTMG5
+	outp32((void *)UMCTL2_BA + 0x114,0x03030202);  //mod 20200103
+
+	//set DRAMTMG8
+	outp32((void *)UMCTL2_BA + 0x120,0x00000a02);  //mod 20200506
+
+	//set DRAMTMG15
+	outp32((void *)UMCTL2_BA + 0x13c,0x80000032);  //mod 20200225
+
+	//set ZQCTL0
+	outp32((void *)UMCTL2_BA + 0x180,0x00800020);
+
+	//set ZQCTL1
+	outp32((void *)UMCTL2_BA + 0x184,0x00000100);  //mod 20200505
+
+	//set DFITMG0
+	outp32((void *)UMCTL2_BA + 0x190,0x04020101);
+
+	//set DFITMG1
+	outp32((void *)UMCTL2_BA + 0x194,0x00060101);
+
+	//set DFILPCFG0
+#ifdef DFI_DDR_PHY_LP
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b131);  //mod 20200417
+#else
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b030);  //mod 20200825
+#endif
+
+	//set DFIUPD0
+	outp32((void *)UMCTL2_BA + 0x1a0,0x00400005);  //mod 20200303
+
+	//set DFIUPD1
+	outp32((void *)UMCTL2_BA + 0x1a4,0x00170066);  //mod 20200425
+
+	//set DFIUPD2
+	outp32((void *)UMCTL2_BA + 0x1a8,0x80000000);  //mod 20200309
+
+	//set DFIMISC
+	outp32((void *)UMCTL2_BA + 0x1b0,0x00000011);  //mod
+
+	//set DFIPHYMSTR
+	outp32((void *)UMCTL2_BA + 0x1c4,0x00000000);
+
+	//set ADDRMAP0
+	outp32((void *)UMCTL2_BA + 0x200,0x00000015);  //mod 20200506
+
+	//set ADDRMAP1
+	outp32((void *)UMCTL2_BA + 0x204,0x00080808);
+
+	//set ADDRMAP2
+	outp32((void *)UMCTL2_BA + 0x208,0x00000000);
+
+	//set ADDRMAP3
+	outp32((void *)UMCTL2_BA + 0x20c,0x00000000);
+
+	//set ADDRMAP4
+	outp32((void *)UMCTL2_BA + 0x210,0x00001f1f);
+
+	//set ADDRMAP5
+	outp32((void *)UMCTL2_BA + 0x214,0x070f0707);
+
+	//set ADDRMAP6
+	outp32((void *)UMCTL2_BA + 0x218,0x0f0f0707);  //mod 20200506
+
+	//set ADDRMAP9
+	outp32((void *)UMCTL2_BA + 0x224,0x07070707);
+
+	//set ADDRMAP10
+	outp32((void *)UMCTL2_BA + 0x228,0x07070707);
+
+	//set ADDRMAP11
+	outp32((void *)UMCTL2_BA + 0x22c,0x00000007);
+
+	//set ODTCFG
+	outp32((void *)UMCTL2_BA + 0x240,0x06000608);
+
+	//set ODTMAP
+	outp32((void *)UMCTL2_BA + 0x244,0x00000000);  //mod 20220606
+
+	//set SCHED
+	outp32((void *)UMCTL2_BA + 0x250,0x00f51f00);
+
+	//set SCHED1
+	outp32((void *)UMCTL2_BA + 0x254,0x00000000);
+
+	//set PERFHPR1
+	outp32((void *)UMCTL2_BA + 0x25c,0x0f000001);
+
+	//set PERFLPR1
+	outp32((void *)UMCTL2_BA + 0x264,0x0f00007f);
+
+	//set PERFWR1
+	outp32((void *)UMCTL2_BA + 0x26c,0x0f00007f);
+
+	//set DBG0
+	outp32((void *)UMCTL2_BA + 0x300,0x00000000);
+
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000000);
+
+	//set DBGCMD
+	outp32((void *)UMCTL2_BA + 0x30c,0x00000000);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//set SWCTLSTATIC
+	outp32((void *)UMCTL2_BA + 0x328,0x00000000);
+
+	//set POISONCFG
+	outp32((void *)UMCTL2_BA + 0x36c,0x00110011);
+
+	//set PCTRL_0
+	outp32((void *)UMCTL2_BA + 0x490,0x00000001);
+
+	//set PCTRL_1
+	outp32((void *)UMCTL2_BA + 0x540,0x00000000);  //mod 20200323
+
+	//set PCTRL_2
+	outp32((void *)UMCTL2_BA + 0x5f0,0x00000000);  //mod 20200323
+
+	//set PCTRL_3
+	outp32((void *)UMCTL2_BA + 0x6a0,0x00000000);  //mod 20200323
+
+	//set PCTRL_4
+	outp32((void *)UMCTL2_BA + 0x750,0x00000000);  //mod 20200323
+
+	//set PCTRL_5
+	outp32((void *)UMCTL2_BA + 0x800,0x00000001);  //mod 20201016
+
+	//set PCTRL_6
+	outp32((void *)UMCTL2_BA + 0x8b0,0x00000001);
+
+	//set PCCFG
+	outp32((void *)UMCTL2_BA + 0x400,0x00000000);
+
+	//set PCFGR_0
+	outp32((void *)UMCTL2_BA + 0x404,0x0001500f);  //mod 20200408
+
+	//set PCFGR_1
+	outp32((void *)UMCTL2_BA + 0x4b4,0x0001500f);  //mod 20200408
+
+	//set PCFGR_2
+	outp32((void *)UMCTL2_BA + 0x564,0x0001500f);  //mod 20200408
+
+	//set PCFGR_3
+	outp32((void *)UMCTL2_BA + 0x614,0x0001500f);  //mod 20200408
+
+	//set PCFGR_4
+	outp32((void *)UMCTL2_BA + 0x6c4,0x0001500f);  //mod 20200408
+
+	//set PCFGR_5
+	outp32((void *)UMCTL2_BA + 0x774,0x0001500f);  //mod 20200408
+
+	//set PCFGR_6
+	outp32((void *)UMCTL2_BA + 0x824,0x0001500f);  //mod 20200408
+
+	//set PCFGW_0
+	outp32((void *)UMCTL2_BA + 0x408,0x0000500f);  //mod 20200408
+
+	//set PCFGW_1
+	outp32((void *)UMCTL2_BA + 0x4b8,0x0000500f);  //mod 20200408
+
+	//set PCFGW_2
+	outp32((void *)UMCTL2_BA + 0x568,0x0000500f);  //mod 20200408
+
+	//set PCFGW_3
+	outp32((void *)UMCTL2_BA + 0x618,0x0000500f);  //mod 20200408
+
+	//set PCFGW_4
+	outp32((void *)UMCTL2_BA + 0x6c8,0x0000500f);  //mod 20200408
+
+	//set PCFGW_5
+	outp32((void *)UMCTL2_BA + 0x778,0x0000500f);  //mod 20200408
+
+	//set PCFGW_6
+	outp32((void *)UMCTL2_BA + 0x828,0x0000500f);  //mod 20200408
+
+	//set SARBASE0
+	outp32((void *)UMCTL2_BA + 0xf04,0x00000008);
+
+	//set SARSIZE0
+	outp32((void *)UMCTL2_BA + 0xf08,0x00000000);
+
+	//de-assert reset signals of DDR memory controller
+	outp32((void *)SYS_BA+0x20,(inp32((void *)SYS_BA+0x20) & 0x8fffffff));
+	while( (inp32((void *)SYS_BA+0x20) & 0x20000000) != 0x00000000);
+
+	//=====================================================================
+	//                  DDR PHY initialization
+	//=====================================================================
+
+	//set DSGCR,addr=16
+	outp32((void *)DDRPHY_BA + 0x040,0xf004649f);
+
+	//set PGCR1,addr=3
+	outp32((void *)DDRPHY_BA + 0x00c,0x0300c461);  //mod 20200608
+
+	//set PGCR2,addr=35
+	outp32((void *)DDRPHY_BA + 0x08c,0x00f0027f);  //mod 20210106
+
+	//set PTR0,addr=7
+	outp32((void *)DDRPHY_BA + 0x01c,0x0c806403);  //mod 20200306 for pclk=100mhz
+
+	//set PTR1,addr=8
+	outp32((void *)DDRPHY_BA + 0x020,0x27100385);  //mod 20200306 for pclk=100mhz
+
+	//set PTR2,addr=9
+	outp32((void *)DDRPHY_BA + 0x024,0x00083def);
+
+	//set PTR3,addr=10
+	outp32((void *)DDRPHY_BA + 0x028,0x05b4111d);  //mod 20200506
+
+	//set PTR4,addr=11
+	outp32((void *)DDRPHY_BA + 0x02c,0x0801a072);  //mod 20200508
+
+	//set MR0,addr=21
+	outp32((void *)DDRPHY_BA + 0x054,0x00001b40);  //mod
+
+	//set MR1,addr=22
+	outp32((void *)DDRPHY_BA + 0x058,0x00000002);  //mod 20220606
+
+	//set MR2,addr=23
+	outp32((void *)DDRPHY_BA + 0x05c,0x00000048);  //mod 20200822
+
+	//set MR3,addr=24
+	outp32((void *)DDRPHY_BA + 0x060,0x00000000);
+
+	//set DTPR0,addr=18
+	outp32((void *)DDRPHY_BA + 0x048,0x71568855);
+
+	//set DTPR1,addr=19
+	outp32((void *)DDRPHY_BA + 0x04c,0x2282b32a);  //mod 20201208
+
+	//set DTPR2,addr=20
+	outp32((void *)DDRPHY_BA + 0x050,0x30023e00);
+
+	//set ZQ0CR1,addr=97
+	outp32((void *)DDRPHY_BA + 0x184,0x0000105d);  //mod 20201109
+
+	//polling PGSR0 (addr=4) to 0x0000000f
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0x0000000f) != 0x0000000f);
+
+	//set DCR,addr=17
+	outp32((void *)DDRPHY_BA + 0x044,0x0000040b);
+
+	//set DTCR,addr=26
+	outp32((void *)DDRPHY_BA + 0x068,0x91003587);  //mod 20200820
+
+	//set PIR,addr=1
+	outp32((void *)DDRPHY_BA + 0x004,0x0000ff81);
+
+	//polling PGSR0 (addr=4) to 0xb0000fff
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0xffffffff) != 0xb0000fff);
+
+	//polling MCTL2 STAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x004) & 0x00000003) != 0x00000001);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x0000000b);  //mod 20191213
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//polling MCTL2 SWSTAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x324) & 0x00000001) != 0x00000001);
+
+}
+
+/* DDR3_512MB_1066MBPS_WINBOND_INIT_BY_DDR32PHY */
+void ma35d1_wb_ddr3_512mb(void)
+{
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000001);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000001);  //mod
+
+	//polling to 0x00000000
+	//while((inp32((void *)UMCTL2_BA + 0x004) & 0x00000003) != 0x00000000);
+
+	//set MSTR
+	outp32((void *)UMCTL2_BA + 0x000,0x01040001);  //mod 20200507
+
+	//set MRCTRL0
+	outp32((void *)UMCTL2_BA + 0x010,0x0000d010);  //mod 20200507
+
+	//set MRCTRL1
+	outp32((void *)UMCTL2_BA + 0x014,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000000);  //add
+
+	//set PWRTMG
+	outp32((void *)UMCTL2_BA + 0x034,0x00400010);  //mod 20200421
+
+	//set HWLPCTL
+	outp32((void *)UMCTL2_BA + 0x038,0x000a0003);  //mod 20200121
+
+	//set RFSHCTL0
+	outp32((void *)UMCTL2_BA + 0x050,0x00210000);
+
+	//set RFSHCTL1
+	outp32((void *)UMCTL2_BA + 0x054,0x003c003c);
+
+	//set RFSHCTL3
+	outp32((void *)UMCTL2_BA + 0x060,0x00000000);  //mod 20191211
+
+	//set RFSHTMG
+	outp32((void *)UMCTL2_BA + 0x064,0x00100046);  //mod 20210106
+
+	//set CRCPARCTL0
+	outp32((void *)UMCTL2_BA + 0x0c0,0x00000000);
+
+	//set INIT0
+	outp32((void *)UMCTL2_BA + 0x0d0,0x40020083);  //mod 20200505
+
+	//set INIT1
+	outp32((void *)UMCTL2_BA + 0x0d4,0x00350002);  //mod 20200505
+
+	//set INIT3
+	outp32((void *)UMCTL2_BA + 0x0dc,0x1b400006);  //mod 20201109
+
+	//set INIT4
+	outp32((void *)UMCTL2_BA + 0x0e0,0x00480000);  //mod 20200822
+
+	//set INIT5
+	outp32((void *)UMCTL2_BA + 0x0e4,0x00090000);
+
+	//set DIMMCTL
+	outp32((void *)UMCTL2_BA + 0x0f0,0x00000000);
+
+	//set RANKCTL
+	outp32((void *)UMCTL2_BA + 0x0f4,0x0000032f);
+
+	//set DRAMTMG0
+	outp32((void *)UMCTL2_BA + 0x100,0x090d040a);  //mod 20210108
+
+	//set DRAMTMG1
+	outp32((void *)UMCTL2_BA + 0x104,0x0003020e);  //mod 20200103
+
+	//set DRAMTMG2
+	outp32((void *)UMCTL2_BA + 0x108,0x00000408);  //mod 20200103
+
+	//set DRAMTMG3
+	outp32((void *)UMCTL2_BA + 0x10c,0x00003007);  //mod 20201208
+
+	//set DRAMTMG4
+	outp32((void *)UMCTL2_BA + 0x110,0x04020205);  //mod 20200103
+
+	//set DRAMTMG5
+	outp32((void *)UMCTL2_BA + 0x114,0x03030202);  //mod 20200103
+
+	//set DRAMTMG8
+	outp32((void *)UMCTL2_BA + 0x120,0x00000a04);
+
+	//set DRAMTMG15
+	outp32((void *)UMCTL2_BA + 0x13c,0x80000032);  //mod 20200225
+
+	//set ZQCTL0
+	outp32((void *)UMCTL2_BA + 0x180,0x00800020);
+
+	//set ZQCTL1
+	outp32((void *)UMCTL2_BA + 0x184,0x00000100);  //mod 20200505
+
+	//set DFITMG0
+	outp32((void *)UMCTL2_BA + 0x190,0x04020101);
+
+	//set DFITMG1
+	outp32((void *)UMCTL2_BA + 0x194,0x00060101);
+
+	//set DFILPCFG0
+#ifdef DFI_DDR_PHY_LP
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b131);  //mod 20200417
+#else
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b030);  //mod 20200825
+#endif
+
+	//set DFIUPD0
+	outp32((void *)UMCTL2_BA + 0x1a0,0x00400005);  //mod 20200303
+
+	//set DFIUPD1
+	outp32((void *)UMCTL2_BA + 0x1a4,0x00170066);  //mod 20200425
+
+	//set DFIUPD2
+	outp32((void *)UMCTL2_BA + 0x1a8,0x80000000);  //mod 20200309
+
+	//set DFIMISC
+	outp32((void *)UMCTL2_BA + 0x1b0,0x00000011);  //mod
+
+	//set DFIPHYMSTR
+	outp32((void *)UMCTL2_BA + 0x1c4,0x00000000);
+
+	//set ADDRMAP0
+	outp32((void *)UMCTL2_BA + 0x200,0x0000001f);  //mod 20200507
+
+	//set ADDRMAP1
+	outp32((void *)UMCTL2_BA + 0x204,0x00080808);
+
+	//set ADDRMAP2
+	outp32((void *)UMCTL2_BA + 0x208,0x00000000);
+
+	//set ADDRMAP3
+	outp32((void *)UMCTL2_BA + 0x20c,0x00000000);
+
+	//set ADDRMAP4
+	outp32((void *)UMCTL2_BA + 0x210,0x00001f1f);
+
+	//set ADDRMAP5
+	outp32((void *)UMCTL2_BA + 0x214,0x070f0707);
+
+	//set ADDRMAP6
+	outp32((void *)UMCTL2_BA + 0x218,0x0f070707);
+
+	//set ADDRMAP9
+	outp32((void *)UMCTL2_BA + 0x224,0x07070707);
+
+	//set ADDRMAP10
+	outp32((void *)UMCTL2_BA + 0x228,0x07070707);
+
+	//set ADDRMAP11
+	outp32((void *)UMCTL2_BA + 0x22c,0x00000007);
+
+	//set ODTCFG
+	outp32((void *)UMCTL2_BA + 0x240,0x06000608);
+
+	//set ODTMAP
+	outp32((void *)UMCTL2_BA + 0x244,0x00000101);  //mod 20200508
+
+	//set SCHED
+	outp32((void *)UMCTL2_BA + 0x250,0x00f51f00);
+
+	//set SCHED1
+	outp32((void *)UMCTL2_BA + 0x254,0x00000000);
+
+	//set PERFHPR1
+	outp32((void *)UMCTL2_BA + 0x25c,0x0f000001);
+
+	//set PERFLPR1
+	outp32((void *)UMCTL2_BA + 0x264,0x0f00007f);
+
+	//set PERFWR1
+	outp32((void *)UMCTL2_BA + 0x26c,0x0f00007f);
+
+	//set DBG0
+	outp32((void *)UMCTL2_BA + 0x300,0x00000000);
+
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000000);
+
+	//set DBGCMD
+	outp32((void *)UMCTL2_BA + 0x30c,0x00000000);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//set SWCTLSTATIC
+	outp32((void *)UMCTL2_BA + 0x328,0x00000000);
+
+	//set POISONCFG
+	outp32((void *)UMCTL2_BA + 0x36c,0x00110011);
+
+	//set PCTRL_0
+	outp32((void *)UMCTL2_BA + 0x490,0x00000001);
+
+	//set PCTRL_1
+	outp32((void *)UMCTL2_BA + 0x540,0x00000000);  //mod 20200323
+
+	//set PCTRL_2
+	outp32((void *)UMCTL2_BA + 0x5f0,0x00000000);  //mod 20200323
+
+	//set PCTRL_3
+	outp32((void *)UMCTL2_BA + 0x6a0,0x00000000);  //mod 20200323
+
+	//set PCTRL_4
+	outp32((void *)UMCTL2_BA + 0x750,0x00000000);  //mod 20200323
+
+	//set PCTRL_5
+	outp32((void *)UMCTL2_BA + 0x800,0x00000000);  //mod 20200323
+
+	//set PCTRL_6
+	outp32((void *)UMCTL2_BA + 0x8b0,0x00000001);
+
+	//set PCTRL_7
+	outp32((void *)UMCTL2_BA + 0x960,0x00000001);
+
+	//set PCCFG
+	outp32((void *)UMCTL2_BA + 0x400,0x00000000);
+
+	//set PCFGR_0
+	outp32((void *)UMCTL2_BA + 0x404,0x0001500f);  //mod 20200408
+
+	//set PCFGR_1
+	outp32((void *)UMCTL2_BA + 0x4b4,0x0001500f);  //mod 20200408
+
+	//set PCFGR_2
+	outp32((void *)UMCTL2_BA + 0x564,0x0001500f);  //mod 20200408
+
+	//set PCFGR_3
+	outp32((void *)UMCTL2_BA + 0x614,0x0001500f);  //mod 20200408
+
+	//set PCFGR_4
+	outp32((void *)UMCTL2_BA + 0x6c4,0x0001500f);  //mod 20200408
+
+	//set PCFGR_5
+	outp32((void *)UMCTL2_BA + 0x774,0x0001500f);  //mod 20200408
+
+	//set PCFGR_6
+	outp32((void *)UMCTL2_BA + 0x824,0x0001500f);  //mod 20200408
+
+	//set PCFGR_7
+	outp32((void *)UMCTL2_BA + 0x8d4,0x0001500f);  //mod 20200408
+
+	//set PCFGW_0
+	outp32((void *)UMCTL2_BA + 0x408,0x0000500f);  //mod 20200408
+
+	//set PCFGW_1
+	outp32((void *)UMCTL2_BA + 0x4b8,0x0000500f);  //mod 20200408
+
+	//set PCFGW_2
+	outp32((void *)UMCTL2_BA + 0x568,0x0000500f);  //mod 20200408
+
+	//set PCFGW_3
+	outp32((void *)UMCTL2_BA + 0x618,0x0000500f);  //mod 20200408
+
+	//set PCFGW_4
+	outp32((void *)UMCTL2_BA + 0x6c8,0x0000500f);  //mod 20200408
+
+	//set PCFGW_5
+	outp32((void *)UMCTL2_BA + 0x778,0x0000500f);  //mod 20200408
+
+	//set PCFGW_6
+	outp32((void *)UMCTL2_BA + 0x828,0x0000500f);  //mod 20200408
+
+	//set PCFGW_7
+	outp32((void *)UMCTL2_BA + 0x8d8,0x0000500f);  //mod 20200408
+
+	//set SARBASE0
+	outp32((void *)UMCTL2_BA + 0xf04,0x00000008);
+
+	//set SARSIZE0
+	outp32((void *)UMCTL2_BA + 0xf08,0x00000001);  //mod 20200507
+
+	//de-assert reset signals of DDR memory controller
+	outp32((void *)SYS_BA+0x20,(inp32((void *)SYS_BA+0x20) & 0x8fffffff));
+	while( (inp32((void *)SYS_BA+0x20) & 0x20000000) != 0x00000000);
+
+	//=====================================================================
+	//                  DDR PHY initialization
+	//=====================================================================
+
+	//set DSGCR,addr=16
+	outp32((void *)DDRPHY_BA + 0x040,0xf004649f);
+
+	//set PGCR1,addr=3
+	outp32((void *)DDRPHY_BA + 0x00c,0x0300c461);  //mod 20200608
+
+	//set PGCR2,addr=35
+	outp32((void *)DDRPHY_BA + 0x08c,0x00f0027f);  //mod 20210106
+
+	//set PTR0,addr=7
+	outp32((void *)DDRPHY_BA + 0x01c,0x0c806403);  //mod 20200306 for pclk=100mhz
+
+	//set PTR1,addr=8
+	outp32((void *)DDRPHY_BA + 0x020,0x27100385);  //mod 20200306 for pclk=100mhz
+
+	//set PTR2,addr=9
+	outp32((void *)DDRPHY_BA + 0x024,0x00083def);
+
+	//set PTR3,addr=10
+	outp32((void *)DDRPHY_BA + 0x028,0x0904111d);  //mod 20200504
+
+	//set PTR4,addr=11
+	outp32((void *)DDRPHY_BA + 0x02c,0x0801a072);  //mod 20200508
+
+	//set MR0,addr=21
+	outp32((void *)DDRPHY_BA + 0x054,0x00001b40);  //mod
+
+	//set MR1,addr=22
+	outp32((void *)DDRPHY_BA + 0x058,0x00000006);  //mod 20201109
+
+	//set MR2,addr=23
+	outp32((void *)DDRPHY_BA + 0x05c,0x00000048);  //mod 20200822
+
+	//set MR3,addr=24
+	outp32((void *)DDRPHY_BA + 0x060,0x00000000);
+
+	//set DTPR0,addr=18
+	outp32((void *)DDRPHY_BA + 0x048,0x71568855);
+
+	//set DTPR1,addr=19
+	outp32((void *)DDRPHY_BA + 0x04c,0x2284632a);  //mod 20201208
+
+	//set DTPR2,addr=20
+	outp32((void *)DDRPHY_BA + 0x050,0x30023e00);
+
+	//set ZQ0CR1,addr=97
+	outp32((void *)DDRPHY_BA + 0x184,0x0000105d);  //mod 20201109
+
+	//polling PGSR0 (addr=4) to 0x0000000f
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0x0000000f) != 0x0000000f);
+
+	//set DCR,addr=17
+	outp32((void *)DDRPHY_BA + 0x044,0x0000040b);
+
+	//set DTCR,addr=26
+	outp32((void *)DDRPHY_BA + 0x068,0x91003587);  //mod 20200820
+
+	//set PIR,addr=1
+	outp32((void *)DDRPHY_BA + 0x004,0x0000ff81);
+
+	//polling PGSR0 (addr=4) to 0xb0000fff
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0xffffffff) != 0xb0000fff);
+
+	//polling MCTL2 STAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x004) & 0x00000003) != 0x00000001);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x0000000b);  //mod 20191213
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//polling MCTL2 SWSTAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x324) & 0x00000001) != 0x00000001);
+
+}
+
+/* #define DDR3_1GB_1066MBPS_MICRON_INIT_BY_DDR32PHY */
+void ma35d1_mt_ddr3_1gb(void)
+{
+	INFO("MICRON DDR3 1GB\n");
+
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000001);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000001);  //mod
+
+	//polling to 0x00000000
+	//while((inp32((void *)UMCTL2_BA + 0x004) & 0x00000003) != 0x00000000);
+
+	//set MSTR
+	outp32((void *)UMCTL2_BA + 0x000,0x01040001);  //mod 20201204
+
+	//set MRCTRL0
+	outp32((void *)UMCTL2_BA + 0x010,0x0000d010);  //mod 20201204
+
+	//set MRCTRL1
+	outp32((void *)UMCTL2_BA + 0x014,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000000);  //add
+
+	//set PWRTMG
+	outp32((void *)UMCTL2_BA + 0x034,0x00400010);  //mod 20200421
+
+	//set HWLPCTL
+	outp32((void *)UMCTL2_BA + 0x038,0x000a0003);  //mod 20200121
+
+	//set RFSHCTL0
+	outp32((void *)UMCTL2_BA + 0x050,0x00210000);
+
+	//set RFSHCTL1
+	outp32((void *)UMCTL2_BA + 0x054,0x003c003c);
+
+	//set RFSHCTL3
+	outp32((void *)UMCTL2_BA + 0x060,0x00000000);  //mod 20191211
+
+	//set RFSHTMG
+	outp32((void *)UMCTL2_BA + 0x064,0x0020005e);  //mod 20210106
+
+	//set CRCPARCTL0
+	outp32((void *)UMCTL2_BA + 0x0c0,0x00000000);
+
+	//set INIT0
+	outp32((void *)UMCTL2_BA + 0x0d0,0x40020083);  //mod 20200505
+
+	//set INIT1
+	outp32((void *)UMCTL2_BA + 0x0d4,0x00350002);  //mod 20200505
+
+	//set INIT3
+	outp32((void *)UMCTL2_BA + 0x0dc,0x1b400006);  //mod 20201109
+
+	//set INIT4
+	outp32((void *)UMCTL2_BA + 0x0e0,0x00480000);  //mod 20200822
+
+	//set INIT5
+	outp32((void *)UMCTL2_BA + 0x0e4,0x00090000);
+
+	//set DIMMCTL
+	outp32((void *)UMCTL2_BA + 0x0f0,0x00000000);
+
+	//set RANKCTL
+	outp32((void *)UMCTL2_BA + 0x0f4,0x0000032f);
+
+	//set DRAMTMG0
+	outp32((void *)UMCTL2_BA + 0x100,0x090e080a);  //mod 20210108
+
+	//set DRAMTMG1
+	outp32((void *)UMCTL2_BA + 0x104,0x0003020e);
+
+	//set DRAMTMG2
+	outp32((void *)UMCTL2_BA + 0x108,0x00000407);
+
+	//set DRAMTMG3
+	outp32((void *)UMCTL2_BA + 0x10c,0x00003007);  //mod 20201208
+
+	//set DRAMTMG4
+	outp32((void *)UMCTL2_BA + 0x110,0x04020305);  //mod 20200529
+
+	//set DRAMTMG5
+	outp32((void *)UMCTL2_BA + 0x114,0x03030202);
+
+	//set DRAMTMG8
+	outp32((void *)UMCTL2_BA + 0x120,0x00000a04);
+
+	//set DRAMTMG15
+	outp32((void *)UMCTL2_BA + 0x13c,0x80000032);  //mod 20200225
+
+	//set ZQCTL0
+	outp32((void *)UMCTL2_BA + 0x180,0x00800020);
+
+	//set ZQCTL1
+	outp32((void *)UMCTL2_BA + 0x184,0x00000100);  //mod 20200505
+
+	//set DFITMG0
+	outp32((void *)UMCTL2_BA + 0x190,0x04020101);
+
+	//set DFITMG1
+	outp32((void *)UMCTL2_BA + 0x194,0x00060101);
+
+	//set DFILPCFG0
+#ifdef DFI_DDR_PHY_LP
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b131);  //mod 20200417
+#else
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b030);  //mod 20200825
+#endif
+
+	//set DFIUPD0
+	outp32((void *)UMCTL2_BA + 0x1a0,0x00400005);  //mod 20200303
+
+	//set DFIUPD1
+	outp32((void *)UMCTL2_BA + 0x1a4,0x00170066);  //mod 20200425
+
+	//set DFIUPD2
+	outp32((void *)UMCTL2_BA + 0x1a8,0x80000000);  //mod 20200309
+
+	//set DFIMISC
+	outp32((void *)UMCTL2_BA + 0x1b0,0x00000011);  //mod
+
+	//set DFIPHYMSTR
+	outp32((void *)UMCTL2_BA + 0x1c4,0x00000000);
+
+	//set ADDRMAP0
+	outp32((void *)UMCTL2_BA + 0x200,0x0000001f);  //mod 20201204
+
+	//set ADDRMAP1
+	outp32((void *)UMCTL2_BA + 0x204,0x00080808);
+
+	//set ADDRMAP2
+	outp32((void *)UMCTL2_BA + 0x208,0x00000000);
+
+	//set ADDRMAP3
+	outp32((void *)UMCTL2_BA + 0x20c,0x00000000);
+
+	//set ADDRMAP4
+	outp32((void *)UMCTL2_BA + 0x210,0x00001f1f);
+
+	//set ADDRMAP5
+	outp32((void *)UMCTL2_BA + 0x214,0x070f0707);
+
+	//set ADDRMAP6
+	outp32((void *)UMCTL2_BA + 0x218,0x07070707);  //mod 20200117,for 1G bytes
+
+	//set ADDRMAP9
+	outp32((void *)UMCTL2_BA + 0x224,0x07070707);
+
+	//set ADDRMAP10
+	outp32((void *)UMCTL2_BA + 0x228,0x07070707);
+
+	//set ADDRMAP11
+	outp32((void *)UMCTL2_BA + 0x22c,0x00000007);
+
+	//set ODTCFG
+	outp32((void *)UMCTL2_BA + 0x240,0x06000608);
+
+	//set ODTMAP
+	outp32((void *)UMCTL2_BA + 0x244,0x00000101);  //mod 20201204
+
+	//set SCHED
+	outp32((void *)UMCTL2_BA + 0x250,0x00f51f00);
+
+	//set SCHED1
+	outp32((void *)UMCTL2_BA + 0x254,0x00000000);
+
+	//set PERFHPR1
+	outp32((void *)UMCTL2_BA + 0x25c,0x0f000001);
+
+	//set PERFLPR1
+	outp32((void *)UMCTL2_BA + 0x264,0x0f00007f);
+
+	//set PERFWR1
+	outp32((void *)UMCTL2_BA + 0x26c,0x0f00007f);
+
+	//set DBG0
+	outp32((void *)UMCTL2_BA + 0x300,0x00000000);
+
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000000);
+
+	//set DBGCMD
+	outp32((void *)UMCTL2_BA + 0x30c,0x00000000);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//set SWCTLSTATIC
+	outp32((void *)UMCTL2_BA + 0x328,0x00000000);
+
+	//set POISONCFG
+	outp32((void *)UMCTL2_BA + 0x36c,0x00110011);
+
+	//set PCTRL_0
+	outp32((void *)UMCTL2_BA + 0x490,0x00000001);
+
+	//set PCTRL_1
+	outp32((void *)UMCTL2_BA + 0x540,0x00000000);  //mod 20200323
+
+	//set PCTRL_2
+	outp32((void *)UMCTL2_BA + 0x5f0,0x00000000);  //mod 20200323
+
+	//set PCTRL_3
+	outp32((void *)UMCTL2_BA + 0x6a0,0x00000000);  //mod 20200323
+
+	//set PCTRL_4
+	outp32((void *)UMCTL2_BA + 0x750,0x00000000);  //mod 20200323
+
+	//set PCTRL_5
+	outp32((void *)UMCTL2_BA + 0x800,0x00000000);  //mod 20200323
+
+	//set PCTRL_6
+	outp32((void *)UMCTL2_BA + 0x8b0,0x00000001);
+
+	//set PCTRL_7
+	outp32((void *)UMCTL2_BA + 0x960,0x00000001);
+
+	//set PCCFG
+	outp32((void *)UMCTL2_BA + 0x400,0x00000000);
+
+	//set PCFGR_0
+	outp32((void *)UMCTL2_BA + 0x404,0x0001500f);  //mod 20200408
+
+	//set PCFGR_1
+	outp32((void *)UMCTL2_BA + 0x4b4,0x0001500f);  //mod 20200408
+
+	//set PCFGR_2
+	outp32((void *)UMCTL2_BA + 0x564,0x0001500f);  //mod 20200408
+
+	//set PCFGR_3
+	outp32((void *)UMCTL2_BA + 0x614,0x0001500f);  //mod 20200408
+
+	//set PCFGR_4
+	outp32((void *)UMCTL2_BA + 0x6c4,0x0001500f);  //mod 20200408
+
+	//set PCFGR_5
+	outp32((void *)UMCTL2_BA + 0x774,0x0001500f);  //mod 20200408
+
+	//set PCFGR_6
+	outp32((void *)UMCTL2_BA + 0x824,0x0001500f);  //mod 20200408
+
+	//set PCFGR_7
+	outp32((void *)UMCTL2_BA + 0x8d4,0x0001500f);  //mod 20200408
+
+	//set PCFGW_0
+	outp32((void *)UMCTL2_BA + 0x408,0x0000500f);  //mod 20200408
+
+	//set PCFGW_1
+	outp32((void *)UMCTL2_BA + 0x4b8,0x0000500f);  //mod 20200408
+
+	//set PCFGW_2
+	outp32((void *)UMCTL2_BA + 0x568,0x0000500f);  //mod 20200408
+
+	//set PCFGW_3
+	outp32((void *)UMCTL2_BA + 0x618,0x0000500f);  //mod 20200408
+
+	//set PCFGW_4
+	outp32((void *)UMCTL2_BA + 0x6c8,0x0000500f);  //mod 20200408
+
+	//set PCFGW_5
+	outp32((void *)UMCTL2_BA + 0x778,0x0000500f);  //mod 20200408
+
+	//set PCFGW_6
+	outp32((void *)UMCTL2_BA + 0x828,0x0000500f);  //mod 20200408
+
+	//set PCFGW_7
+	outp32((void *)UMCTL2_BA + 0x8d8,0x0000500f);  //mod 20200408
+
+	//set SARBASE0
+	outp32((void *)UMCTL2_BA + 0xf04,0x00000008);
+
+	//set SARSIZE0
+	outp32((void *)UMCTL2_BA + 0xf08,0x00000003);  //mod 20201204
+
+	//de-assert reset signals of DDR memory controller
+	outp32((void *)SYS_BA+0x20,(inp32((void *)SYS_BA+0x20) & 0x8fffffff));
+	while( (inp32((void *)SYS_BA+0x20) & 0x20000000) != 0x00000000);
+
+	//=====================================================================
+	//                  DDR PHY initialization
+	//=====================================================================
+
+	//set DSGCR,addr=16
+	outp32((void *)DDRPHY_BA + 0x040,0xf004649f);
+
+	//set PGCR1,addr=3
+	outp32((void *)DDRPHY_BA + 0x00c,0x0300c461);  //mod 20200608
+
+	//set PGCR2,addr=35
+	outp32((void *)DDRPHY_BA + 0x08c,0x00f0068e);  //mod 20210106
+
+	//set PTR0,addr=7
+	outp32((void *)DDRPHY_BA + 0x01c,0x0c806403);  //mod 20200306 for pclk=100mhz
+
+	//set PTR1,addr=8
+	outp32((void *)DDRPHY_BA + 0x020,0x27100385);  //mod 20200306 for pclk=100mhz
+
+	//set PTR2,addr=9
+	outp32((void *)DDRPHY_BA + 0x024,0x00083def);
+
+	//set PTR3,addr=10
+	outp32((void *)DDRPHY_BA + 0x028,0x0c04111d);  //mod 20200511
+
+	//set PTR4,addr=11
+	outp32((void *)DDRPHY_BA + 0x02c,0x0801a072);  //mod 20200511
+
+	//set MR0,addr=21
+	outp32((void *)DDRPHY_BA + 0x054,0x00001b40);  //mod
+
+	//set MR1,addr=22
+	outp32((void *)DDRPHY_BA + 0x058,0x00000006);  //mod 20201109
+
+	//set MR2,addr=23
+	outp32((void *)DDRPHY_BA + 0x05c,0x00000048);  //mod 20200822
+
+	//set MR3,addr=24
+	outp32((void *)DDRPHY_BA + 0x060,0x00000000);
+
+	//set DTPR0,addr=18
+	outp32((void *)DDRPHY_BA + 0x048,0x75959955);  //mod 20200511
+
+	//set DTPR1,addr=19
+	outp32((void *)DDRPHY_BA + 0x04c,0x2285e36a);  //mod 20201208
+
+	//set DTPR2,addr=20
+	outp32((void *)DDRPHY_BA + 0x050,0x30023e00);
+
+	//set ZQ0CR1,addr=97
+	outp32((void *)DDRPHY_BA + 0x184,0x0000105d);  //mod 20201109
+
+	//polling PGSR0 (addr=4) to 0x0000000f
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0x0000000f) != 0x0000000f);
+
+	//set DCR,addr=17
+	outp32((void *)DDRPHY_BA + 0x044,0x0000040b);
+
+	//set DTCR,addr=26
+	outp32((void *)DDRPHY_BA + 0x068,0x91003587);  //mod 20201204
+
+	//set PIR,addr=1
+	outp32((void *)DDRPHY_BA + 0x004,0x0000ff81);
+
+	//polling PGSR0 (addr=4) to 0xb0000fff
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0xffffffff) != 0xb0000fff);
+
+	//polling MCTL2 STAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x004) & 0x00000003) != 0x00000001);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x0000000b);  //mod 20191213
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//polling MCTL2 SWSTAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x324) & 0x00000001) != 0x00000001);
+
+}
+
+/* #define DDR2_128MB_1066MBPS_WINBOND_INIT_BY_DDR32PHY */
+void ma35d1_wb_ddr2_128mb(void)
+{
+
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000001);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000001);  //mod
+
+	//polling to 0x00000000
+	//while((inp32((void *)UMCTL2_BA + 0x004) & 0x00000003) != 0x00000000);
+
+	//set MSTR
+	outp32((void *)UMCTL2_BA + 0x000,0x01040000);
+
+	//set MRCTRL0
+	outp32((void *)UMCTL2_BA + 0x010,0x00001010);  //mod 20200511
+
+	//set MRCTRL1
+	outp32((void *)UMCTL2_BA + 0x014,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000000);  //add
+
+	//set PWRTMG
+	outp32((void *)UMCTL2_BA + 0x034,0x00400010);  //mod 20200421
+
+	//set HWLPCTL
+	outp32((void *)UMCTL2_BA + 0x038,0x000a0003);  //mod 20200121
+
+	//set RFSHCTL0
+	outp32((void *)UMCTL2_BA + 0x050,0x00210000);
+
+	//set RFSHCTL1
+	outp32((void *)UMCTL2_BA + 0x054,0x003c003c);
+
+	//set RFSHCTL3
+	outp32((void *)UMCTL2_BA + 0x060,0x00000000);  //mod 20191211
+
+	//set RFSHTMG
+	outp32((void *)UMCTL2_BA + 0x064,0x00100022);  //mod 20210106
+
+	//set CRCPARCTL0
+	outp32((void *)UMCTL2_BA + 0x0c0,0x00000000);
+
+	//set INIT0
+	outp32((void *)UMCTL2_BA + 0x0d0,0x40020035);  //mod 20200309
+
+	//set INIT1
+	outp32((void *)UMCTL2_BA + 0x0d4,0x00010002);
+
+	//set INIT3
+	outp32((void *)UMCTL2_BA + 0x0dc,0x0e730000);  //mod 20220608
+
+	//set INIT4
+	outp32((void *)UMCTL2_BA + 0x0e0,0x00000080);  //mod 20220607
+
+	//set INIT5
+	outp32((void *)UMCTL2_BA + 0x0e4,0x00010000);
+
+	//set DIMMCTL
+	outp32((void *)UMCTL2_BA + 0x0f0,0x00000000);
+
+	//set RANKCTL
+	outp32((void *)UMCTL2_BA + 0x0f4,0x0000031f);
+
+	//set DRAMTMG0
+	outp32((void *)UMCTL2_BA + 0x100,0x0a0d110d);  //mod 20220608
+
+	//set DRAMTMG1
+	outp32((void *)UMCTL2_BA + 0x104,0x0003040f);  //mod 20220608
+
+	//set DRAMTMG2
+	outp32((void *)UMCTL2_BA + 0x108,0x00000407);  //mod 20200103
+
+	//set DRAMTMG3
+	outp32((void *)UMCTL2_BA + 0x10c,0x00001004);
+
+	//set DRAMTMG4
+	outp32((void *)UMCTL2_BA + 0x110,0x04010305);  //mod 20220608
+
+	//set DRAMTMG5
+	outp32((void *)UMCTL2_BA + 0x114,0x01010202);  //mod 20200103
+
+	//set DRAMTMG8
+	outp32((void *)UMCTL2_BA + 0x120,0x00000502);
+
+	//set DRAMTMG15
+	outp32((void *)UMCTL2_BA + 0x13c,0x80000032);  //mod 20200225
+
+	//set ZQCTL0
+	outp32((void *)UMCTL2_BA + 0x180,0xc0000000);
+
+	//set ZQCTL1
+	outp32((void *)UMCTL2_BA + 0x184,0x00074bf0);
+
+	//set DFITMG0
+	outp32((void *)UMCTL2_BA + 0x190,0x04020101);
+
+	//set DFITMG1
+	outp32((void *)UMCTL2_BA + 0x194,0x00060101);
+
+	//set DFILPCFG0
+#ifdef DFI_DDR_PHY_LP
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b131);  //mod 20200417
+#else
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b030);  //mod 20200825
+#endif
+
+	//set DFIUPD0
+	outp32((void *)UMCTL2_BA + 0x1a0,0x00400005);  //mod 20200303
+
+	//set DFIUPD1
+	outp32((void *)UMCTL2_BA + 0x1a4,0x00170066);  //mod 20200425
+
+	//set DFIUPD2
+	outp32((void *)UMCTL2_BA + 0x1a8,0x80000000);  //mod 20200309
+
+	//set DFIMISC
+	outp32((void *)UMCTL2_BA + 0x1b0,0x00000011);  //mod
+
+	//set DFIPHYMSTR
+	outp32((void *)UMCTL2_BA + 0x1c4,0x00000000);
+
+	//set ADDRMAP0
+	outp32((void *)UMCTL2_BA + 0x200,0x0000001f);
+
+	//set ADDRMAP1
+	outp32((void *)UMCTL2_BA + 0x204,0x00080808);
+
+	//set ADDRMAP2
+	outp32((void *)UMCTL2_BA + 0x208,0x00000000);
+
+	//set ADDRMAP3
+	outp32((void *)UMCTL2_BA + 0x20c,0x00000000);
+
+	//set ADDRMAP4
+	outp32((void *)UMCTL2_BA + 0x210,0x00001f1f);
+
+	//set ADDRMAP5
+	outp32((void *)UMCTL2_BA + 0x214,0x070f0707);
+
+	//set ADDRMAP6
+	outp32((void *)UMCTL2_BA + 0x218,0x0f0f0f07);
+
+	//set ADDRMAP9
+	outp32((void *)UMCTL2_BA + 0x224,0x07070707);
+
+	//set ADDRMAP10
+	outp32((void *)UMCTL2_BA + 0x228,0x07070707);
+
+	//set ADDRMAP11
+	outp32((void *)UMCTL2_BA + 0x22c,0x00000007);
+
+	//set ODTCFG
+	outp32((void *)UMCTL2_BA + 0x240,0x07010708);
+
+	//set ODTMAP
+	outp32((void *)UMCTL2_BA + 0x244,0x00000000);  //mod 20220606
+
+	//set SCHED
+	outp32((void *)UMCTL2_BA + 0x250,0x00f51f00);
+
+	//set SCHED1
+	outp32((void *)UMCTL2_BA + 0x254,0x00000000);
+
+	//set PERFHPR1
+	outp32((void *)UMCTL2_BA + 0x25c,0x0f000001);
+
+	//set PERFLPR1
+	outp32((void *)UMCTL2_BA + 0x264,0x0f00007f);
+
+	//set PERFWR1
+	outp32((void *)UMCTL2_BA + 0x26c,0x0f00007f);
+
+	//set DBG0
+	outp32((void *)UMCTL2_BA + 0x300,0x00000000);
+
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000000);
+
+	//set DBGCMD
+	outp32((void *)UMCTL2_BA + 0x30c,0x00000000);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//set SWCTLSTATIC
+	outp32((void *)UMCTL2_BA + 0x328,0x00000000);
+
+	//set POISONCFG
+	outp32((void *)UMCTL2_BA + 0x36c,0x00110011);
+
+	//set PCTRL_0
+	outp32((void *)UMCTL2_BA + 0x490,0x00000001);
+
+	//set PCTRL_1
+	outp32((void *)UMCTL2_BA + 0x540,0x00000000);  //mod 20200323
+
+	//set PCTRL_2
+	outp32((void *)UMCTL2_BA + 0x5f0,0x00000000);  //mod 20200323
+
+	//set PCTRL_3
+	outp32((void *)UMCTL2_BA + 0x6a0,0x00000000);  //mod 20200323
+
+	//set PCTRL_4
+	outp32((void *)UMCTL2_BA + 0x750,0x00000000);  //mod 20200323
+
+	//set PCTRL_5
+	outp32((void *)UMCTL2_BA + 0x800,0x00000001);  //mod 20201016
+
+	//set PCTRL_6
+	outp32((void *)UMCTL2_BA + 0x8b0,0x00000001);
+
+	//set PCCFG
+	outp32((void *)UMCTL2_BA + 0x400,0x00000000);
+
+	//set PCFGR_0
+	outp32((void *)UMCTL2_BA + 0x404,0x0001500f);  //mod 20200408
+
+	//set PCFGR_1
+	outp32((void *)UMCTL2_BA + 0x4b4,0x0001500f);  //mod 20200408
+
+	//set PCFGR_2
+	outp32((void *)UMCTL2_BA + 0x564,0x0001500f);  //mod 20200408
+
+	//set PCFGR_3
+	outp32((void *)UMCTL2_BA + 0x614,0x0001500f);  //mod 20200408
+
+	//set PCFGR_4
+	outp32((void *)UMCTL2_BA + 0x6c4,0x0001500f);  //mod 20200408
+
+	//set PCFGR_5
+	outp32((void *)UMCTL2_BA + 0x774,0x0001500f);  //mod 20200408
+
+	//set PCFGR_6
+	outp32((void *)UMCTL2_BA + 0x824,0x0001500f);  //mod 20200408
+
+	//set PCFGW_0
+	outp32((void *)UMCTL2_BA + 0x408,0x0000500f);  //mod 20200408
+
+	//set PCFGW_1
+	outp32((void *)UMCTL2_BA + 0x4b8,0x0000500f);  //mod 20200408
+
+	//set PCFGW_2
+	outp32((void *)UMCTL2_BA + 0x568,0x0000500f);  //mod 20200408
+
+	//set PCFGW_3
+	outp32((void *)UMCTL2_BA + 0x618,0x0000500f);  //mod 20200408
+
+	//set PCFGW_4
+	outp32((void *)UMCTL2_BA + 0x6c8,0x0000500f);  //mod 20200408
+
+	//set PCFGW_5
+	outp32((void *)UMCTL2_BA + 0x778,0x0000500f);  //mod 20200408
+
+	//set PCFGW_6
+	outp32((void *)UMCTL2_BA + 0x828,0x0000500f);  //mod 20200408
+
+	//set SARBASE0
+	outp32((void *)UMCTL2_BA + 0xf04,0x00000008);
+
+	//set SARSIZE0
+	outp32((void *)UMCTL2_BA + 0xf08,0x00000000);
+
+	//de-assert reset signals of DDR memory controller
+	outp32((void *)SYS_BA+0x20,(inp32((void *)SYS_BA+0x20) & 0x8fffffff));
+	while( (inp32((void *)SYS_BA+0x20) & 0x20000000) != 0x00000000);
+
+	//=====================================================================
+	//                  DDR PHY initialization
+	//=====================================================================
+
+	//set DSGCR,addr=16
+	outp32((void *)DDRPHY_BA + 0x040,0xf004649f);
+
+	//set PGCR1,addr=3
+	outp32((void *)DDRPHY_BA + 0x00c,0x0300c461);  //mod 20200608
+
+	//set PGCR2,addr=35
+	outp32((void *)DDRPHY_BA + 0x08c,0x00f0027f);  //mod 20210106
+
+	//set PTR0,addr=7
+	outp32((void *)DDRPHY_BA + 0x01c,0x0c806403);  //mod 20200306 for pclk=100mhz
+
+	//set PTR1,addr=8
+	outp32((void *)DDRPHY_BA + 0x020,0x27100385);  //mod 20200306 for pclk=100mhz
+
+	//set PTR2,addr=9
+	outp32((void *)DDRPHY_BA + 0x024,0x00083def);
+
+	//set PTR3,addr=10
+	outp32((void *)DDRPHY_BA + 0x028,0x0d61a072);
+
+	//set PTR4,addr=11
+	outp32((void *)DDRPHY_BA + 0x02c,0x0559a072);
+
+	//set MR0,addr=21
+	outp32((void *)DDRPHY_BA + 0x054,0x00000e73);  //mod 20200918
+
+	//set MR1,addr=22
+	outp32((void *)DDRPHY_BA + 0x058,0x00000000);  //mod 20220608
+
+	//set MR2,addr=23
+	outp32((void *)DDRPHY_BA + 0x05c,0x00000080);  //mod 20220607
+
+	//set MR3,addr=24
+	outp32((void *)DDRPHY_BA + 0x060,0x00000000);
+
+	//set DTPR0,addr=18
+	outp32((void *)DDRPHY_BA + 0x048,0x71997755);  //mod 20220608
+
+	//set DTPR1,addr=19
+	outp32((void *)DDRPHY_BA + 0x04c,0x22822b22);  //mod 20220608
+
+	//set DTPR2,addr=20
+	outp32((void *)DDRPHY_BA + 0x050,0x1001a8c8);  //mod 20220608
+
+	//set ZQ0CR1,addr=97
+	outp32((void *)DDRPHY_BA + 0x184,0x0000104b);  //mod 20201014
+
+	//polling PGSR0 (addr=4) to 0x0000000f
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0x0000000f) != 0x0000000f);
+
+	//set DCR,addr=17
+	outp32((void *)DDRPHY_BA + 0x044,0x0000040a);
+
+	//set DTCR,addr=26
+	outp32((void *)DDRPHY_BA + 0x068,0x91003587);
+
+	//set PIR,addr=1
+	outp32((void *)DDRPHY_BA + 0x004,0x0000f501);
+
+	//polling PGSR0 (addr=4) to 0xb0000f5f
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0xffffffff) != 0xb0000f5f);
+
+	//polling MCTL2 STAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x004) & 0x00000003) != 0x00000001);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x0000000b);  //mod 20191213
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//polling MCTL2 SWSTAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x324) & 0x00000001) != 0x00000001);
+
+
+}
+
+//#define DDR3_1GB_1066MBPS_ISSI_INIT_BY_DDR32PHY
+void ma35d1_issi_ddr3_1gb(void)
+{
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000001);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000001);
+
+	//polling to 0x00000000
+	//while((inp32(UMCTL2_BA + 0x004) & 0x00000003) != 0x00000000);
+
+	//set MSTR
+	outp32((void *)UMCTL2_BA + 0x000,0x01040001);
+
+	//set MRCTRL0
+	outp32((void *)UMCTL2_BA + 0x010,0x0000d010);
+
+	//set MRCTRL1
+	outp32((void *)UMCTL2_BA + 0x014,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000000);
+
+	//set PWRTMG
+	outp32((void *)UMCTL2_BA + 0x034,0x00400010);
+
+	//set HWLPCTL
+	outp32((void *)UMCTL2_BA + 0x038,0x000a0003);
+
+	//set RFSHCTL0
+	outp32((void *)UMCTL2_BA + 0x050,0x00210000);
+
+	//set RFSHCTL1
+	outp32((void *)UMCTL2_BA + 0x054,0x003c003c);
+
+	//set RFSHCTL3
+	outp32((void *)UMCTL2_BA + 0x060,0x00000000);
+
+	//set RFSHTMG
+	outp32((void *)UMCTL2_BA + 0x064,0x0010005e);  //mod 2021916
+
+	//set CRCPARCTL0
+	outp32((void *)UMCTL2_BA + 0x0c0,0x00000000);
+
+	//set INIT0
+	outp32((void *)UMCTL2_BA + 0x0d0,0x40020083);
+
+	//set INIT1
+	outp32((void *)UMCTL2_BA + 0x0d4,0x00350002);
+
+	//set INIT3
+	outp32((void *)UMCTL2_BA + 0x0dc,0x1b400006);
+
+	//set INIT4
+	outp32((void *)UMCTL2_BA + 0x0e0,0x00480000);
+
+	//set INIT5
+	outp32((void *)UMCTL2_BA + 0x0e4,0x00090000);
+
+	//set DIMMCTL
+	outp32((void *)UMCTL2_BA + 0x0f0,0x00000000);
+
+	//set RANKCTL
+	outp32((void *)UMCTL2_BA + 0x0f4,0x0000032f);
+
+	//set DRAMTMG0
+	outp32((void *)UMCTL2_BA + 0x100,0x090b040a);  //mod 20210916
+
+	//set DRAMTMG1
+	outp32((void *)UMCTL2_BA + 0x104,0x0002020e);  //mod 20210916
+
+	//set DRAMTMG2
+	outp32((void *)UMCTL2_BA + 0x108,0x00000407);
+
+	//set DRAMTMG3
+	outp32((void *)UMCTL2_BA + 0x10c,0x00002006);  //mod 20210916
+
+	//set DRAMTMG4
+	outp32((void *)UMCTL2_BA + 0x110,0x04020305);
+
+	//set DRAMTMG5
+	outp32((void *)UMCTL2_BA + 0x114,0x03030202);
+
+	//set DRAMTMG8
+	outp32((void *)UMCTL2_BA + 0x120,0x00000a04);
+
+	//set DRAMTMG15
+	outp32((void *)UMCTL2_BA + 0x13c,0x80000032);
+
+	//set ZQCTL0
+	outp32((void *)UMCTL2_BA + 0x180,0x00800020);
+
+	//set ZQCTL1
+	outp32((void *)UMCTL2_BA + 0x184,0x00000100);
+
+	//set DFITMG0
+	outp32((void *)UMCTL2_BA + 0x190,0x04020101);
+
+	//set DFITMG1
+	outp32((void *)UMCTL2_BA + 0x194,0x00060101);
+
+	//set DFILPCFG0
+#ifdef DFI_DDR_PHY_LP
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b131);
+#else
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b030);
+#endif
+
+	//set DFIUPD0
+	outp32((void *)UMCTL2_BA + 0x1a0,0x00400005);
+
+	//set DFIUPD1
+	outp32((void *)UMCTL2_BA + 0x1a4,0x00170066);
+
+	//set DFIUPD2
+	outp32((void *)UMCTL2_BA + 0x1a8,0x80000000);
+
+	//set DFIMISC
+	outp32((void *)UMCTL2_BA + 0x1b0,0x00000011);
+
+	//set DFIPHYMSTR
+	outp32((void *)UMCTL2_BA + 0x1c4,0x00000000);
+
+	//set ADDRMAP0
+	outp32((void *)UMCTL2_BA + 0x200,0x0000001f);
+
+	//set ADDRMAP1
+	outp32((void *)UMCTL2_BA + 0x204,0x00080808);
+
+	//set ADDRMAP2
+	outp32((void *)UMCTL2_BA + 0x208,0x00000000);
+
+	//set ADDRMAP3
+	outp32((void *)UMCTL2_BA + 0x20c,0x00000000);
+
+	//set ADDRMAP4
+	outp32((void *)UMCTL2_BA + 0x210,0x00001f1f);
+
+	//set ADDRMAP5
+	outp32((void *)UMCTL2_BA + 0x214,0x070f0707);
+
+	//set ADDRMAP6
+	outp32((void *)UMCTL2_BA + 0x218,0x07070707);  //for 1G bytes
+
+	//set ADDRMAP9
+	outp32((void *)UMCTL2_BA + 0x224,0x07070707);
+
+	//set ADDRMAP10
+	outp32((void *)UMCTL2_BA + 0x228,0x07070707);
+
+	//set ADDRMAP11
+	outp32((void *)UMCTL2_BA + 0x22c,0x00000007);
+
+	//set ODTCFG
+	outp32((void *)UMCTL2_BA + 0x240,0x06000608);
+
+	//set ODTMAP
+	outp32((void *)UMCTL2_BA + 0x244,0x00000101);
+
+	//set SCHED
+	outp32((void *)UMCTL2_BA + 0x250,0x00f51f00);
+
+	//set SCHED1
+	outp32((void *)UMCTL2_BA + 0x254,0x00000000);
+
+	//set PERFHPR1
+	outp32((void *)UMCTL2_BA + 0x25c,0x0f000001);
+
+	//set PERFLPR1
+	outp32((void *)UMCTL2_BA + 0x264,0x0f00007f);
+
+	//set PERFWR1
+	outp32((void *)UMCTL2_BA + 0x26c,0x0f00007f);
+
+	//set DBG0
+	outp32((void *)UMCTL2_BA + 0x300,0x00000000);
+
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000000);
+
+	//set DBGCMD
+	outp32((void *)UMCTL2_BA + 0x30c,0x00000000);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//set SWCTLSTATIC
+	outp32((void *)UMCTL2_BA + 0x328,0x00000000);
+
+	//set POISONCFG
+	outp32((void *)UMCTL2_BA + 0x36c,0x00110011);
+
+	//set PCTRL_0
+	outp32((void *)UMCTL2_BA + 0x490,0x00000001);
+
+	//set PCTRL_1
+	outp32((void *)UMCTL2_BA + 0x540,0x00000000);
+
+	//set PCTRL_2
+	outp32((void *)UMCTL2_BA + 0x5f0,0x00000000);
+
+	//set PCTRL_3
+	outp32((void *)UMCTL2_BA + 0x6a0,0x00000000);
+
+	//set PCTRL_4
+	outp32((void *)UMCTL2_BA + 0x750,0x00000000);
+
+	//set PCTRL_5
+	outp32((void *)UMCTL2_BA + 0x800,0x00000001);
+
+	//set PCTRL_6
+	outp32((void *)UMCTL2_BA + 0x8b0,0x00000001);
+
+	//set PCCFG
+	outp32((void *)UMCTL2_BA + 0x400,0x00000000);
+
+	//set PCFGR_0
+	outp32((void *)UMCTL2_BA + 0x404,0x0001500f);
+
+	//set PCFGR_1
+	outp32((void *)UMCTL2_BA + 0x4b4,0x0001500f);
+
+	//set PCFGR_2
+	outp32((void *)UMCTL2_BA + 0x564,0x0001500f);
+
+	//set PCFGR_3
+	outp32((void *)UMCTL2_BA + 0x614,0x0001500f);
+
+	//set PCFGR_4
+	outp32((void *)UMCTL2_BA + 0x6c4,0x0001500f);
+
+	//set PCFGR_5
+	outp32((void *)UMCTL2_BA + 0x774,0x0001500f);
+
+	//set PCFGR_6
+	outp32((void *)UMCTL2_BA + 0x824,0x0001500f);
+
+	//set PCFGW_0
+	outp32((void *)UMCTL2_BA + 0x408,0x0000500f);
+
+	//set PCFGW_1
+	outp32((void *)UMCTL2_BA + 0x4b8,0x0000500f);
+
+	//set PCFGW_2
+	outp32((void *)UMCTL2_BA + 0x568,0x0000500f);
+
+	//set PCFGW_3
+	outp32((void *)UMCTL2_BA + 0x618,0x0000500f);
+
+	//set PCFGW_4
+	outp32((void *)UMCTL2_BA + 0x6c8,0x0000500f);
+
+	//set PCFGW_5
+	outp32((void *)UMCTL2_BA + 0x778,0x0000500f);
+
+	//set PCFGW_6
+	outp32((void *)UMCTL2_BA + 0x828,0x0000500f);
+
+	//set SARBASE0
+	outp32((void *)UMCTL2_BA + 0xf04,0x00000008);
+
+	//set SARSIZE0
+	outp32((void *)UMCTL2_BA + 0xf08,0x00000003);
+
+	//de-assert reset signals of DDR memory controller
+	outp32((void *)SYS_BA+0x20,(inp32((void *)SYS_BA+0x20) & 0x8fffffff));
+	while( (inp32((void *)SYS_BA+0x20) & 0x20000000) != 0x00000000);
+
+	//=====================================================================
+	//                  DDR PHY initialization
+	//=====================================================================
+
+	//set DSGCR,addr=16
+	outp32((void *)DDRPHY_BA + 0x040,0xf004649f);
+
+	//set PGCR1,addr=3
+	outp32((void *)DDRPHY_BA + 0x00c,0x0300c461);
+
+	//set PGCR2,addr=35
+	outp32((void *)DDRPHY_BA + 0x08c,0x00f0027f);  //mod 20210916
+
+	//set PTR0,addr=7
+	outp32((void *)DDRPHY_BA + 0x01c,0x0c806403);  //for pclk=100mhz
+
+	//set PTR1,addr=8
+	outp32((void *)DDRPHY_BA + 0x020,0x27100385);  //for pclk=100mhz
+
+	//set PTR2,addr=9
+	outp32((void *)DDRPHY_BA + 0x024,0x00083def);
+
+	//set PTR3,addr=10
+	outp32((void *)DDRPHY_BA + 0x028,0x0c04111d);
+
+	//set PTR4,addr=11
+	outp32((void *)DDRPHY_BA + 0x02c,0x0801a072);
+
+	//set MR0,addr=21
+	outp32((void *)DDRPHY_BA + 0x054,0x00001b40);
+
+	//set MR1,addr=22
+	outp32((void *)DDRPHY_BA + 0x058,0x00000006);
+
+	//set MR2,addr=23
+	outp32((void *)DDRPHY_BA + 0x05c,0x00000048);
+
+	//set MR3,addr=24
+	outp32((void *)DDRPHY_BA + 0x060,0x00000000);
+
+	//set DTPR0,addr=18
+	outp32((void *)DDRPHY_BA + 0x048,0x6d548855);  //mod 20210916
+
+	//set DTPR1,addr=19
+	outp32((void *)DDRPHY_BA + 0x04c,0x1a85e2c0);  //mod 20210922
+
+	//set DTPR2,addr=20
+	outp32((void *)DDRPHY_BA + 0x050,0x30023e00);
+
+	//set ZQ0CR1,addr=97
+	outp32((void *)DDRPHY_BA + 0x184,0x0000105d);
+
+	//polling PGSR0 (addr=4) to 0x0000000f
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0x0000000f) != 0x0000000f);
+
+	//set DCR,addr=17
+	outp32((void *)DDRPHY_BA + 0x044,0x0000040b);
+
+	//set DTCR,addr=26
+	outp32((void *)DDRPHY_BA + 0x068,0x91003587);
+
+	//set PIR,addr=1
+	outp32((void *)DDRPHY_BA + 0x004,0x0000ff81);
+
+	//polling PGSR0 (addr=4) to 0xb0000fff
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0xffffffff) != 0xb0000fff);
+
+	//polling MCTL2 STAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x004) & 0x00000003) != 0x00000001);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x0000000b);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//polling MCTL2 SWSTAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x324) & 0x00000001) != 0x00000001);
+
+}
+
+//#define DDR3_1GB_1066MBPS_ZENTEL_INIT_BY_DDR32PHY
+void ma35d1_zentel_ddr3_1gb(void)
+{
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000001);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000001);  //mod
+
+	//polling to 0x00000000
+	//while((inp32(UMCTL2_BA + 0x004) & 0x00000003) != 0x00000000);
+
+	//set MSTR
+	outp32((void *)UMCTL2_BA + 0x000,0x01040001);  //mod 20201204
+
+	//set MRCTRL0
+	outp32((void *)UMCTL2_BA + 0x010,0x0000d010);  //mod 20201204
+
+	//set MRCTRL1
+	outp32((void *)UMCTL2_BA + 0x014,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x00000000);  //add
+
+	//set PWRTMG
+	outp32((void *)UMCTL2_BA + 0x034,0x00400010);  //mod 20200421
+
+	//set HWLPCTL
+	outp32((void *)UMCTL2_BA + 0x038,0x000a0003);  //mod 20200121
+
+	//set RFSHCTL0
+	outp32((void *)UMCTL2_BA + 0x050,0x00210000);
+
+	//set RFSHCTL1
+	outp32((void *)UMCTL2_BA + 0x054,0x003c003c);
+
+	//set RFSHCTL3
+	outp32((void *)UMCTL2_BA + 0x060,0x00000000);  //mod 20191211
+
+	//set RFSHTMG
+	outp32((void *)UMCTL2_BA + 0x064,0x0020005e);  //mod 20210106
+
+	//set CRCPARCTL0
+	outp32((void *)UMCTL2_BA + 0x0c0,0x00000000);
+
+	//set INIT0
+	outp32((void *)UMCTL2_BA + 0x0d0,0x40020083);  //mod 20200505
+
+	//set INIT1
+	outp32((void *)UMCTL2_BA + 0x0d4,0x00350002);  //mod 20200505
+
+	//set INIT3
+	outp32((void *)UMCTL2_BA + 0x0dc,0x1b400006);  //mod 20201109
+
+	//set INIT4
+	outp32((void *)UMCTL2_BA + 0x0e0,0x00480000);  //mod 20200822
+
+	//set INIT5
+	outp32((void *)UMCTL2_BA + 0x0e4,0x00090000);
+
+	//set DIMMCTL
+	outp32((void *)UMCTL2_BA + 0x0f0,0x00000000);
+
+	//set RANKCTL
+	outp32((void *)UMCTL2_BA + 0x0f4,0x0000032f);
+
+	//set DRAMTMG0
+	outp32((void *)UMCTL2_BA + 0x100,0x090b080a);  //mod 20211222
+
+	//set DRAMTMG1
+	outp32((void *)UMCTL2_BA + 0x104,0x0003020e);
+
+	//set DRAMTMG2
+	outp32((void *)UMCTL2_BA + 0x108,0x00000407);
+
+	//set DRAMTMG3
+	outp32((void *)UMCTL2_BA + 0x10c,0x00002006);  //mod 20211222
+
+	//set DRAMTMG4
+	outp32((void *)UMCTL2_BA + 0x110,0x04020205);  //mod 20211222
+
+	//set DRAMTMG5
+	outp32((void *)UMCTL2_BA + 0x114,0x03030202);
+
+	//set DRAMTMG8
+	outp32((void *)UMCTL2_BA + 0x120,0x00000a04);
+
+	//set DRAMTMG15
+	outp32((void *)UMCTL2_BA + 0x13c,0x80000032);  //mod 20200225
+
+	//set ZQCTL0
+	outp32((void *)UMCTL2_BA + 0x180,0x00800020);
+
+	//set ZQCTL1
+	outp32((void *)UMCTL2_BA + 0x184,0x00000100);  //mod 20200505
+
+	//set DFITMG0
+	outp32((void *)UMCTL2_BA + 0x190,0x04020101);
+
+	//set DFITMG1
+	outp32((void *)UMCTL2_BA + 0x194,0x00060101);
+
+	//set DFILPCFG0
+#ifdef DFI_DDR_PHY_LP
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b131);  //mod 20200417
+#else
+	outp32((void *)UMCTL2_BA + 0x198,0x0700b030);  //mod 20200825
+#endif
+
+	//set DFIUPD0
+	outp32((void *)UMCTL2_BA + 0x1a0,0x00400005);  //mod 20200303
+
+	//set DFIUPD1
+	outp32((void *)UMCTL2_BA + 0x1a4,0x00170066);  //mod 20200425
+
+	//set DFIUPD2
+	outp32((void *)UMCTL2_BA + 0x1a8,0x80000000);  //mod 20200309
+
+	//set DFIMISC
+	outp32((void *)UMCTL2_BA + 0x1b0,0x00000011);  //mod
+
+	//set DFIPHYMSTR
+	outp32((void *)UMCTL2_BA + 0x1c4,0x00000000);
+
+	//set ADDRMAP0
+	outp32((void *)UMCTL2_BA + 0x200,0x0000001f);  //mod 20201204
+
+	//set ADDRMAP1
+	outp32((void *)UMCTL2_BA + 0x204,0x00080808);
+
+	//set ADDRMAP2
+	outp32((void *)UMCTL2_BA + 0x208,0x00000000);
+
+	//set ADDRMAP3
+	outp32((void *)UMCTL2_BA + 0x20c,0x00000000);
+
+	//set ADDRMAP4
+	outp32((void *)UMCTL2_BA + 0x210,0x00001f1f);
+
+	//set ADDRMAP5
+	outp32((void *)UMCTL2_BA + 0x214,0x070f0707);
+
+	//set ADDRMAP6
+	outp32((void *)UMCTL2_BA + 0x218,0x07070707);  //mod 20200117,for 1G bytes
+
+	//set ADDRMAP9
+	outp32((void *)UMCTL2_BA + 0x224,0x07070707);
+
+	//set ADDRMAP10
+	outp32((void *)UMCTL2_BA + 0x228,0x07070707);
+
+	//set ADDRMAP11
+	outp32((void *)UMCTL2_BA + 0x22c,0x00000007);
+
+	//set ODTCFG
+	outp32((void *)UMCTL2_BA + 0x240,0x06000608);
+
+	//set ODTMAP
+	outp32((void *)UMCTL2_BA + 0x244,0x00000101);  //mod 20201204
+
+	//set SCHED
+	outp32((void *)UMCTL2_BA + 0x250,0x00f51f00);
+
+	//set SCHED1
+	outp32((void *)UMCTL2_BA + 0x254,0x00000000);
+
+	//set PERFHPR1
+	outp32((void *)UMCTL2_BA + 0x25c,0x0f000001);
+
+	//set PERFLPR1
+	outp32((void *)UMCTL2_BA + 0x264,0x0f00007f);
+
+	//set PERFWR1
+	outp32((void *)UMCTL2_BA + 0x26c,0x0f00007f);
+
+	//set DBG0
+	outp32((void *)UMCTL2_BA + 0x300,0x00000000);
+
+	//set DBG1
+	outp32((void *)UMCTL2_BA + 0x304,0x00000000);
+
+	//set DBGCMD
+	outp32((void *)UMCTL2_BA + 0x30c,0x00000000);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//set SWCTLSTATIC
+	outp32((void *)UMCTL2_BA + 0x328,0x00000000);
+
+	//set POISONCFG
+	outp32((void *)UMCTL2_BA + 0x36c,0x00110011);
+
+	//set PCTRL_0
+	outp32((void *)UMCTL2_BA + 0x490,0x00000001);
+
+	//set PCTRL_1
+	outp32((void *)UMCTL2_BA + 0x540,0x00000000);  //mod 20200323
+
+	//set PCTRL_2
+	outp32((void *)UMCTL2_BA + 0x5f0,0x00000000);  //mod 20200323
+
+	//set PCTRL_3
+	outp32((void *)UMCTL2_BA + 0x6a0,0x00000000);  //mod 20200323
+
+	//set PCTRL_4
+	outp32((void *)UMCTL2_BA + 0x750,0x00000000);  //mod 20200323
+
+	//set PCTRL_5
+	outp32((void *)UMCTL2_BA + 0x800,0x00000001);  //mod 20201204
+
+	//set PCTRL_6
+	outp32((void *)UMCTL2_BA + 0x8b0,0x00000001);
+
+	//set PCCFG
+	outp32((void *)UMCTL2_BA + 0x400,0x00000000);
+
+	//set PCFGR_0
+	outp32((void *)UMCTL2_BA + 0x404,0x0001500f);  //mod 20200408
+
+	//set PCFGR_1
+	outp32((void *)UMCTL2_BA + 0x4b4,0x0001500f);  //mod 20200408
+
+	//set PCFGR_2
+	outp32((void *)UMCTL2_BA + 0x564,0x0001500f);  //mod 20200408
+
+	//set PCFGR_3
+	outp32((void *)UMCTL2_BA + 0x614,0x0001500f);  //mod 20200408
+
+	//set PCFGR_4
+	outp32((void *)UMCTL2_BA + 0x6c4,0x0001500f);  //mod 20200408
+
+	//set PCFGR_5
+	outp32((void *)UMCTL2_BA + 0x774,0x0001500f);  //mod 20200408
+
+	//set PCFGR_6
+	outp32((void *)UMCTL2_BA + 0x824,0x0001500f);  //mod 20200408
+
+	//set PCFGW_0
+	outp32((void *)UMCTL2_BA + 0x408,0x0000500f);  //mod 20200408
+
+	//set PCFGW_1
+	outp32((void *)UMCTL2_BA + 0x4b8,0x0000500f);  //mod 20200408
+
+	//set PCFGW_2
+	outp32((void *)UMCTL2_BA + 0x568,0x0000500f);  //mod 20200408
+
+	//set PCFGW_3
+	outp32((void *)UMCTL2_BA + 0x618,0x0000500f);  //mod 20200408
+
+	//set PCFGW_4
+	outp32((void *)UMCTL2_BA + 0x6c8,0x0000500f);  //mod 20200408
+
+	//set PCFGW_5
+	outp32((void *)UMCTL2_BA + 0x778,0x0000500f);  //mod 20200408
+
+	//set PCFGW_6
+	outp32((void *)UMCTL2_BA + 0x828,0x0000500f);  //mod 20200408
+
+	//set SARBASE0
+	outp32((void *)UMCTL2_BA + 0xf04,0x00000008);
+
+	//set SARSIZE0
+	outp32((void *)UMCTL2_BA + 0xf08,0x00000003);  //mod 20201204
+
+	//de-assert reset signals of DDR memory controller
+	outp32((void *)SYS_BA+0x20,(inp32((void *)SYS_BA+0x20) & 0x8fffffff));
+	while( (inp32((void *)SYS_BA+0x20) & 0x20000000) != 0x00000000);
+
+	//=====================================================================
+	//                  DDR PHY initialization
+	//=====================================================================
+
+	//set DSGCR,addr=16
+	outp32((void *)DDRPHY_BA + 0x040,0xf004649f);
+
+	//set PGCR1,addr=3
+	outp32((void *)DDRPHY_BA + 0x00c,0x0300c461);  //mod 20200608
+
+	//set PGCR2,addr=35
+	outp32((void *)DDRPHY_BA + 0x08c,0x00f0068e);  //mod 20210106
+
+	//set PTR0,addr=7
+	outp32((void *)DDRPHY_BA + 0x01c,0x0c806403);  //mod 20200306 for pclk=100mhz
+
+	//set PTR1,addr=8
+	outp32((void *)DDRPHY_BA + 0x020,0x27100385);  //mod 20200306 for pclk=100mhz
+
+	//set PTR2,addr=9
+	outp32((void *)DDRPHY_BA + 0x024,0x00083def);
+
+	//set PTR3,addr=10
+	outp32((void *)DDRPHY_BA + 0x028,0x0c04111d);  //mod 20200511
+
+	//set PTR4,addr=11
+	outp32((void *)DDRPHY_BA + 0x02c,0x0801a072);  //mod 20200511
+
+	//set MR0,addr=21
+	outp32((void *)DDRPHY_BA + 0x054,0x00001b40);  //mod
+
+	//set MR1,addr=22
+	outp32((void *)DDRPHY_BA + 0x058,0x00000006);  //mod 20201109
+
+	//set MR2,addr=23
+	outp32((void *)DDRPHY_BA + 0x05c,0x00000048);  //mod 20200822
+
+	//set MR3,addr=24
+	outp32((void *)DDRPHY_BA + 0x060,0x00000000);
+
+	//set DTPR0,addr=18
+	outp32((void *)DDRPHY_BA + 0x048,0x6d558855);  //mod 20211222
+
+	//set DTPR1,addr=19
+	outp32((void *)DDRPHY_BA + 0x04c,0x2285e2ca);  //mod 20211222
+
+	//set DTPR2,addr=20
+	outp32((void *)DDRPHY_BA + 0x050,0x30023e00);
+
+	//set ZQ0CR1,addr=97
+	outp32((void *)DDRPHY_BA + 0x184,0x0000105d);  //mod 20201109
+
+	//polling PGSR0 (addr=4) to 0x0000000f
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0x0000000f) != 0x0000000f);
+
+	//set DCR,addr=17
+	outp32((void *)DDRPHY_BA + 0x044,0x0000040b);
+
+	//set DTCR,addr=26
+	outp32((void *)DDRPHY_BA + 0x068,0x91003587);  //mod 20201204
+
+	//set PIR,addr=1
+	outp32((void *)DDRPHY_BA + 0x004,0x0000ff81);
+
+	//polling PGSR0 (addr=4) to 0xb0000fff
+	while((inp32((void *)DDRPHY_BA + 0x010) & 0xffffffff) != 0xb0000fff);
+
+	//polling MCTL2 STAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x004) & 0x00000003) != 0x00000001);
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000000);
+
+	//set PWRCTL
+	outp32((void *)UMCTL2_BA + 0x030,0x0000000b);  //mod 20191213
+
+	//set SWCTL
+	outp32((void *)UMCTL2_BA + 0x320,0x00000001);
+
+	//polling MCTL2 SWSTAT to 0x00000001
+	while((inp32((void *)UMCTL2_BA + 0x324) & 0x00000001) != 0x00000001);
+
+}
+
+
+static void *fdt = (void *)(uintptr_t)MA35D1_DTB_BASE;
+
+void ma35d1_ddr_init(void)
+{
+	uint32_t  clk_sel0;
+
+	clk_sel0 = inp32(CLK_BA + 0x18);
+
+	/* set SYS_CLK0, DCUltra, and GFX clock from SYS_PLL, instead of EPLL */
+	outp32(CLK_BA + 0x18, 0xd000015);
+
+	//Set TAHBCKEN,CM4CKEN,CA35CKEN,DDR6CKEN,GFXCKEN,VC8KCKEN,DCUCKEN,GMAC0CKEN,GMAC1CKEN,CAP0CKEN,CAP1CKEN
+	outp32(CLK_BA + 0x04, (inp32(CLK_BA + 0x04) | 0x7F000037));
+	outp32(CLK_BA + 0x0C, (inp32(CLK_BA + 0x0C) | 0x40000000));
+
+	/* DDR control register clock gating disable */
+	outp32(SYS_BA + 0x70, (inp32(SYS_BA + 0x70) | 0x00800000));
+	/* de-assert presetn of MCTL2 */
+	outp32(SYS_BA + 0x20, (inp32(SYS_BA + 0x20) & 0xafffffff));
+	while((inp32(SYS_BA + 0x20) & 0x50000000) != 0x00000000);
+	//set MCTLCRST to 1
+	outp32(SYS_BA + 0x20, (inp32(SYS_BA + 0x20) | 0x20000000));
+
+	/* read DTB */
+	/* get device tree information */
+	if (fdt_check_header(fdt) < 0) {
+		WARN("device tree header check error.\n");
+	}
+
+	if (fdt_node_offset_by_compatible(fdt, -1, "wb-ddr3-256mb") >= 0) {
+		ma35d1_wb_ddr3_256mb();
+	} else if (fdt_node_offset_by_compatible(fdt, -1, "wb-ddr3-512mb") >= 0) {
+		ma35d1_wb_ddr3_512mb();
+	} else if (fdt_node_offset_by_compatible(fdt, -1, "mt-ddr3-1gb") >= 0) {
+		ma35d1_mt_ddr3_1gb();
+	} else if (fdt_node_offset_by_compatible(fdt, -1, "wb-ddr2-128mb") >= 0) {
+		ma35d1_wb_ddr2_128mb();
+	} else if (fdt_node_offset_by_compatible(fdt, -1, "issi-ddr3-1gb") >= 0) {
+		ma35d1_issi_ddr3_1gb();
+	} else if (fdt_node_offset_by_compatible(fdt, -1, "zentel-ddr3-1gb") >= 0) {
+		ma35d1_zentel_ddr3_1gb();
+	} else {
+		WARN("The compatible property ddr type not found\n");
+	}
+
+	outp32((void *)UMCTL2_BA+0x490, 0x1);
+	outp32((void *)UMCTL2_BA+0x8b0, 0x1);
+	outp32((void *)UMCTL2_BA+0x960, 0x1);
+
+	outp32((void *)UMCTL2_BA+0x540, 0x1);
+	outp32((void *)UMCTL2_BA+0x5f0, 0x1);
+	outp32((void *)UMCTL2_BA+0x6a0, 0x1);
+	outp32((void *)UMCTL2_BA+0x750, 0x1);
+	outp32((void *)UMCTL2_BA+0x800, 0x1);
+
+	outp32(SYS_BA + 0x70,(inp32(SYS_BA + 0x70) & ~0x00800000));	/* DDR control register clock gating enable */
+	outp32(CLK_BA + 0x04, 0x35);
+
+	/* restore CLK_SEL0 */
+	outp32(CLK_BA + 0x18, clk_sel0);
+}
+
diff --git a/drivers/nuvoton/nand/ma35d1_nand.c b/drivers/nuvoton/nand/ma35d1_nand.c
new file mode 100644
index 0000000..7e93eef
--- /dev/null
+++ b/drivers/nuvoton/nand/ma35d1_nand.c
@@ -0,0 +1,604 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include <libfdt.h>
+
+#include <plat/common/platform.h>
+#include <platform_def.h>
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/delay_timer.h>
+#include <drivers/io/io_block.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#include <drivers/nuvoton/ma35d1_nand.h>
+
+#define SZ_128M		128U
+
+struct ma35d1_nand_info {
+	int pages_per_block;
+	int page_size;
+	int oob_size;
+	int max_bit_corr;
+	long size;	/* nand total size */
+	long offset;	/* image offset in nand */
+};
+
+struct ma35d1_nand_info ma35d1_nand;
+
+
+/*--------------------------------------------------*/
+// define the total padding bytes for 512/1024 data segment
+#define BCH_PADDING_LEN_512     32
+#define BCH_PADDING_LEN_1024    64
+// define the BCH parity code length for 512 bytes data pattern
+#define BCH_PARITY_LEN_T8       15
+#define BCH_PARITY_LEN_T12      23
+// define the BCH parity code length for 1024 bytes data pattern
+#define BCH_PARITY_LEN_T24      45
+
+
+/*********************************************************/
+int ma35d1_nand_wait_ready(unsigned long delay)
+{
+#if 0
+	uint64_t timeout;
+
+	timeout = timeout_init_us(delay);
+	while (!timeout_elapsed(timeout)) {
+		if ((mmio_read_32(REG_NANDINTSTS) & 0x400)) {
+			mmio_write_32(REG_NANDINTSTS, 0x400);
+			return 0;
+		}
+	}
+	return -ETIMEDOUT;
+#endif
+	while (1) {
+		if ((mmio_read_32(REG_NANDINTSTS) & 0x400)) {
+			mmio_write_32(REG_NANDINTSTS, 0x400);
+			return 0;
+		}
+	}
+	return 0;
+}
+
+int ma35d1_nand_reset(void)
+{
+	mmio_write_32(REG_NANDINTSTS, 0x400);   /* RB0_IF */
+
+	mmio_write_32(REG_NANDCMD, NAND_CMD_RESET);       /* RESET command */
+
+	/* delay for NAND flash tWB time */
+	udelay(100);
+
+	if (ma35d1_nand_wait_ready(1))
+		return -ETIMEDOUT;
+	else
+		return 0;
+}
+
+static void ma35d1_nand_read_oob(struct ma35d1_nand_info *nand, unsigned int page)
+{
+	int volatile i;
+	unsigned char *ptr;
+
+	ma35d1_nand_reset();
+
+	/* set READ command */
+	mmio_write_32(REG_NANDCMD, NAND_CMD_READ_1ST);       // READ 1st cycle command
+	mmio_write_32(REG_NANDADDR, nand->page_size & 0xff);
+	mmio_write_32(REG_NANDADDR, (nand->page_size >> 8) & 0xff);
+
+	mmio_write_32(REG_NANDADDR, page & 0xff);
+	if (nand->size > SZ_128M) {
+		mmio_write_32(REG_NANDADDR, (page >> 8) & 0xff);
+		mmio_write_32(REG_NANDADDR, ((page >> 16) & 0xff) | NAND_EOA);
+	} else {
+		mmio_write_32(REG_NANDADDR, ((page >> 8) & 0xff) | NAND_EOA);
+	}
+
+	mmio_write_32(REG_NANDCMD, NAND_CMD_READ_2ND);       // READ 2nd cycle command
+
+	ma35d1_nand_wait_ready(1);
+
+	ptr = (unsigned char *)REG_NANDRA0;
+	for (i=0; i<nand->oob_size; i++)
+		*(unsigned char*) ptr++ = inp8(REG_NANDDATA);
+}
+
+
+static void ma35d1_correct_data(unsigned char ucFieidIndex, unsigned char ucErrorCnt, unsigned char* pDAddr)
+{
+	unsigned int uaData[24], uaAddr[24];
+	unsigned int uaErrorData[6];
+	unsigned char  i, j;
+	unsigned int uPageSize;
+	unsigned int field_len, padding_len, parity_len;
+	unsigned int total_field_num;
+	unsigned char  *smra_index;
+
+	//--- assign some parameters for different BCH and page size
+	field_len   = 512;
+	padding_len = BCH_PADDING_LEN_512;
+
+	switch (mmio_read_32(REG_NANDCTL) & BCH_TSEL)
+	{
+		case BCH_24:
+			field_len   = 1024;
+			padding_len = BCH_PADDING_LEN_1024;
+			parity_len  = BCH_PARITY_LEN_T24;
+			break;
+		case BCH_12:
+			parity_len  = BCH_PARITY_LEN_T12;
+			break;
+		case BCH_8:
+			parity_len  = BCH_PARITY_LEN_T8;
+			break;
+		default:
+			WARN("error BCH\n");
+			panic();
+	}
+
+	uPageSize = mmio_read_32(REG_NANDCTL) & PSIZE;
+	switch (uPageSize)
+	{
+		case PSIZE_8K:  total_field_num = 8192 / field_len; break;
+		case PSIZE_4K:  total_field_num = 4096 / field_len; break;
+		case PSIZE_2K:  total_field_num = 2048 / field_len; break;
+		default:
+			return;
+	}
+
+	//--- got valid BCH_ECC_DATAx and parse them to uaData[]
+	// got the valid register number of BCH_ECC_DATAx since one register include 4 error bytes
+	j = ucErrorCnt/4;
+	j ++;
+	if (j > 6)
+		j = 6;     // there are 6 BCH_ECC_DATAx registers to support BCH T24
+
+	for(i=0; i<j; i++)
+	{
+		uaErrorData[i] = mmio_read_32(REG_NANDECCED0 + i*4);
+	}
+
+	for(i=0; i<j; i++)
+	{
+		uaData[i*4+0] = uaErrorData[i] & 0xff;
+		uaData[i*4+1] = (uaErrorData[i]>>8) & 0xff;
+		uaData[i*4+2] = (uaErrorData[i]>>16) & 0xff;
+		uaData[i*4+3] = (uaErrorData[i]>>24) & 0xff;
+	}
+
+	//--- got valid REG_BCH_ECC_ADDRx and parse them to uaAddr[]
+	// got the valid register number of REG_BCH_ECC_ADDRx since one register include 2 error addresses
+	j = ucErrorCnt/2;
+	j ++;
+	if (j > 12)
+		j = 12;    // there are 12 REG_BCH_ECC_ADDRx registers to support BCH T24
+
+	for(i=0; i<j; i++)
+	{
+		uaAddr[i*2+0] = mmio_read_32(REG_NANDECCEA0 + i*4) & 0x07ff;   // 11 bits for error address
+		uaAddr[i*2+1] = (mmio_read_32(REG_NANDECCEA0 + i*4)>>16) & 0x07ff;
+	}
+
+	//--- pointer to begin address of field that with data error
+	pDAddr += (ucFieidIndex-1) * field_len;
+
+	//--- correct each error bytes
+	for(i=0; i<ucErrorCnt; i++)
+	{
+		// for wrong data in field
+		if (uaAddr[i] < field_len)
+		{
+			*(pDAddr+uaAddr[i]) ^= uaData[i];
+		}
+		// for wrong first-3-bytes in redundancy area
+		else if (uaAddr[i] < (field_len+3))
+		{
+			uaAddr[i] -= field_len;
+			uaAddr[i] += (parity_len*(ucFieidIndex-1));    // field offset
+
+			*((unsigned char *)REG_NANDRA0+uaAddr[i]) ^= uaData[i];
+		}
+		// for wrong parity code in redundancy area
+		else
+		{
+			// BCH_ERR_ADDRx = [data in field] + [3 bytes] + [xx] + [parity code]
+			//                                   |<--     padding bytes      -->|
+			// The BCH_ERR_ADDRx for last parity code always = field size + padding size.
+			// So, the first parity code = field size + padding size - parity code length.
+			// For example, for BCH T12, the first parity code = 512 + 32 - 23 = 521.
+			// That is, error byte address offset within field is
+			uaAddr[i] = uaAddr[i] - (field_len + padding_len - parity_len);
+
+			// smra_index point to the first parity code of first field in register SMRA0~n
+			smra_index = (unsigned char *)(long)(REG_NANDRA0 + (mmio_read_32(REG_NANDRACTL) & REA128_EXT) - // bottom of all parity code -
+						  (parity_len * total_field_num)                            // byte count of all parity code
+						 );
+
+			// final address = first parity code of first field +
+			//                 offset of fields +
+			//                 offset within field
+			*((unsigned char *)smra_index + (parity_len * (ucFieidIndex-1)) + uaAddr[i]) ^= uaData[i];
+		}
+	}   // end of for (i<ucErrorCnt)
+}
+
+
+static int ma35d1_nand_read_page(struct ma35d1_nand_info *nand, unsigned int page, uintptr_t buffer)
+{
+	unsigned int volatile uStatus, uErrorCnt;
+	unsigned int volatile uF1_status;
+	unsigned char volatile i, j, uLoop;
+
+	//INFO(">%s page %i buffer %lx\n", __func__, page, buffer);
+
+	if (nand->max_bit_corr != 0)    /* ECC_EN */
+		ma35d1_nand_read_oob(nand, page);
+
+	mmio_write_32(REG_NANDCTL, mmio_read_32(REG_NANDCTL) & ~REDUN_REN);
+	/* enable DMAC */
+	mmio_write_32(REG_FMI_DMACTL, 0x1); /* enable DMAC */
+
+	/* Set DMA Transfer Starting Address */
+	mmio_write_32(REG_FMI_DMASA, buffer);
+	mmio_write_32(REG_NANDCMD, NAND_CMD_READ_1ST);       // READ 1st cycle command
+	mmio_write_32(REG_NANDADDR, 0);
+	mmio_write_32(REG_NANDADDR, 0);
+	mmio_write_32(REG_NANDADDR, page & 0xff);
+	if (nand->size > SZ_128M) {
+		mmio_write_32(REG_NANDADDR, (page >> 8) & 0xff);
+		mmio_write_32(REG_NANDADDR, ((page >> 16) & 0xff) | NAND_EOA);
+	} else {
+		mmio_write_32(REG_NANDADDR, ((page >> 8) & 0xff) | NAND_EOA);
+	}
+
+	mmio_write_32(REG_NANDCMD, NAND_CMD_READ_2ND);       // READ 2nd cycle command
+
+	ma35d1_nand_wait_ready(1);
+
+	uF1_status = 0;
+	uStatus = 0;
+	/* begin DMA read transfer */
+	mmio_write_32(REG_NANDINTSTS, 0x5);     /* clear DMA and ECC_Field flag */
+	mmio_write_32(REG_NANDCTL, mmio_read_32(REG_NANDCTL) | 0x2);    /* READ enable */
+
+	while(1) {
+		if (nand->max_bit_corr) {
+			if (mmio_read_32(REG_NANDINTSTS) & 0x4) {
+				switch (mmio_read_32(REG_NANDCTL) & PSIZE) {
+					case PSIZE_2K:
+						uLoop = 1;
+						break;
+					case PSIZE_4K:
+						if ((mmio_read_32(REG_NANDCTL) & BCH_TSEL) == BCH_24)
+							uLoop = 1;
+						else
+							uLoop = 2;
+						break;
+					case PSIZE_8K:
+						if ((mmio_read_32(REG_NANDCTL) & BCH_TSEL) == BCH_24)
+							uLoop = 2;
+						else
+							uLoop = 4;
+						break;
+				}
+
+				for (j=0; j<uLoop; j++) {
+					uF1_status = mmio_read_32(REG_NANDECCES0+j*4);
+					if (!uF1_status)
+						continue;   // no error on this register for 4 fields
+					for (i=1; i<5; i++) {
+						if (!(uF1_status & 0x3)) {     // no error for this field
+							uF1_status >>= 8;  // next field
+							continue;
+						}
+
+						if ((uF1_status & 0x3)==0x01) {
+							/* correctable error in field (j*4+i) */
+							uErrorCnt = (uF1_status >> 2) & 0x1F;
+							ma35d1_correct_data(j*4+i, uErrorCnt, (unsigned char*)(long)buffer);
+							break;
+						} else if (((uF1_status & 0x3) == 0x02) || ((uF1_status & 0x3) == 0x03)) {
+							/* uncorrectable error or ECC error in 1st field */
+							uStatus = 1;
+							break;
+						}
+						uStatus >>= 8;  // next field
+					}
+				}
+				mmio_write_32(REG_NANDINTSTS, 0x4);     // clear ECC_FLD_Error
+			}
+		}
+
+		if (mmio_read_32(REG_NANDINTSTS) & 0x1) {    // wait to finish DMAC transfer.
+			if (nand->max_bit_corr) {
+				if ( !(mmio_read_32(REG_NANDINTSTS) & 0x4) )
+					break;
+			} else
+				break;
+		}
+	}
+
+	mmio_write_32(REG_NANDINTSTS, 0x5); /* clear DMA and ECC flag */
+
+	if (uStatus) {
+		ERROR("Err-ECC 0x%x / 0x%x\n", uStatus, uF1_status);
+		return 1;
+	}
+
+	return 0;
+}
+
+static int ma35d1_nand_read_pages(struct ma35d1_nand_info *nand, uintptr_t buf, int page_start, int page_count)
+{
+	while (page_count > 0)
+	{
+		if (ma35d1_nand_read_page(nand, page_start, buf)) {
+			return -EBADMSG;
+		}
+		buf += nand->page_size;
+		page_count--;
+		page_start++;
+	}
+	return 0;
+}
+
+static int ma35d1_block_isbad(struct ma35d1_nand_info *nand, unsigned int pba)
+{
+	unsigned int page, data;
+
+	/* check first 2 page and last 2 page */
+	page = pba * nand->pages_per_block;
+	ma35d1_nand_read_oob(nand, page);
+	data = mmio_read_32(REG_NANDRA0) & 0xff;
+	if (data != 0xFF)
+		return 1;   /* invalid */
+
+	ma35d1_nand_read_oob(nand, page+1);
+	data = mmio_read_32(REG_NANDRA0) & 0xff;
+	if (data != 0xFF)
+		return 1;   /* invalid */
+
+	ma35d1_nand_read_oob(nand, page+nand->pages_per_block-1);
+	data = mmio_read_32(REG_NANDRA0) & 0xff;
+	if (data != 0xFF)
+		return 1;   /* invalid */
+
+	ma35d1_nand_read_oob(nand, page+nand->pages_per_block-2);
+	data = mmio_read_32(REG_NANDRA0) & 0xff;
+	if (data != 0xFF)
+		return 1;   /* invalid */
+
+	ma35d1_nand_reset();
+
+	return 0;   /* good block */
+}
+
+
+static size_t parse_nand_read(struct ma35d1_nand_info *nand, int lba, uintptr_t buf, size_t size)
+{
+	int pages_per_block = nand->pages_per_block;
+	int page_size = nand->page_size;
+	int pages_to_read = div_round_up(size, page_size);
+	int block_count = div_round_up(pages_to_read, pages_per_block);
+	int page = lba % pages_per_block;
+	int block = lba / pages_per_block;
+	uintptr_t p = buf;
+	int page_count, ret;
+
+	while (pages_to_read) {
+		ret = ma35d1_block_isbad(nand, block);
+		if (ret) {
+			block++;
+			if ((--block_count) <= 0)
+				goto out;
+			else
+				continue;
+		}
+
+		page_count = MIN(pages_per_block - page, pages_to_read);
+
+		ret = ma35d1_nand_read_pages(nand, p, block * pages_per_block + page, page_count);
+		if (ret)
+			goto out;
+
+		block++;
+		page = 0;
+		p += page_size * page_count;
+		pages_to_read -= page_count;
+	}
+
+out:
+	/* number of read bytes */
+	return MIN(size, p - buf);
+}
+
+int ma35d1_nand_ctrl_init(void)
+{
+	/* enable nand clock */
+	mmio_write_32(CLK_SYSCLK0, mmio_read_32(CLK_SYSCLK0) | (1 << 18));
+
+	/* set MFP */
+	mmio_write_32(SYS_GPA_MFPL, 0x66666666);
+	mmio_write_32(SYS_GPA_MFPH, 0x06666666);
+
+	// reset FMI
+	mmio_write_32(SYS_IPRST0, 0x4000000);
+	mmio_write_32(SYS_IPRST0, 0x0000000);
+
+	// DMAC Initial
+	mmio_write_32(REG_FMI_DMACTL, 0x00000001);
+
+	// enable SM
+	mmio_write_32(REG_FMI_CTL, 0x08);
+
+	/* enable CS0 */
+	mmio_write_32(REG_NANDCTL, (mmio_read_32(REG_NANDCTL) & ~0x02000000) | 0x4000000);
+
+	return 0;
+}
+
+static void *fdt = (void *)(uintptr_t)MA35D1_DTB_BASE;
+
+static void ma35d1_nand_setup(struct ma35d1_nand_info *nand)
+{
+	unsigned int reg = 0x04910090; // REG_NANDCTL default value
+	int node, count;
+
+	ma35d1_nand_ctrl_init();
+
+	/* get device tree information */
+	if (fdt_check_header(fdt) < 0) {
+		WARN("device tree header check error.\n");
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, "nuvoton,ma35d1-nand");
+	if (node < 0) {
+		WARN("The compatible property `nuvoton,ma35d1-nand` not found\n");
+	}
+
+	nand->max_bit_corr = fdt_read_uint32_default(fdt, node, "nand-ecc-strength", 8);
+	nand->page_size = fdt_read_uint32_default(fdt, node, "nand-page-size", 2048);
+	nand->pages_per_block = fdt_read_uint32_default(fdt, node, "nand-page-count", 64);
+	nand->oob_size = fdt_read_uint32_default(fdt, node, "nand-oob-size", 0);
+	count = fdt_read_uint32_default(fdt, node, "nand-block-count", 256) / 1024;
+	nand->size = (nand->page_size / 1024) * nand->pages_per_block * count;
+	nand->offset = fdt_read_uint32_default(fdt, node, "nand-image-offset", 0);
+
+	INFO("NAND: Size %liMB, Page %i, pages per block %i, oob size %i, bit correct %i\n", nand->size, nand->page_size,
+		nand->pages_per_block, nand->oob_size, nand->max_bit_corr);
+
+	switch (nand->page_size) {
+	case 2048:
+		reg = (reg & (~0x30000)) | 0x10000;
+		switch (nand->max_bit_corr) {
+		case 0:
+			reg &= ~ECC_EN;
+			nand->oob_size = 8;
+			break;
+		case 8:
+			reg = (reg & ~0x7C0000) | BCH_8;
+			reg |= ECC_EN;
+			break;
+
+		case 12:
+			reg = (reg & ~0x7C0000) | BCH_12;
+			reg |= ECC_EN;
+			break;
+
+		case 24:
+			reg = (reg & ~0x7C0000) | BCH_24;
+			reg |= ECC_EN;
+			break;
+		default:
+			WARN("error BCH in 2KB page size\n");
+		}
+		break;
+
+	case 4096:
+		reg = (reg & (~0x30000)) | 0x20000;
+		switch (nand->max_bit_corr) {
+		case 0:
+			reg &= ~ECC_EN;
+			nand->oob_size = 8;
+			break;
+		case 8:
+			reg = (reg & ~0x7C0000) | BCH_8;
+			reg |= ECC_EN;
+			break;
+
+		case 12:
+			reg = (reg & ~0x7C0000) | BCH_12;
+			reg |= ECC_EN;
+			break;
+
+		case 24:
+			reg = (reg & ~0x7C0000) | BCH_24;
+			reg |= ECC_EN;
+			break;
+		default:
+			WARN("error BCH in 4KB page size\n");
+		}
+		break;
+
+	case 8192:
+		reg = (reg & (~0x30000)) | 0x30000;
+		switch (nand->max_bit_corr) {
+		case 0:
+			reg &= ~ECC_EN;
+			nand->oob_size = 8;
+			break;
+		case 8:
+			reg = (reg & ~0x7C0000) | BCH_8;
+			reg |= ECC_EN;
+			break;
+
+		case 12:
+			reg = (reg & ~0x7C0000) | BCH_12;
+			reg |= ECC_EN;
+			break;
+
+		case 24:
+			reg = (reg & ~0x7C0000) | BCH_24;
+			reg |= ECC_EN;
+			break;
+		default:
+			WARN("error BCH in 8KB page size\n");
+		}
+		break;
+
+	default:
+		WARN("NAND Controller is not support this PAGE SIZE. (%d)\n", nand->page_size);
+	}
+
+	mmio_write_32(REG_NANDCTL, reg|PROT_3BEN|REDUN_AUTO_WEN);
+	mmio_write_32(REG_NANDRACTL, mmio_read_32(REG_NANDRACTL) & ~MECC_Msk);
+	mmio_write_32(REG_NANDRACTL, nand->oob_size);
+	ma35d1_nand_reset();
+}
+
+static size_t ma35d1_nand_read(int lba, uintptr_t buf, size_t size)
+{
+	size_t count = 0;
+
+	inv_dcache_range(buf, size);
+
+	count = parse_nand_read(&ma35d1_nand, lba, buf, size);
+
+	inv_dcache_range(buf, size);
+
+	return count;
+}
+
+
+static struct io_block_dev_spec nand_dev_spec = {
+	.ops = {
+		.read = ma35d1_nand_read,
+	},
+	/* fill .block_size at run-time */
+};
+
+int ma35d1_nand_init(struct io_block_dev_spec **block_dev_spec, long *offset)
+{
+	ma35d1_nand_setup(&ma35d1_nand);
+	*offset = ma35d1_nand.offset;
+
+	nand_dev_spec.block_size = ma35d1_nand.page_size;
+
+	*block_dev_spec = &nand_dev_spec;
+
+	return 0;
+}
+
+
+
diff --git a/drivers/nuvoton/pmic/ma35d1_pmic.c b/drivers/nuvoton/pmic/ma35d1_pmic.c
new file mode 100644
index 0000000..da0a1bb
--- /dev/null
+++ b/drivers/nuvoton/pmic/ma35d1_pmic.c
@@ -0,0 +1,339 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include <libfdt.h>
+
+#include <plat/common/platform.h>
+#include <platform_def.h>
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/delay_timer.h>
+#include <drivers/io/io_block.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#include <drivers/nuvoton/ma35d1_pmic.h>
+
+#define RETRY_COUNT 3
+/*---------------------------------------------------------------------------*/
+/* Global variables                                                          */
+/*---------------------------------------------------------------------------*/
+unsigned char g_u8DeviceAddr = 0xB0;
+unsigned char g_uPageNum;
+unsigned char g_u8RegAddr;
+unsigned char g_u8WriteData;
+
+volatile unsigned char g_u8RxData;
+volatile unsigned char g_u8DataLen;
+volatile unsigned char g_u8EndFlag = 0;
+
+void I2C_MasterRx(unsigned int u32Status)
+{
+	if (u32Status == 0x08) {
+		/* START has been transmitted and prepare SLA+W */
+		mmio_write_32(REG_I2C0_DAT,
+					g_u8DeviceAddr|(g_uPageNum << 1));
+		mmio_write_32(REG_I2C0_CTL,
+					(mmio_read_32(REG_I2C0_CTL) &
+					~0x3c) | I2C_CTL_SI);
+	} else if (u32Status == 0x18) {
+		/* SLA+W has been transmitted and ACK has been received */
+		mmio_write_32(REG_I2C0_DAT, g_u8RegAddr);
+		mmio_write_32(REG_I2C0_CTL,
+					(mmio_read_32(REG_I2C0_CTL) &
+					~0x3c) | I2C_CTL_SI);
+	} else if (u32Status == 0x20) {
+		/* SLA+W has been transmitted and NACK has been received */
+		mmio_write_32(REG_I2C0_CTL,
+					(mmio_read_32(REG_I2C0_CTL) &
+					~0x3c) | (I2C_CTL_STA |
+					I2C_CTL_STO | I2C_CTL_SI));
+	} else if (u32Status == 0x28) {
+		/* DATA has been transmitted and ACK has been received */
+		mmio_write_32(REG_I2C0_CTL,
+					(mmio_read_32(REG_I2C0_CTL) &
+					~0x3c) | (I2C_CTL_STA |
+					I2C_CTL_SI)); // repeat start
+	} else if (u32Status == 0x10) {
+		/* Repeat START has been transmitted and prepare SLA+R */
+		mmio_write_32(REG_I2C0_DAT,
+					(g_u8DeviceAddr|(g_uPageNum << 1)) |
+					0x01);
+		mmio_write_32(REG_I2C0_CTL,
+					(mmio_read_32(REG_I2C0_CTL) &
+					~0x3c) | I2C_CTL_SI);
+	} else if (u32Status == 0x40) {
+		/* SLA+R has been transmitted and ACK has been received */
+		mmio_write_32(REG_I2C0_CTL,
+					(mmio_read_32(REG_I2C0_CTL) &
+					~0x3c) | I2C_CTL_SI);
+	} else if (u32Status == 0x58) {
+		/* DATA has been received and NACK has been returned */
+		g_u8RxData = mmio_read_32(REG_I2C0_DAT);
+		mmio_write_32(REG_I2C0_CTL,
+					(mmio_read_32(REG_I2C0_CTL) &
+					~0x3c) | (I2C_CTL_STO | I2C_CTL_SI));
+		g_u8EndFlag = 1;
+	} else {
+		//ERROR("Status 0x%x is NOT processed\n", u32Status);
+	}
+}
+
+void I2C_MasterTx(unsigned int u32Status)
+{
+	if (u32Status == 0x08) {
+		/* START has been transmitted */
+		 /* Write SLA+W to Register I2CDAT */
+		mmio_write_32(REG_I2C0_DAT,
+					g_u8DeviceAddr|(g_uPageNum << 1));
+		mmio_write_32(REG_I2C0_CTL,
+					(mmio_read_32(REG_I2C0_CTL) &
+					~0x3c) | I2C_CTL_SI);
+	} else if (u32Status == 0x18) {
+		/* SLA+W has been transmitted and ACK has been received */
+		mmio_write_32(REG_I2C0_DAT, g_u8RegAddr);
+		mmio_write_32(REG_I2C0_CTL,
+					(mmio_read_32(REG_I2C0_CTL) &
+					~0x3c) | I2C_CTL_SI);
+	} else if (u32Status == 0x20) {
+		/* SLA+W has been transmitted and NACK has been received */
+		mmio_write_32(REG_I2C0_CTL,
+					(mmio_read_32(REG_I2C0_CTL) &
+					~0x3c) | (I2C_CTL_STA | I2C_CTL_STO |
+					I2C_CTL_SI));
+	} else if (u32Status == 0x28) {
+		/* DATA has been transmitted and ACK has been received */
+		if ((g_u8DataLen == 0) && (g_u8EndFlag == 0)) {
+			mmio_write_32(REG_I2C0_DAT, g_u8WriteData);
+			mmio_write_32(REG_I2C0_CTL,
+						(mmio_read_32(REG_I2C0_CTL) &
+						~0x3c) | I2C_CTL_SI);
+			g_u8DataLen++;
+		} else {
+			g_u8DataLen = 0;
+			mmio_write_32(REG_I2C0_CTL,
+						(mmio_read_32(REG_I2C0_CTL) &
+						~0x3c) |
+						(I2C_CTL_STO | I2C_CTL_SI));
+			g_u8EndFlag = 1;
+		}
+	} else {
+		//ERROR("Status 0x%x is NOT processed\n", u32Status);
+	}
+}
+
+unsigned int ma35d1_write_i2c_data(unsigned int u32Addr, unsigned int u32Data)
+{
+	unsigned int I2C_TIME_OUT_COUNT = 6000;
+	unsigned int u32Status;
+	unsigned int u32time_out = 0;
+
+	g_uPageNum = 0;
+	if (g_uPageNum == 0xff) {
+		ERROR("\n address error !!\n");
+		return 0;
+	}
+
+	g_u8RegAddr     = u32Addr;
+	g_u8WriteData   = u32Data;
+	g_u8EndFlag     = 0x0;
+
+	mmio_write_32(REG_I2C0_CTL, (mmio_read_32(REG_I2C0_CTL) &
+				~0x3c) | I2C_CTL_STA);
+
+	while (1) {
+		if (mmio_read_32(REG_I2C0_CTL) & I2C_CTL_SI) {
+			u32Status = mmio_read_32(REG_I2C0_STATUS);
+			I2C_MasterTx(u32Status);
+		}
+
+		if (g_u8EndFlag) {
+			break;
+		}
+		u32time_out++;
+		if (u32time_out > I2C_TIME_OUT_COUNT) {
+			return 0; // error
+		}
+	}
+	return 1;
+}
+
+unsigned int ma35d1_read_i2c_data(unsigned int u32Addr, unsigned int *u32Data)
+{
+	unsigned int I2C_TIME_OUT_COUNT = 6000;
+	unsigned int u32Status;
+	unsigned int u32time_out = 0;
+
+	g_uPageNum = 0;
+	if (g_uPageNum == 0xff) {
+		ERROR("\n address error !!\n");
+		return 0;
+	}
+
+	g_u8RegAddr     = u32Addr;
+	g_u8EndFlag     = 0x0;
+
+	mmio_write_32(REG_I2C0_CTL, (mmio_read_32(REG_I2C0_CTL) &
+				 ~0x3c) | I2C_CTL_STA);
+
+	while (1) {
+		if (mmio_read_32(REG_I2C0_CTL) & I2C_CTL_SI) {
+			u32Status = mmio_read_32(REG_I2C0_STATUS);
+			I2C_MasterRx(u32Status);
+		}
+
+		if (g_u8EndFlag) {
+			break;
+		}
+
+		u32time_out++;
+		if (u32time_out > I2C_TIME_OUT_COUNT) {
+			return 1; // error
+		}
+	}
+
+	*u32Data = g_u8RxData;
+	return 2;
+}
+
+unsigned int ma35d1_read_pmic_data(
+	unsigned int u32Addr,
+	unsigned int *u32Data)
+{
+	int j = RETRY_COUNT;
+
+	while (j-- > 0) {
+		if (ma35d1_read_i2c_data(u32Addr, u32Data) == 2) {
+			break;
+		}
+	}
+
+	if (j <= 0) {
+		//WARN("\nREAD PMIC DATA ERROR!\n");
+		return 0;
+	}
+
+	return 1;
+}
+
+unsigned int ma35d1_write_pmic_data(unsigned int u32Addr, unsigned int u32Data)
+{
+	int j = RETRY_COUNT;
+
+	while (j-- > 0) {
+		if (ma35d1_write_i2c_data(u32Addr, u32Data) == 1) {
+			break;
+		}
+	}
+
+	if (j <= 0) {
+		/* WARN("\nWRITE PMIC DATA ERROR [%d]!\n", j); */
+		return 0;
+	}
+
+	return 1;
+}
+
+void ma35d1_i2c0_init(unsigned int sys_clk)
+{
+	unsigned long clk_rate;
+	unsigned int u32Div, speed;
+
+	outp32((void *)0X40460208, inp32((void *)0X40460208) |
+		    (0x3fff << 16)); // enable GPIO clock
+	outp32((void *)0X40460210, inp32((void *)0X40460210) |
+		    (0x1 << 0));  // I2C0 CLK
+
+	outp32(0x40460098, ((inp32(0x40460098) & ~0x0f000000) |
+		    (0x6<<24))); // PD.6 I2C0_SDA
+	outp32(0x40460098, ((inp32(0x40460098) & ~0xf0000000) |
+		    (0x6<<28))); // PD.7 I2C0_CLK
+	outp32(0x400400F0, 0x5 << 12); // pull high
+
+	/* i2c_clk = 100KHz */
+	clk_rate = sys_clk;
+	speed = 100*1000;
+
+	/* assume speed above 1000 are Hz-specified */
+	if (speed > 1000)
+		speed = speed / 1000;
+	if (speed > 400)
+		speed = 400;
+
+	u32Div = (unsigned int)(((clk_rate * 10U) /
+			(speed * 4U) + 5U) / 10U - 1U);
+
+	mmio_write_32(REG_I2C0_CLKDIV, u32Div);
+	mmio_write_32(REG_I2C0_CTL, mmio_read_32(REG_I2C0_CTL)  |
+				I2C_CTL_ENABLE); /* i2c enable */
+}
+
+
+int ma35d1_set_pmic(int type, int vol)
+{
+	unsigned int reg = 0xff;
+	int ret = 0;
+
+	if (pmicIsInit == 0) {
+		ma35d1_i2c0_init(pmic_clk);
+		pmicIsInit = 1;
+	}
+
+	if (type == VOL_CPU) {
+		reg = 0xA4;
+	} else if (type == VOL_SD) {
+		reg = 0x32;
+	} else {
+		ERROR("Not support type!\n");
+	}
+
+	if (vol == VOL_1_10) {		// (1.1 - 0.3) / 0.01 = 80 = 0x50
+		INFO("1.1V\n");
+		ret = ma35d1_write_pmic_data(reg, 0x50);
+	} else if (vol == VOL_1_00) {	// (1.00 - 0.3) / 0.01 = 70 = 0x46
+		INFO("1.00V\n");
+		ret = ma35d1_write_pmic_data(reg, 0x46);
+	} else if (vol == VOL_1_15) {	// (1.15 - 0.3) / 0.01 = 85 = 0x55
+		INFO("1.15V\n");
+		ret = ma35d1_write_pmic_data(reg, 0x55);
+	} else if (vol == VOL_1_20) {	// (1.2 - 0.3) / 0.01 = 90 = 0x5A
+		INFO("1.20V\n");
+		ret = ma35d1_write_pmic_data(reg, 0x5A);
+	} else if (vol == VOL_1_25) {	// (1.25 - 0.3) / 0.01 = 95 = 0x5F
+		INFO("1.25V\n");
+		ret = ma35d1_write_pmic_data(reg, 0x5F);
+	} else if (vol == VOL_1_29) {	// (1.29 - 0.3) / 0.01 = 99 = 0x63
+		INFO("1.29V\n");
+		ret = ma35d1_write_pmic_data(reg, 0x63);
+	} else if (vol == VOL_1_30) {	// (1.3 - 0.3) / 0.01 = 100 = 0x64
+		INFO("1.3V\n");
+		ret = ma35d1_write_pmic_data(reg, 0x64);
+	} else if (vol == VOL_1_80) {
+		INFO("1.8V\n");
+		ret = ma35d1_write_pmic_data(reg, 0x80);
+	} else if (vol == VOL_3_30) {
+		INFO("3.3V\n");
+		ret = ma35d1_write_pmic_data(reg, 0x00);
+	} else {
+		ERROR("Not support voltage!\n");
+		ret = -1;
+	}
+
+	if (ret >= 0)
+		pmic_state[type] = vol;
+
+	return ret;
+}
+
+int ma35d1_get_pmic(int type)
+{
+	return pmic_state[type];
+}
+
diff --git a/drivers/nuvoton/qspi/ma35d1_qspi.c b/drivers/nuvoton/qspi/ma35d1_qspi.c
new file mode 100644
index 0000000..b2d62e8
--- /dev/null
+++ b/drivers/nuvoton/qspi/ma35d1_qspi.c
@@ -0,0 +1,737 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include <libfdt.h>
+
+#include <plat/common/platform.h>
+#include <platform_def.h>
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/delay_timer.h>
+#include <drivers/io/io_block.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#include <drivers/nuvoton/ma35d1_qspi.h>
+
+
+struct ma35d1_qspi_info {
+	int page_size;
+	int oob_size;
+	int pages_per_block;
+	long size;	/* spinand total size */
+	long offset;	/* image offset in spinand */
+	unsigned char   is_quad;
+	unsigned char   QuadReadCmd;
+	unsigned char   ReadStatusCmd;
+	unsigned char   WriteStatusCmd;
+	unsigned char   StatusValue;
+	unsigned char   dummybyte1;     /* between command and address */
+	unsigned char   dummybyte2;     /* between address and data */
+	unsigned char   SuspendInterval;
+};
+
+struct ma35d1_qspi_info ma35d1_qspi;
+
+#define SPINOR_BLOCK_SIZE	(2048)
+
+/***************************************************************/
+static void nus3500_spi_sendcmd(unsigned char *cmd, unsigned int cmdlen, unsigned char *data, unsigned int datalen)
+{
+	int volatile i;
+
+	mmio_write_32(REG_QSPI0_SSCTL, 0x01);   // CS0 low
+
+	for (i=0; i<cmdlen; i++)
+		mmio_write_32(REG_QSPI0_TX, cmd[i]);
+
+	// wait tx finish
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x01){}
+	// clear RX buffer
+	mmio_write_32(REG_QSPI0_FIFOCTL, mmio_read_32(REG_QSPI0_FIFOCTL) | 0x1);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x800000);
+
+	// read data
+	for (i=0; i<datalen; i++)
+	{
+		mmio_write_32(REG_QSPI0_TX, 0x00);
+		while(mmio_read_32(REG_QSPI0_STATUS) & 0x01);
+		*data++ = mmio_read_32(REG_QSPI0_RX);
+	}
+	mmio_write_32(REG_QSPI0_SSCTL, 0x05);   // CS0 high
+}
+
+/***************************************************************/
+
+static void ma35d1_spinand_reset()
+{
+	unsigned char cmd[1];
+
+	cmd[0] = 0xff;
+	nus3500_spi_sendcmd(cmd, 1, 0, 0);
+}
+
+static int ma35d1_spinand_getstatus(unsigned char offset)
+{
+	unsigned char data[2];
+	unsigned char cmd[4];
+
+	/* read status */
+	cmd[0] = 0x0f;
+	cmd[1] = offset;
+	nus3500_spi_sendcmd(cmd, 2, data, 1);
+	return data[0];
+}
+
+static void ma35d1_spinand_setstatus(unsigned char offset, unsigned char value)
+{
+	unsigned char cmd[4];
+
+	/* write enable */
+	cmd[0] = CMD_WRITE_ENABLE;
+	nus3500_spi_sendcmd(cmd, 1, 0, 0);
+
+	/* write status */
+	cmd[0] = 0x1f;
+	cmd[1] = offset;
+	cmd[2] = value;
+	nus3500_spi_sendcmd(cmd, 3, 0, 0);
+}
+
+static void ma35d1_spinand_quad_disable()
+{
+	unsigned int status;
+
+	/* disable quad mode */
+	status = ma35d1_spinand_getstatus(0xb0);
+	ma35d1_spinand_setstatus(0xb0, status & 0xfe);
+}
+
+static void ma35d1_spinand_quad_enable()
+{
+	unsigned int status;
+
+	/* enable quad mode */
+	status = ma35d1_spinand_getstatus(0xb0);
+	ma35d1_spinand_setstatus(0xb0, status | 0x01);
+}
+
+static int ma35d1_spinand_singleread(struct ma35d1_qspi_info *spinand, unsigned int addr, unsigned int *buf)
+{
+	unsigned char cmd[4];
+	int volatile i;
+
+	cmd[0] = 0x13;  /* page read */
+	cmd[1] = (addr >> 16) & 0xFF;
+	cmd[2] = (addr >> 8) & 0xFF;
+	cmd[3] = addr & 0xFF;
+	nus3500_spi_sendcmd(cmd, 4, 0, 0);
+	while(ma35d1_spinand_getstatus(0xc0) & 0x1);    // wait ready
+	if (ma35d1_spinand_getstatus(0xc0) & 0x20)
+	{
+		ERROR("Err-ECC\n");
+		return 1;
+	}
+
+	mmio_write_32(REG_QSPI0_SSCTL, 0x01);   // CS0 low
+
+	mmio_write_32(REG_QSPI0_TX, 0x03);
+	mmio_write_32(REG_QSPI0_TX, 0);
+	mmio_write_32(REG_QSPI0_TX, 0);
+	mmio_write_32(REG_QSPI0_TX, 0);
+
+	// wait tx finish
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x01){}
+	// clear RX buffer
+	mmio_write_32(REG_QSPI0_FIFOCTL, mmio_read_32(REG_QSPI0_FIFOCTL) | 0x1);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x800000);
+
+	// set DWIDTH to 32 bit and enable byte reorder
+	mmio_write_32(REG_QSPI0_CTL, (mmio_read_32(REG_QSPI0_CTL) & ~0x1F00) | (1<<19));
+
+	// read data
+	for (i=0; i<spinand->page_size/4; i++)
+	{
+		mmio_write_32(REG_QSPI0_TX, 0x00);
+		while(mmio_read_32(REG_QSPI0_STATUS) & 0x01);
+		*buf++ = mmio_read_32(REG_QSPI0_RX);
+	}
+	mmio_write_32(REG_QSPI0_SSCTL, 0x05);   // CS0 high
+	// set DWIDTH to 8 bit and disable byte reorder
+	mmio_write_32(REG_QSPI0_CTL, (mmio_read_32(REG_QSPI0_CTL) & ~0x80000) | (8<<8));
+
+
+	return 0;
+}
+
+
+static int ma35d1_spinand_read_oob(struct ma35d1_qspi_info *spinand, unsigned int addr, unsigned int len, unsigned char *buf)
+{
+	unsigned char cmd[4];
+
+	cmd[0] = 0x13;  /* page read */
+	cmd[1] = (addr >> 16) & 0xFF;
+	cmd[2] = (addr >> 8) & 0xFF;
+	cmd[3] = addr & 0xFF;
+	nus3500_spi_sendcmd(cmd, 4, 0, 0);
+	while(ma35d1_spinand_getstatus(0xc0) & 0x1);    // wait ready
+	if (ma35d1_spinand_getstatus(0xc0) & 0x20)
+	{
+		ERROR("Err-ECC\n");
+		return 1;
+	}
+	/* read data */
+	cmd[0] = 0x03;  /* page read */
+	cmd[1] = (spinand->page_size >> 8) & 0xff;
+	cmd[2] = spinand->page_size & 0xff;
+	cmd[3] = 0;
+	nus3500_spi_sendcmd(cmd, 4, buf, len);
+	return 0;
+}
+
+
+static int ma35d1_spinand_quadread(struct ma35d1_qspi_info *spinand, unsigned int addr, unsigned int *buf)
+{
+	int volatile i;
+	unsigned char cmd[4];
+
+	cmd[0] = 0x13;  /* page read */
+	cmd[1] = (addr >> 16) & 0xFF;
+	cmd[2] = (addr >> 8) & 0xFF;
+	cmd[3] = addr & 0xFF;
+	nus3500_spi_sendcmd(cmd, 4, 0, 0);
+	while(ma35d1_spinand_getstatus(0xc0) & 0x1);    // wait ready
+	if (ma35d1_spinand_getstatus(0xc0) & 0x20)
+	{
+		ERROR("Err-ECC\n");
+		return 1;
+	}
+	/* read data */
+	mmio_write_32(REG_QSPI0_SSCTL, 0x01);   // CS0 low
+	mmio_write_32(REG_QSPI0_TX, spinand->QuadReadCmd);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x01){}
+
+	if (spinand->QuadReadCmd == CMD_READ_QUAD_IO_FAST)
+	{
+		mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) & (~0x1));
+		while(mmio_read_32(REG_QSPI0_STATUS) & 0x8000);
+		mmio_write_32(REG_QSPI0_CTL, (mmio_read_32(REG_QSPI0_CTL) & ~0xf00000) | 0x500000); // quad output mode
+		mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) | 0x1);
+		while((mmio_read_32(REG_QSPI0_STATUS) & 0x8000) == 0);
+	}
+	// dummy byte (between command and address)
+	for (i=0; i<spinand->dummybyte1; i++)
+		mmio_write_32(REG_QSPI0_TX, 0x00);
+
+	// column address
+	mmio_write_32(REG_QSPI0_TX, 0x00);
+	mmio_write_32(REG_QSPI0_TX, 0x00);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x20000); /* For 4-level FIFO buffer SPI port */
+
+	// dummy byte (between address and data)
+	for (i=0; i<spinand->dummybyte2; i++)
+		mmio_write_32(REG_QSPI0_TX, 0x00);
+
+	// wait tx finish
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x01){}
+
+	// clear RX buffer
+	mmio_write_32(REG_QSPI0_FIFOCTL, mmio_read_32(REG_QSPI0_FIFOCTL) | 0x1);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x800000);
+
+	/* Enable Quad IO input mode */
+	mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) & (~0x1));
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x8000);
+	mmio_write_32(REG_QSPI0_CTL, (mmio_read_32(REG_QSPI0_CTL)& ~0x101ff0)| 0x480000);
+	if (spinand->SuspendInterval == 0xff)
+		mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) | 0x10);
+	else
+		mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) | ((spinand->SuspendInterval & 0xf) << 4));
+	mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) | 0x1);
+	while((mmio_read_32(REG_QSPI0_STATUS) & 0x8000) == 0);
+	mmio_write_32(SYS_GPD_MFPL, 0x00555555);
+
+	// read data
+	for (i=0; i<spinand->page_size/4; i++)
+	{
+		mmio_write_32(REG_QSPI0_TX, 0x00);
+		while(mmio_read_32(REG_QSPI0_STATUS) & 0x01);
+		*buf++ = mmio_read_32(REG_QSPI0_RX);
+	}
+
+	mmio_write_32(REG_QSPI0_SSCTL, 0x05);   // CS0 high
+	mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) & (~0x1));
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x8000);
+	mmio_write_32(REG_QSPI0_CTL, (mmio_read_32(REG_QSPI0_CTL)& ~0x4800f0) | 0x800); // disable quad mode
+	mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) | 0x1);
+	while((mmio_read_32(REG_QSPI0_STATUS) & 0x8000) == 0);
+	mmio_write_32(SYS_GPD_MFPL, 0x00005555);
+	mmio_write_32(GPIOD_MODE, 0x500);
+	mmio_write_32(GPIOD_DOUT, mmio_read_32(GPIOD_DOUT)|0x30);
+
+	return 0;
+}
+
+static int ma35d1_spinand_read_pages(struct ma35d1_qspi_info *spinand, uintptr_t buf, int page_start, int page_count)
+{
+	while (page_count > 0)
+	{
+		if (spinand->is_quad) {
+			if (ma35d1_spinand_quadread(spinand, page_start, (unsigned int *)buf)) {
+				return -EBADMSG;
+			}
+		} else {
+			if (ma35d1_spinand_singleread(spinand, page_start, (unsigned int *)buf)) {
+				return -EBADMSG;
+			}
+		}
+		buf += spinand->page_size;
+		page_count--;
+		page_start++;
+	}
+	return 0;
+}
+
+
+static int ma35d1_spinand_block_isbad(struct ma35d1_qspi_info *spinand, unsigned int block)
+{
+	unsigned int page = block * spinand->pages_per_block;
+	unsigned char data;
+
+	ma35d1_spinand_read_oob(spinand, page, 1, &data);
+	if (data != 0xff)
+		return 1;   /* bad block */
+
+	ma35d1_spinand_read_oob(spinand, page+1, 1, &data);
+	if (data != 0xff)
+		return 1;   /* bad block */
+
+	return 0;   /* good block */
+}
+
+
+static size_t parse_spinand_read(struct ma35d1_qspi_info *spinand, int lba, uintptr_t buf, size_t size)
+{
+	int pages_per_block = spinand->pages_per_block;
+	int page_size = spinand->page_size;
+	int pages_to_read = div_round_up(size, page_size);
+	int block_count = div_round_up(pages_to_read, pages_per_block);
+	int page = lba % pages_per_block;
+	int block = lba / pages_per_block;
+	uintptr_t p = buf;
+	int page_count, ret;
+
+	while (pages_to_read) {
+		ret = ma35d1_spinand_block_isbad(spinand, block);
+		if (ret) {
+			block++;
+			if ((--block_count) <= 0)
+				goto out;
+			else
+				continue;
+		}
+
+		page_count = MIN(pages_per_block - page, pages_to_read);
+
+		ret = ma35d1_spinand_read_pages(spinand, p, block * pages_per_block + page, page_count);
+		if (ret)
+			goto out;
+
+		block++;
+		page = 0;
+		p += page_size * page_count;
+		pages_to_read -= page_count;
+	}
+
+out:
+	/* number of read bytes */
+	return MIN(size, p - buf);
+}
+
+int ma35d1_qspi_init(void)
+{
+	/* enable qspi0/gpiod clock */
+	mmio_write_32(CLK_SYSCLK1, mmio_read_32(CLK_SYSCLK1) | (1 << 19));
+	mmio_write_32(CLK_APBCLK1, mmio_read_32(CLK_APBCLK1) | (1 << 6));
+
+	/* set MFP */
+	mmio_write_32(SYS_GPD_MFPL, 0x00005555);
+
+	/* Set PD.1(QSPI0_CLK) high slew rate */
+	mmio_write_32(GPIOD_SLEWCTL, 0x4);
+	mmio_write_32(GPIOD_MODE, 0x500);
+	mmio_write_32(GPIOD_DOUT, mmio_read_32(GPIOD_DOUT) | 0x30);
+
+	/* QSPI0 clock source: PCLK0 (SYSCLK1, SYSCLK1 is SYSPLL) */
+	if (mmio_read_32(SYS_PWRONOTP) & 0x2)	/* SYS_PWRONOTP[1] */
+		mmio_write_32(REG_QSPI0_CLKDIV, 2);	/* Set SPI0 clock to 60 MHz => PCLK(180)/(n+1) */
+	else
+		mmio_write_32(REG_QSPI0_CLKDIV, 4);	/* Set SPI0 clock to 36 MHz => PCLK(180)/(n+1) */
+
+	/* Default setting: slave selection signal is active low; disable automatic slave selection function. */
+	mmio_write_32(REG_QSPI0_SSCTL, 0);
+	/* Default setting: MSB first, disable unit transfer interrupt, SP_CYCLE = 0. */
+	mmio_write_32(REG_QSPI0_CTL, 0x805);
+
+	return 0;
+}
+
+static void *fdt = (void *)(uintptr_t)MA35D1_DTB_BASE;
+
+static void ma35d1_spinand_setup(struct ma35d1_qspi_info *spinand)
+{
+	int node;
+
+	ma35d1_qspi_init();
+
+	/* get device tree information */
+	if (fdt_check_header(fdt) < 0) {
+		WARN("device tree header check error.\n");
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, "nuvoton,ma35d1-qspi");
+	if (node < 0) {
+		WARN("The compatible property `nuvoton,ma35d1-qspi` not found\n");
+	}
+
+	spinand->page_size = fdt_read_uint32_default(fdt, node, "spinand-page-size", 2048);
+	spinand->pages_per_block = fdt_read_uint32_default(fdt, node, "spinand-page-count", 64);
+	spinand->oob_size = fdt_read_uint32_default(fdt, node, "spinand-oob-size", 0);
+	spinand->size = spinand->page_size * spinand->pages_per_block * fdt_read_uint32_default(fdt, node, "spinand-block-count", 256);
+	spinand->offset = fdt_read_uint32_default(fdt, node, "spi-image-offset", 0);
+
+	spinand->QuadReadCmd = fdt_read_uint32_default(fdt, node, "spi-quad-read-cmd", 0);
+	spinand->dummybyte1 = fdt_read_uint32_default(fdt, node, "spi-dummy1", 0);
+	spinand->dummybyte2 = fdt_read_uint32_default(fdt, node, "spi-dummy2", 0);
+	spinand->SuspendInterval = fdt_read_uint32_default(fdt, node, "spi-suspend-interval", 0);
+
+	INFO("SPINAND: Size %liMB, Page %i, pages per block %i, oob size %i\n", (spinand->size/1024)/1024, spinand->page_size,
+		spinand->pages_per_block, spinand->oob_size);
+
+	ma35d1_spinand_quad_disable();
+	/* reset spi nand */
+	ma35d1_spinand_reset();
+	while(1)
+	{
+		if ((ma35d1_spinand_getstatus(0xc0) & 0x1) == 0)
+			break;
+	}
+
+	if (spinand->is_quad) {
+		ma35d1_spinand_quad_enable();
+	}
+}
+
+/***************************************************************/
+static int ma35d1_spinor_reset(void)
+{
+	/* reset SPI flash */
+	mmio_write_32(REG_QSPI0_SSCTL, 0x01);   // CS0 low
+	mmio_write_32(REG_QSPI0_TX, 0x66);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x01);    // wait tx finish
+	mmio_write_32(REG_QSPI0_SSCTL, 0x05);   // CS0 high
+	udelay(50);
+
+	mmio_write_32(REG_QSPI0_SSCTL, 0x01);   // CS0 low
+	mmio_write_32(REG_QSPI0_TX, 0x99);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x01);    // wait tx finish
+	mmio_write_32(REG_QSPI0_SSCTL, 0x05);   // CS0 high
+	udelay(50);
+
+	mmio_write_32(REG_QSPI0_SSCTL, 0x01);   // CS0 low
+	mmio_write_32(REG_QSPI0_TX, 0xf0);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x01);    // wait tx finish
+	mmio_write_32(REG_QSPI0_SSCTL, 0x05);   // CS0 high
+	udelay(50);
+
+	return 0;
+
+}
+
+
+int spinor_single_read(unsigned int addr, unsigned int len, unsigned int *buf)
+{
+	int volatile i;
+	unsigned int count;
+
+	mmio_write_32(REG_QSPI0_SSCTL, 0x01);   // CS0 low
+
+	mmio_write_32(REG_QSPI0_TX, CMD_READ_ARRAY_SLOW);
+	mmio_write_32(REG_QSPI0_TX, (addr >> 16) & 0xFF);
+	mmio_write_32(REG_QSPI0_TX, (addr >> 8) & 0xFF);
+	mmio_write_32(REG_QSPI0_TX, addr & 0xFF);
+
+	// wait tx finish
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x01){}
+	// clear RX buffer
+	mmio_write_32(REG_QSPI0_FIFOCTL, mmio_read_32(REG_QSPI0_FIFOCTL) | 0x1);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x800000);
+
+	// set DWIDTH to 32 bit and enable byte reorder
+	mmio_write_32(REG_QSPI0_CTL, (mmio_read_32(REG_QSPI0_CTL) & ~0x1F00) | (1<<19));
+
+	// read data
+	count = (len / 4) + 1;
+	for (i=0; i<count; i++)
+	{
+		mmio_write_32(REG_QSPI0_TX, 0x00);
+		while(mmio_read_32(REG_QSPI0_STATUS) & 0x01);
+		*buf++ = mmio_read_32(REG_QSPI0_RX);
+	}
+	mmio_write_32(REG_QSPI0_SSCTL, 0x05);   // CS0 high
+	// set DWIDTH to 8 bit and disable byte reorder
+	mmio_write_32(REG_QSPI0_CTL, (mmio_read_32(REG_QSPI0_CTL) & ~0x80000) | (8<<8));
+
+	return 0;
+}
+
+int ma35d1_spinor_quad_enable(struct ma35d1_qspi_info *spinor)
+{
+	unsigned char data[2];
+	unsigned char cmd[4];
+
+	/* write enable */
+	cmd[0] = CMD_WRITE_ENABLE;
+	nus3500_spi_sendcmd(cmd, 1, 0, 0);
+
+	if (spinor->ReadStatusCmd == CMD_READ_STATUS)
+	{
+		/* read status */
+		cmd[0] = CMD_READ_STATUS;
+		nus3500_spi_sendcmd(cmd, 1, &data[0], 1);
+		cmd[0] = spinor->ReadStatusCmd;
+		nus3500_spi_sendcmd(cmd, 1, &data[1], 1);
+
+		/* write status */
+		cmd[0] = spinor->WriteStatusCmd;
+		cmd[1] = data[0];
+		cmd[2] = data[1] | spinor->StatusValue;
+		nus3500_spi_sendcmd(cmd, 3, 0, 0);
+		while(1)
+		{
+			cmd[0] = CMD_READ_STATUS;
+			nus3500_spi_sendcmd(cmd, 1, &data[0], 1);
+			if ((data[0] & 0x1) == 0)
+				break;
+		}
+	}
+	else if (spinor->ReadStatusCmd == CMD_READ_EVCR)  /* micron */
+	{
+		/* read status */
+		cmd[0] = CMD_READ_EVCR;
+		nus3500_spi_sendcmd(cmd, 1, &data[0], 1);
+		/* write status */
+		cmd[0] = spinor->WriteStatusCmd;
+		cmd[1] = data[0] & (~spinor->StatusValue);
+		nus3500_spi_sendcmd(cmd, 2, 0, 0);
+		while(1)
+		{
+			cmd[0] = CMD_READ_STATUS;
+			nus3500_spi_sendcmd(cmd, 1, &data[0], 1);
+			if ((data[0] & 0x1) == 0)
+				break;
+		}
+	}
+	else
+	{
+		ERROR("Err-Unknown\n");
+		return 1;
+	}
+	return 0;
+}
+
+int spinor_quad_read(struct ma35d1_qspi_info *spinor, unsigned int addr, unsigned int len, unsigned int *buf)
+{
+	int volatile i;
+	int volatile count;
+
+	ma35d1_spinor_quad_enable(spinor);
+
+	mmio_write_32(SYS_GPD_MFPL, 0x00555555);    /* set MFP */
+	mmio_write_32(REG_QSPI0_SSCTL, 0x01);   // CS0 low
+	mmio_write_32(REG_QSPI0_TX, spinor->QuadReadCmd);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x01){}
+
+	if (spinor->QuadReadCmd == CMD_READ_QUAD_IO_FAST)
+	{
+		mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) & (~0x1));
+		while(mmio_read_32(REG_QSPI0_STATUS) & 0x8000);
+		mmio_write_32(REG_QSPI0_CTL, (mmio_read_32(REG_QSPI0_CTL) & ~0xf00000) | 0x500000); // quad output mode
+		mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) | 0x1);
+		while((mmio_read_32(REG_QSPI0_STATUS) & 0x8000) == 0);
+	}
+	// dummy byte (between command and address)
+	for (i=0; i<spinor->dummybyte1; i++)
+		mmio_write_32(REG_QSPI0_TX, 0x00);
+
+	// address
+	mmio_write_32(REG_QSPI0_TX, (addr>>16) & 0xFF);
+	mmio_write_32(REG_QSPI0_TX, (addr>>8)  & 0xFF);
+	mmio_write_32(REG_QSPI0_TX,  addr      & 0xFF);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x20000); /* For 4-level FIFO buffer SPI port */
+
+	// dummy byte (between address and data)
+	for (i=0; i<spinor->dummybyte2; i++)
+		mmio_write_32(REG_QSPI0_TX, 0x00);
+
+	// wait tx finish
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x01){}
+
+	// clear RX buffer
+	mmio_write_32(REG_QSPI0_FIFOCTL, mmio_read_32(REG_QSPI0_FIFOCTL) | 0x1);
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x800000);
+
+	/* Enable Quad IO input mode */
+	mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) & (~0x1));
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x8000);
+	mmio_write_32(REG_QSPI0_CTL, (mmio_read_32(REG_QSPI0_CTL)& ~0x101ff0)| 0x480000);
+	if (spinor->SuspendInterval == 0xff)
+		mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) | 0x10);
+	else
+		mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) | ((spinor->SuspendInterval & 0xf) << 4));
+	mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) | 0x1);
+	while((mmio_read_32(REG_QSPI0_STATUS) & 0x8000) == 0);
+
+	count = (len / 4) + 1;
+	// read data
+	for (i=0; i<count; i++)
+	{
+		mmio_write_32(REG_QSPI0_TX, 0x00);
+		while(mmio_read_32(REG_QSPI0_STATUS) & 0x01);
+		*buf++ = mmio_read_32(REG_QSPI0_RX);
+	}
+
+	mmio_write_32(REG_QSPI0_SSCTL, 0x05);   // CS0 high
+	mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) & (~0x1));
+	while(mmio_read_32(REG_QSPI0_STATUS) & 0x8000);
+	mmio_write_32(REG_QSPI0_CTL, (mmio_read_32(REG_QSPI0_CTL)& ~0x4800f0) | 0x800); // disable quad mode and set 8-bit
+	mmio_write_32(REG_QSPI0_CTL, mmio_read_32(REG_QSPI0_CTL) | 0x1);
+	while((mmio_read_32(REG_QSPI0_STATUS) & 0x8000) == 0);
+
+	// disable quad mode
+	ma35d1_spinor_reset();
+
+	return 0;
+}
+
+
+static size_t parse_spinor_read(struct ma35d1_qspi_info *spinor, int lba, uintptr_t buf, size_t size)
+{
+	if (spinor->is_quad)
+		spinor_quad_read(spinor, lba*SPINOR_BLOCK_SIZE, size, (unsigned int *)buf);
+	else
+		spinor_single_read(lba*SPINOR_BLOCK_SIZE, size, (unsigned int *)buf);
+
+	/* number of read bytes */
+	return size;
+}
+
+
+static void ma35d1_spinor_setup(struct ma35d1_qspi_info *spinor)
+{
+	int node;
+
+	ma35d1_qspi_init();
+
+	/* get device tree information */
+	if (fdt_check_header(fdt) < 0) {
+		WARN("device tree header check error.\n");
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, "nuvoton,ma35d1-qspi");
+	if (node < 0) {
+		WARN("The compatible property `nuvoton,ma35d1-qspi` not found\n");
+	}
+
+	spinor->offset = fdt_read_uint32_default(fdt, node, "spi-image-offset", 0);
+	spinor->QuadReadCmd = fdt_read_uint32_default(fdt, node, "spi-quad-read-cmd", 0);
+	spinor->ReadStatusCmd = fdt_read_uint32_default(fdt, node, "spi-status-read-cmd", 0);
+	spinor->WriteStatusCmd = fdt_read_uint32_default(fdt, node, "spi-status-write-cmd", 0);
+	spinor->StatusValue = fdt_read_uint32_default(fdt, node, "spi-status", 0);
+	spinor->dummybyte1 = fdt_read_uint32_default(fdt, node, "spi-dummy1", 0);
+	spinor->dummybyte2 = fdt_read_uint32_default(fdt, node, "spi-dummy2", 0);
+	spinor->SuspendInterval = fdt_read_uint32_default(fdt, node, "spi-suspend-interval", 0);
+
+	/* reset spi nor */
+	ma35d1_spinor_reset();
+
+}
+
+/***************************************************************/
+static size_t ma35d1_spinand_read(int lba, uintptr_t buf, size_t size)
+{
+	size_t count = 0;
+
+	inv_dcache_range(buf, size);
+
+	count = parse_spinand_read(&ma35d1_qspi, lba, buf, size);
+
+	inv_dcache_range(buf, size);
+
+	return count;
+}
+
+
+static struct io_block_dev_spec spinand_dev_spec = {
+	.ops = {
+		.read = ma35d1_spinand_read,
+	},
+	/* fill .block_size at run-time */
+};
+
+int ma35d1_spinand_init(struct io_block_dev_spec **block_dev_spec, long *offset, int is_quad)
+{
+	ma35d1_qspi.is_quad = is_quad;
+	ma35d1_spinand_setup(&ma35d1_qspi);
+	*offset = ma35d1_qspi.offset;
+
+	spinand_dev_spec.block_size = ma35d1_qspi.page_size;
+
+	*block_dev_spec = &spinand_dev_spec;
+
+	return 0;
+}
+
+/***************************************************************/
+
+static size_t ma35d1_spinor_read(int lba, uintptr_t buf, size_t size)
+{
+	size_t count = 0;
+
+	inv_dcache_range(buf, size);
+
+	count = parse_spinor_read(&ma35d1_qspi, lba, buf, size);
+	INFO("lba 0x%x, buf 0x%lx, size 0x%lx, cnt 0x%lx\n", lba, buf, size, count);
+
+	inv_dcache_range(buf, size);
+
+	return count;
+}
+
+
+static struct io_block_dev_spec spinor_dev_spec = {
+	.ops = {
+		.read = ma35d1_spinor_read,
+	},
+	.block_size = SPINOR_BLOCK_SIZE,
+};
+
+int ma35d1_spinor_init(struct io_block_dev_spec **block_dev_spec, long *offset, int is_quad)
+{
+	ma35d1_qspi.is_quad = is_quad;
+	ma35d1_spinor_setup(&ma35d1_qspi);
+	*offset = ma35d1_qspi.offset;
+
+	*block_dev_spec = &spinor_dev_spec;
+
+	return 0;
+}
+
+
diff --git a/drivers/nuvoton/sdhc/ma35d1_sdhc.c b/drivers/nuvoton/sdhc/ma35d1_sdhc.c
new file mode 100644
index 0000000..69ed1d4
--- /dev/null
+++ b/drivers/nuvoton/sdhc/ma35d1_sdhc.c
@@ -0,0 +1,727 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <stdint.h>
+#include <string.h>
+#include <errno.h>
+#include <libfdt.h>
+
+#include <plat/common/platform.h>
+#include <platform_def.h>
+#include <common/debug.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/delay_timer.h>
+#include <drivers/io/io_block.h>
+#include <lib/mmio.h>
+#include <lib/utils_def.h>
+
+#include <drivers/nuvoton/ma35d1_sdhc.h>
+
+struct mmc_cmd {
+	unsigned short cmdidx;
+	unsigned int   resp_type;
+	unsigned int   cmdarg;
+	unsigned int   response[4];
+};
+
+struct mmc_data {
+	union {
+		char *dest;
+		const char *src; /* src buffers don't get written to */
+	};
+	unsigned int flags;
+	unsigned int blocks;
+	unsigned int blocksize;
+};
+
+struct mmc {
+	unsigned int base;
+	unsigned int version;
+	unsigned int rca;
+	int high_capacity;
+	unsigned int csd[4];
+	long offset;	/* image offset in nand */
+	int bus_width;
+};
+
+
+struct mmc ma35d1_mmc;
+
+/*********************************************************/
+#define SDH_CMD_MAX_TIMEOUT         32000
+#define SDH_CMD_DEFAULT_TIMEOUT     10000
+#define SDH_MAX_DIV_SPEC_300        2046
+
+/*********************************************************/
+static void sdh_reset(struct mmc *mmc, unsigned char mask)
+{
+	unsigned long timeout;
+
+	/* Wait max 100 ms */
+	timeout = 100;
+	mmio_write_8(mmc->base+SDH_SW_RESET, mask);
+	while (mmio_read_8(mmc->base+SDH_SW_RESET) & mask) {
+		if (timeout == 0) {
+			ERROR("SD Reset fail\n");
+			return;
+		}
+		timeout--;
+		udelay(1000);
+	}
+}
+
+static void sdh_set_clock(struct mmc *mmc, unsigned int clock)
+{
+	unsigned long div, clk = 0, timeout;
+
+	/* Wait max 20 ms */
+	timeout = 200;
+	while (mmio_read_32(mmc->base+SDH_PRESENT_STATE) &
+		   0x3) { //(SDH_CMD_INHIBIT | SDH_DATA_INHIBIT))
+		if (timeout == 0) {
+			ERROR("Timeout to wait cmd & data inhibit\n");
+			return;
+		}
+		timeout--;
+		udelay(100);
+	}
+
+	mmio_write_16(mmc->base+SDH_CLOCK_CONTROL, 0);
+
+	/* Version 3.00 divisors must be a multiple of 2. */
+	div = (180000000 / 2) / clock;
+
+	clk |= (div & 0xff) << 8;
+	clk |= 0x01;    //SDHCI_CLOCK_INT_EN;
+	mmio_write_16(mmc->base+SDH_CLOCK_CONTROL, clk);
+
+	/* Wait max 20 ms */
+	timeout = 20;
+	while (!((clk = mmio_read_16(mmc->base +
+		   SDH_CLOCK_CONTROL)) & 0x2)) { // SDHCI_CLOCK_INT_STABLE))
+		if (timeout == 0) {
+			ERROR("Internal clock never stable\n");
+			return;
+		}
+		timeout--;
+		udelay(1000);
+	}
+
+	clk |= 0x4; //SDHCI_CLOCK_CARD_EN;
+	mmio_write_16(mmc->base+SDH_CLOCK_CONTROL, clk);
+}
+
+static void sdh_set_power(struct mmc *mmc)
+{
+	mmio_write_8(mmc->base+SDH_POWER_CONTROL, 0xF);
+}
+
+
+static void sdh_cmd_done(struct mmc *mmc, struct mmc_cmd *cmd)
+{
+	int i;
+
+	if (cmd->resp_type & MMC_RSP_136) {
+		/* CRC is stripped so we need to do some shifting. */
+		for (i = 0; i < 4; i++) {
+			cmd->response[i] = mmio_read_32(mmc->base +
+					SDH_RESPONSE +
+					(3 - i) * 4) << 8;
+			if (i != 3)
+				cmd->response[i] |= mmio_read_8(mmc->base +
+					SDH_RESPONSE + (3 - i) * 4 - 1);
+		}
+	} else {
+		cmd->response[0] = mmio_read_32(mmc->base + SDH_RESPONSE);
+	}
+}
+
+static int sdh_transfer_data(struct mmc *mmc, struct mmc_data *data)
+{
+	unsigned int stat, /*rdy, mask,*/ timeout /*, block = 0*/;
+	char transfer_done = 0;
+	unsigned long start_addr;
+
+	if (data->flags == MMC_DATA_READ)
+		start_addr = (unsigned long) data->dest;
+	else
+		start_addr = (unsigned long) data->src;
+
+	timeout = 2000000;
+	//rdy = 0x30; /* SDHCI_INT_SPACE_AVAIL | SDHCI_INT_DATA_AVAIL */
+	//mask = 0xc00; /* SDHCI_DATA_AVAILABLE | SDHCI_SPACE_AVAILABLE */
+	do {
+		stat = mmio_read_32(mmc->base+SDH_INT_STATUS);
+		if (stat & 0x8000)   /* SDHCI_INT_ERROR */
+			return -1;
+
+		if (!transfer_done && (stat & (1<<3))) {
+			/* SDHCI_INT_DMA_END */
+			mmio_write_32(mmc->base + SDH_INT_STATUS,
+						(1<<3)); /* SDHCI_INT_DMA_END */
+			start_addr &= ~(512*1024 - 1);
+			start_addr += 512*1024;
+			mmio_write_32(mmc->base + SDH_DMA_ADDRESS, start_addr);
+		}
+		if (timeout-- > 0)
+			udelay(10);
+		else
+			return -2;
+
+	} while (!(stat & 0x2));    /* SDHCI_INT_DATA_END */
+	return 0;
+}
+
+
+static int sdh_send_command(struct mmc *mmc,
+						 struct mmc_cmd *cmd,
+						 struct mmc_data *data)
+{
+	unsigned int stat = 0;
+	int ret = 0;
+	unsigned int mask, flags, mode;
+	unsigned int time = 0;
+	/* Timeout unit - ms */
+	unsigned int cmd_timeout = SDH_CMD_DEFAULT_TIMEOUT;
+
+	mask = 0x3; /* SDH_CMD_INHIBIT | SDH_DATA_INHIBIT */
+
+	/*
+	 * We shouldn't wait for data inhibit for stop commands, even
+	 * though they might use busy signaling
+	 */
+	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
+		mask &= ~0x2;   /* SDH_DATA_INHIBIT */
+
+	while (mmio_read_32(mmc->base+SDH_PRESENT_STATE) & mask) {
+		if (time >= cmd_timeout) {
+			if (2 * cmd_timeout <= SDH_CMD_MAX_TIMEOUT) {
+				cmd_timeout += cmd_timeout;
+			} else {
+				return -3;
+			}
+		}
+		time++;
+		udelay(1000);
+	}
+
+	mmio_write_32(mmc->base+SDH_INT_STATUS,
+				 0xffffffff);    /* SDHCI_INT_ALL_MASK */
+
+	mask = 0x1;     /* SDHCI_INT_RESPONSE */
+
+	if (!(cmd->resp_type & MMC_RSP_PRESENT))
+		flags = SDH_CMD_RESP_NONE;
+	else if (cmd->resp_type & MMC_RSP_136)
+		flags = SDH_CMD_RESP_LONG;
+	else if (cmd->resp_type & MMC_RSP_BUSY) {
+		flags = SDH_CMD_RESP_SHORT_BUSY;
+		if (data)
+			mask |= 0x2;    /* SDHCI_INT_DATA_END */
+	} else {
+		flags = SDH_CMD_RESP_SHORT;
+	}
+
+	if (cmd->resp_type & MMC_RSP_CRC)
+		flags |= SDH_CMD_CRC;
+	if (cmd->resp_type & MMC_RSP_OPCODE)
+		flags |= SDH_CMD_INDEX;
+	if (data)
+		flags |= SDH_CMD_DATA;
+
+	/* Set Transfer mode regarding to data flag */
+	if (data) {
+		mmio_write_8(mmc->base+SDH_TOUT_CONTROL, 0xe);
+		mode = 0x2; /* SDHCI_TRNS_BLK_CNT_EN */
+		if (data->blocks > 1)
+			mode |= 0x20;   /* SDHCI_TRNS_MULTI */
+
+		if (data->flags == MMC_DATA_READ) {
+			mode |= 0x10;   /* SDHCI_TRNS_READ */
+			mmio_write_32(mmc->base + SDH_DMA_ADDRESS,
+						(unsigned long) data->dest);
+		} else {
+			mmio_write_32(mmc->base +
+						SDH_DMA_ADDRESS,
+						(unsigned long) data->src);
+		}
+		mode |= 0x1; /* schung: SDH_DMA */
+		mmio_write_8(mmc->base + SDH_HOST_CONTROL,
+				       mmio_read_8(mmc->base +
+				       SDH_HOST_CONTROL) & (~0x18));
+
+		mmio_write_16(mmc->base +
+					 SDH_BLOCK_SIZE, 0x7000 |
+					 (data->blocksize & 0xfff));
+		mmio_write_16(mmc->base+SDH_BLOCK_COUNT, data->blocks);
+		mmio_write_16(mmc->base+SDH_XFER_MODE, mode);
+	} else if (cmd->resp_type & MMC_RSP_BUSY) {
+		mmio_write_8(mmc->base+SDH_TOUT_CONTROL, 0xe);
+	}
+
+	mmio_write_32(mmc->base+SDH_ARGUMENT, cmd->cmdarg);
+	mmio_write_16(mmc->base+SDH_COMMAND,
+				(((cmd->cmdidx & 0xff) << 8) | (flags & 0xff)));
+
+	/* TODO: add timeout */
+	do {
+		stat = mmio_read_32(mmc->base+SDH_INT_STATUS);
+		if (stat & 0x8000) /* SDHCI_INT_ERROR */
+			break;
+	} while ((stat & mask) != mask);
+
+	if ((stat & (0x8000 | mask)) == mask) {
+		sdh_cmd_done(mmc, cmd);
+		mmio_write_32(mmc->base+SDH_INT_STATUS, mask);
+	} else {
+		ret = -4;
+	}
+
+	if (!ret && data)
+		ret = sdh_transfer_data(mmc, data);
+
+	stat = mmio_read_32(mmc->base+SDH_INT_STATUS);
+	/* SDHCI_INT_ALL_MASK */
+	mmio_write_32(mmc->base+SDH_INT_STATUS, 0xffffffff);
+
+	if (ret == 0)
+		return 0;
+
+	sdh_reset(mmc, SDH_RESET_CMD);
+	sdh_reset(mmc, SDH_RESET_DATA);
+	if (stat & 0x10000) /* SDH_INT_TIMEOUT */
+		return -2;
+	else
+		return -1;
+}
+
+
+int sdh_select_card(struct mmc *mmc)
+{
+	struct mmc_cmd cmd;
+
+	cmd.cmdidx = MMC_CMD_SELECT_CARD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca;
+	sdh_send_command(mmc, &cmd, 0);
+
+	if (mmc->version != MMC_VERSION)  {   /* SD */
+		cmd.cmdidx = MMC_CMD_APP_CMD;
+		cmd.resp_type = MMC_RSP_R1;
+		cmd.cmdarg = mmc->rca;
+		sdh_send_command(mmc, &cmd, 0);
+
+		cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
+		cmd.resp_type = MMC_RSP_R1;
+		cmd.cmdarg = 0x2;
+		sdh_send_command(mmc, &cmd, 0);
+
+		/* Set bus width */
+		mmio_write_8(mmc->base + SDH_HOST_CONTROL,
+				       mmio_read_8(mmc->base +
+				       /* SDH_CTRL_4BITBUS */
+				       SDH_HOST_CONTROL) | 0x2);
+	} else {  /* eMMC */
+		cmd.cmdidx = SD_CMD_SWITCH_FUNC;
+		cmd.resp_type = MMC_RSP_R1b;
+		if (mmc->bus_width == 4) {
+			/*
+			 * Set CMD6 argument Access field to 3,
+			 * Index to 183, Value to 1 (4-bit mode)
+			 */
+			cmd.cmdarg = (3ul << 24) | (183ul << 16) | (1ul << 8);
+			mmio_write_8(mmc->base + SDH_HOST_CONTROL,
+					       mmio_read_8(mmc->base +
+					       /* SDH_CTRL_4BITBUS */
+					       SDH_HOST_CONTROL) | 0x2);
+		} else { /* 8-bit */
+			/*
+			 * set CMD6 argument Access field to 3, Index to
+			 * 183, Value to 2 (8-bit mode)
+			 */
+			cmd.cmdarg = (3ul << 24) | (183ul << 16) | (2ul << 8);
+			mmio_write_8(mmc->base + SDH_HOST_CONTROL,
+					       mmio_read_8(mmc->base +
+					       /* SDHCI_CTRL_8BITBUS */
+					       SDH_HOST_CONTROL) | 0x20);
+		}
+		sdh_send_command(mmc, &cmd, 0);
+	}
+
+	/* set block length */
+	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 512;
+	sdh_send_command(mmc, &cmd, 0);
+
+	return 0;
+}
+
+int sdh_read_blocks(struct mmc *mmc,
+				 unsigned int start, void *dst,
+				 unsigned int blkcnt)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+	int err;
+
+	if (blkcnt > 1)
+		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
+	else
+		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
+
+	if (mmc->high_capacity)
+		cmd.cmdarg = start;
+	else
+		cmd.cmdarg = start * 512;
+
+	cmd.resp_type = MMC_RSP_R1;
+
+	data.dest = dst;
+	data.blocks = blkcnt;
+	data.blocksize = 512;
+	data.flags = MMC_DATA_READ;
+
+	err = sdh_send_command(mmc, &cmd, &data);
+	if (err)
+		return err;
+
+	if (blkcnt > 1)	{
+		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
+		cmd.cmdarg = 0;
+		cmd.resp_type = MMC_RSP_R1b;
+		err = sdh_send_command(mmc, &cmd, 0);
+		if (err)
+			return err;
+	}
+	return 0;
+}
+
+#define SD_CMD_APP_SET_CLR_CARD_DETECT  42
+static int sd_set_clear_card_detect(struct mmc *mmc)
+{
+	int err;
+	struct mmc_cmd cmd;
+
+	cmd.cmdidx = MMC_CMD_APP_CMD;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = mmc->rca;
+	//cmd.cmdarg = 0;
+	err = sdh_send_command(mmc, &cmd, 0);
+	if (err)
+		return err;
+
+	cmd.cmdidx = SD_CMD_APP_SET_CLR_CARD_DETECT;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = 0; //0 or 1
+	err = sdh_send_command(mmc, &cmd, 0);
+	if (err)
+		return err;
+	return 0;
+}
+
+static int sd_switch(struct mmc *mmc, int mode,
+				 int group, unsigned char value,
+				 unsigned char *resp)
+{
+	struct mmc_cmd cmd;
+	struct mmc_data data;
+
+	/* Switch the frequency */
+	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
+	cmd.resp_type = MMC_RSP_R1;
+	cmd.cmdarg = (mode << 31) | 0xffffff;
+	cmd.cmdarg &= ~(0xf << (group * 4));
+	cmd.cmdarg |= value << (group * 4);
+
+	data.dest = (char *)resp;
+	data.blocksize = 64;
+	data.blocks = 1;
+	data.flags = MMC_DATA_READ;
+
+	return sdh_send_command(mmc, &cmd, &data);
+}
+
+
+static int ma35d1_sdhc_hw_init(struct mmc *mmc)
+{
+	struct mmc_cmd cmd;
+	int err;
+
+	volatile int timeout;
+
+	sdh_reset(mmc, SDH_RESET_ALL);
+	sdh_set_power(mmc);
+
+	/* Enable only interrupts served by the SD controller */
+	mmio_write_32(mmc->base +
+				 SDH_INT_ENABLE,
+				 /* SDHCI_INT_DATA_MASK | SDHCI_INT_CMD_MASK */
+				 0x027180FB);
+	/* Mask all sdhci interrupt sources */
+	mmio_write_32(mmc->base+SDH_SIGNAL_ENABLE, 0);
+
+	/* set initial state: 1-bit bus width, normal speed */
+	mmio_write_8(mmc->base + SDH_HOST_CONTROL,
+			       mmio_read_8(mmc->base +
+						     SDH_HOST_CONTROL) &
+						     ~0x6);
+
+	/* schung: set sd mode */
+	mmio_write_16(mmc->base + SDH_HOST_CONTROL2,
+				mmio_read_16(mmc->base +
+							SDH_HOST_CONTROL2) | 2);
+
+	/* Set clock : initial clock 200KHz */
+	/* SDH_CLOCK_CONTROL */
+	sdh_set_clock(mmc, 200000);
+
+	/* reset SD bus */
+	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
+	cmd.cmdarg = 0;
+	cmd.resp_type = MMC_RSP_NONE;
+	sdh_send_command(mmc, &cmd, 0);
+
+	/* timer delay */
+	udelay(0x1000);
+
+	mmc->rca = 0;
+	// initial SDHC
+	/* Test for SD version 2 */
+	cmd.cmdidx = SD_CMD_SEND_IF_COND;
+	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
+	cmd.cmdarg = 0x100 | 0xaa;
+	cmd.resp_type = MMC_RSP_R7;
+	sdh_send_command(mmc, &cmd, 0);
+
+	if ((cmd.response[0] & 0xff) == 0xaa) {
+		/* SD 2.0 */
+		mmc->version = SD_VERSION_2;
+
+		timeout = 1000;
+		while (1)	{
+			cmd.cmdidx = MMC_CMD_APP_CMD;
+			cmd.resp_type = MMC_RSP_R1;
+			cmd.cmdarg = 0;
+			sdh_send_command(mmc, &cmd, 0);
+
+			cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
+			cmd.resp_type = MMC_RSP_R3;
+			cmd.cmdarg = 0x40ff8000;
+			sdh_send_command(mmc, &cmd, 0);
+			if (cmd.response[0] & 0x80000000)
+				break; /* OCR_BUSY */
+
+			if (timeout-- <= 0) {
+				ERROR("SD timeout\n");
+				return -ETIMEDOUT;
+			}
+			udelay(1000);
+		}
+		if (cmd.response[0] & 0x40000000)
+			mmc->high_capacity = 0x40000000;
+		else
+			mmc->high_capacity = 0;
+	} else {
+		/* SD 1.1 */
+		/* reset SD bus */
+		cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
+		cmd.cmdarg = 0;
+		cmd.resp_type = MMC_RSP_NONE;
+		sdh_send_command(mmc, &cmd, 0);
+
+		/* timer delay */
+		udelay(0x1000);
+
+		cmd.cmdidx = MMC_CMD_APP_CMD;
+		cmd.resp_type = MMC_RSP_R1;
+		cmd.cmdarg = 0;
+		if (sdh_send_command(mmc, &cmd, 0) < 0) {
+			/* eMMC */
+			/* reset SD bus */
+			cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
+			cmd.cmdarg = 0;
+			cmd.resp_type = MMC_RSP_NONE;
+			sdh_send_command(mmc, &cmd, 0);
+
+			/* timer delay */
+			udelay(0x1000);
+
+			timeout = 1000;
+			while (1) {
+				cmd.cmdidx = MMC_CMD_SEND_OP_COND;
+				cmd.resp_type = MMC_RSP_R3;
+				cmd.cmdarg = 0x40ff8080;
+				sdh_send_command(mmc, &cmd, 0);
+				if (cmd.response[0] & 0x80000000)
+					break; /* OCR_BUSY */
+				if (timeout-- <= 0) {
+					ERROR("SD timeout\n");
+					return -ETIMEDOUT;
+				}
+				udelay(1000);
+			}
+			mmc->high_capacity = 0x40000000;
+			mmc->version = MMC_VERSION;
+			mmc->rca = 0x10000;
+		} else {
+			cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
+			cmd.resp_type = MMC_RSP_R3;
+			cmd.cmdarg = 0x00ff8000;
+			sdh_send_command(mmc, &cmd, 0);
+
+			timeout = 1000;
+			while (1) {
+				cmd.cmdidx = MMC_CMD_APP_CMD;
+				cmd.resp_type = MMC_RSP_R1;
+				cmd.cmdarg = 0;
+				sdh_send_command(mmc, &cmd, 0);
+
+				cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
+				cmd.resp_type = MMC_RSP_R3;
+				cmd.cmdarg = 0x00ff8000;
+				sdh_send_command(mmc, &cmd, 0);
+				if (cmd.response[0] & 0x80000000)
+					break; /* OCR_BUSY */
+
+				if (timeout-- <= 0) {
+					ERROR("SD timeout\n");
+					return -ETIMEDOUT;
+				}
+				udelay(1000);
+			}
+			mmc->version = SD_VERSION_1_0;
+			mmc->high_capacity = 0;
+		}
+	}
+
+	// CMD2, CMD3
+	/* Put the Card in Identify Mode */
+	cmd.cmdidx = MMC_CMD_ALL_SEND_CID;
+	cmd.resp_type = MMC_RSP_R2;
+	cmd.cmdarg = 0;
+	sdh_send_command(mmc, &cmd, 0);
+
+	cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
+	cmd.cmdarg = mmc->rca;
+	cmd.resp_type = MMC_RSP_R6;
+	sdh_send_command(mmc, &cmd, 0);
+
+	if (mmc->version != MMC_VERSION)
+		mmc->rca = cmd.response[0] & 0xffff0000;
+
+	sdh_select_card(mmc);
+	if (mmc->version == SD_VERSION_2) {
+		sd_set_clear_card_detect(mmc);
+		{
+			unsigned char *switch_status[64];
+
+			err = sd_switch(mmc, 1, 0, 0,
+					(unsigned char *)switch_status);
+			if (err) {
+				ERROR("sd_switch failed\n");
+				return err;
+			}
+		}
+	}
+	/* 12MHz */
+	sdh_set_clock(mmc, 20000000);
+
+	return 0;
+}
+
+
+static void *fdt = (void *)(uintptr_t)MA35D1_DTB_BASE;
+
+static void ma35d1_sdhc_setup(struct mmc *mmc)
+{
+	int node;
+
+	/* get device tree information */
+	if (fdt_check_header(fdt) < 0) {
+		WARN("device tree header check error.\n");
+	}
+
+	if (mmc->base == SDH0_BASE) {
+		node = fdt_node_offset_by_compatible(fdt, -1,
+			    "snps,dwcmshc-sdhci0");
+		if (node < 0) {
+			WARN("The compatible property `snps,dwcmshc-sdhci0` not found\n");
+		}
+	} else {
+		node = fdt_node_offset_by_compatible(fdt, -1,
+			    "snps,dwcmshc-sdhci1");
+		if (node < 0) {
+			WARN("The compatible property `snps,dwcmshc-sdhci1` not found\n");
+		}
+	}
+
+	mmc->offset = fdt_read_uint32_default(fdt, node, "mmc-image-offset", 0);
+	mmc->bus_width = fdt_read_uint32_default(fdt, node, "bus-width", 1);
+
+	ma35d1_sdhc_hw_init(mmc);
+}
+
+static size_t ma35d1_sdhc_read(int lba, uintptr_t buf, size_t size)
+{
+	size_t count = 0;
+
+	inv_dcache_range(buf, size);
+
+	if (sdh_read_blocks(&ma35d1_mmc, lba, (void *)buf, size/512) == 0)
+		count = size;
+
+	inv_dcache_range(buf, size);
+
+	return count;
+}
+
+
+static struct io_block_dev_spec sdhc_dev_spec = {
+	.ops = {
+		.read = ma35d1_sdhc_read,
+	},
+	.block_size = 512,
+};
+
+int ma35d1_sdhc_init(struct io_block_dev_spec **block_dev_spec,
+				   long *offset, int sdhc)
+{
+	if (sdhc == 0) {
+		mmio_write_32(CLK_CLKSEL0,
+					mmio_read_32(CLK_CLKSEL0) &
+					~0x30000); /* system pll */
+		mmio_write_32(CLK_SYSCLK0,
+					mmio_read_32(CLK_SYSCLK0) |
+					0x10000); /* enable SD0 clock */
+		/* Set GPC for SD0 */
+		mmio_write_32(SYS_GPC_MFPL, 0x66666666);
+		mmio_write_32(SYS_GPC_MFPH, 0x00006666);
+		ma35d1_mmc.base = SDH0_BASE;
+	} else {
+		mmio_write_32(CLK_CLKSEL0,
+					mmio_read_32(CLK_CLKSEL0) &
+					~0xC0000); /* system pll */
+		mmio_write_32(CLK_SYSCLK0,
+					mmio_read_32(CLK_SYSCLK0) |
+					0x20000); /* enable SD1 clock */
+		/* Set GPJ for SD1 */
+		mmio_write_32(SYS_GPJ_MFPL, 0x66666666);
+		mmio_write_32(SYS_GPJ_MFPH, 0x00006666);
+		ma35d1_mmc.base = SDH1_BASE;
+	}
+
+	ma35d1_sdhc_setup(&ma35d1_mmc);
+	*offset = ma35d1_mmc.offset;
+
+	*block_dev_spec = &sdhc_dev_spec;
+
+	return 0;
+}
+
+
+
diff --git a/drivers/nuvoton/uart/ma35d1_console.S b/drivers/nuvoton/uart/ma35d1_console.S
new file mode 100644
index 0000000..c336b28
--- /dev/null
+++ b/drivers/nuvoton/uart/ma35d1_console.S
@@ -0,0 +1,235 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch.h>
+#include <asm_macros.S>
+#include <assert_macros.S>
+#include <console_macros.S>
+#include <drivers/nuvoton/uart_ma35d1.h>
+
+	/*
+	 * "core" functions are low-level implementations that don't require
+	 * writable memory and are thus safe to call in BL1 crash context.
+	 */
+	.globl console_ma35d1_core_init
+	.globl console_ma35d1_core_putc
+	.globl console_ma35d1_core_getc
+	.globl console_ma35d1_core_flush
+
+	.globl console_ma35d1_putc
+	.globl console_ma35d1_getc
+	.globl console_ma35d1_flush
+
+	/* -----------------------------------------------
+	 * int console_ma35d1_core_init(uintptr_t base_addr,
+	 * unsigned int uart_clk, unsigned int baud_rate)
+	 * Function to initialize the console without a
+	 * C Runtime to print debug information. This
+	 * function will be accessed by console_init and
+	 * crash reporting.
+	 * In: x0 - console base address
+	 *     w1 - Uart clock in Hz
+	 *     w2 - Baud rate
+	 * Out: return 1 on success, 0 on error
+	 * Clobber list : x1, x2, x3
+	 * -----------------------------------------------
+	 */
+func console_ma35d1_core_init
+	/* Check the input base address */
+	cbz	x0, init_fail
+	/* Check baud rate and uart clock for sanity */
+	cbz	w1, init_fail
+	cbz	w2, init_fail
+
+	/* Program the baudrate */
+	/* Mode 2 */
+	/* Divisor =  Uart clock / baudrate - 2 */
+	udiv	w2, w1, w2
+	sub w2, w2, #0x2
+	and	w1, w2, #0xffff
+	ldr	w3, [x0, #UARTBAUD]
+	and w3, w3, #~0xff00ffff
+	orr	w3, w3, #0x30000000
+	orr	w3, w3, w1
+	mov	w3, #0x00CE		// add by chp
+	movk	w3, #0x3000, lsl #16		// add by chp
+	str	w3, [x0, #UARTBAUD]
+
+	/* 8n1 */
+	mov	w3, #7
+	str	w3, [x0, #UARTLCR]
+	/* no interrupt */
+	mov	w3, #0
+	str	w3, [x0, #UARTIER]
+	ret
+init_fail:
+	mov	w0, #0
+	ret
+endfunc console_ma35d1_core_init
+
+	.globl console_ma35d1_register
+
+	/* -----------------------------------------------
+	 * int console_ma35d1_register(uintptr_t baseaddr,
+	 *     uint32_t clock, uint32_t baud,
+	 *     console_t *console);
+	 * Function to initialize and register a new ma35d1
+	 * console. Storage passed in for the console struct
+	 * *must* be persistent (i.e. not from the stack).
+	 * If w1 (UART clock) is 0, initialisation will be
+	 * skipped, relying on previous code to have done
+	 * this already. w2 is ignored then as well.
+	 * In: x0 - UART register base address
+	 *     w1 - UART clock in Hz
+	 *     w2 - Baud rate (ignored if w1 is 0)
+	 *     x3 - pointer to empty console_t struct
+	 * Out: return 1 on success, 0 on error
+	 * Clobber list : x0, x1, x2, x6, x7, x14
+	 * -----------------------------------------------
+	 */
+func console_ma35d1_register
+	mov	x7, x30
+	mov	x6, x3
+	cbz	x6, register_fail
+	str	x0, [x6, #CONSOLE_T_BASE]
+
+	/* A clock rate of zero means to skip the initialisation. */
+	cbz	w1, register_ma35d1
+
+	bl	console_ma35d1_core_init
+	cbz	x0, register_fail
+
+register_ma35d1:
+	mov	x0, x6
+	mov	x30, x7
+	finish_console_register ma35d1 putc=1, getc=1, flush=1
+
+register_fail:
+	ret	x7
+endfunc console_ma35d1_register
+
+	/* --------------------------------------------------------
+	 * int console_ma35d1_core_putc(int c, uintptr_t base_addr)
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
+	 * In : w0 - character to be printed
+	 *      x1 - console base address
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x2
+	 * --------------------------------------------------------
+	 */
+func console_ma35d1_core_putc
+#if ENABLE_ASSERTIONS
+	cmp	x1, #0
+	ASM_ASSERT(ne)
+#endif /* ENABLE_ASSERTIONS */
+
+	/* Prepend '\r' to '\n' */
+	cmp	w0, #0xA
+	b.ne	2f
+	/* Check if the transmit FIFO is full */
+1:	ldr	w2, [x1, #UARTISR]
+	and	w2, w2, #(UARTISR_THRE)
+	cmp	w2, #(UARTISR_THRE)
+	b.ne	1b
+	mov	w2, #0xD		/* '\r' */
+	str	w2, [x1, #UARTTX]
+
+	/* Check if the transmit FIFO is full */
+2:	ldr	w2, [x1, #UARTISR]
+	and	w2, w2, #(UARTISR_THRE)
+	cmp	w2, #(UARTISR_THRE)
+	b.ne	2b
+	str	w0, [x1, #UARTTX]
+	ret
+endfunc console_ma35d1_core_putc
+
+	/* --------------------------------------------------------
+	 * int console_ma35d1_putc(int c, console_t *console)
+	 * Function to output a character over the console. It
+	 * returns the character printed on success or -1 on error.
+	 * In : w0 - character to be printed
+	 *      x1 - pointer to console_t structure
+	 * Out : return -1 on error else return character.
+	 * Clobber list : x2
+	 * --------------------------------------------------------
+	 */
+func console_ma35d1_putc
+	ldr	x1, [x1, #CONSOLE_T_BASE]
+	b	console_ma35d1_core_putc
+endfunc console_ma35d1_putc
+
+	/* ---------------------------------------------
+	 * int console_ma35d1_core_getc(uintptr_t base_addr)
+	 * Function to get a character from the console.
+	 * It returns the character grabbed on success
+	 * or -1 on if no character is available.
+	 * In :  x0 - console base address
+	 * Out : w0 - character if available, else -1
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_ma35d1_core_getc
+
+	/* Check if the receive FIFO is empty */
+1:	ldr	w1, [x0, #UARTISR]
+	tbz	w1, #UARTISR_RDR_BIT, no_char
+	ldr	w0, [x0, #UARTRX]
+	ret
+no_char:
+	mov	w0, #ERROR_NO_PENDING_CHAR
+	ret
+endfunc console_ma35d1_core_getc
+
+	/* ---------------------------------------------
+	 * int console_ma35d1_getc(console_t *console)
+	 * Function to get a character from the console.
+	 * It returns the character grabbed on success
+	 * or -1 on if no character is available.
+	 * In :  x0 - pointer to console_t stucture
+	 * Out : w0 - character if available, else -1
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_ma35d1_getc
+	ldr	x0, [x0, #CONSOLE_T_BASE]
+	b	console_ma35d1_core_getc
+endfunc console_ma35d1_getc
+
+	/* ---------------------------------------------
+	 * int console_ma35d1_core_flush(uintptr_t base_addr)
+	 * Function to force a write of all buffered
+	 * data that hasn't been output.
+	 * In : x0 - console base address
+	 * Out : return -1 on error else return 0.
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_ma35d1_core_flush
+
+	/* Loop until the transmit FIFO is empty */
+1:	ldr	w1, [x0, #UARTISR]
+	and	w1, w1, #(UARTISR_THRE)
+	cmp	w1, #(UARTISR_THRE)
+	b.ne	1b
+
+	mov	w0, #0
+	ret
+endfunc console_ma35d1_core_flush
+
+	/* ---------------------------------------------
+	 * void console_ma35d1_flush(console_t *console)
+	 * Function to force a write of all buffered
+	 * data that hasn't been output.
+	 * In : x0 - pointer to console_t structure
+	 * Out : return -1 on error else return 0.
+	 * Clobber list : x0, x1
+	 * ---------------------------------------------
+	 */
+func console_ma35d1_flush
+	ldr	x0, [x0, #CONSOLE_T_BASE]
+	b	console_ma35d1_core_flush
+endfunc console_ma35d1_flush
diff --git a/fdts/ma35d1-cpu1g-issi-1g.dts b/fdts/ma35d1-cpu1g-issi-1g.dts
new file mode 100644
index 0000000..583e931
--- /dev/null
+++ b/fdts/ma35d1-cpu1g-issi-1g.dts
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "issi-ddr3-1gb";
+	};
+
+};
+
+&clk {
+	assigned-clocks = <&clk capll>, <&clk syspll>,
+				<&clk ddrpll>, <&clk apll>,
+				<&clk epll>, <&clk vpll>;
+	assigned-clock-rates =<1000000000>, <180000000>,
+				<266000000>, <200000000>,
+				<500000000>, <150000000>;
+	clock-pll-mode = <0>, <0>, <1>, <0>, <0>, <0>;
+};
diff --git a/fdts/ma35d1-cpu1g-mc-1g.dts b/fdts/ma35d1-cpu1g-mc-1g.dts
new file mode 100644
index 0000000..b3cd9d0
--- /dev/null
+++ b/fdts/ma35d1-cpu1g-mc-1g.dts
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "mt-ddr3-1gb";
+	};
+
+};
+
+&clk {
+	assigned-clocks = <&clk capll>, <&clk syspll>,
+				<&clk ddrpll>, <&clk apll>,
+				<&clk epll>, <&clk vpll>;
+	assigned-clock-rates =<1000000000>, <180000000>,
+				<266000000>, <200000000>,
+				<500000000>, <150000000>;
+	clock-pll-mode = <0>, <0>, <1>, <0>, <0>, <0>;
+};
diff --git a/fdts/ma35d1-cpu1g-wb-256m.dts b/fdts/ma35d1-cpu1g-wb-256m.dts
new file mode 100644
index 0000000..6b370b1
--- /dev/null
+++ b/fdts/ma35d1-cpu1g-wb-256m.dts
@@ -0,0 +1,37 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "wb-ddr3-256mb";
+	};
+
+};
+
+&clk {
+	assigned-clocks = <&clk capll>, <&clk syspll>,
+				<&clk ddrpll>, <&clk apll>,
+				<&clk epll>, <&clk vpll>;
+	assigned-clock-rates =<1000000000>, <180000000>,
+				<266000000>, <200000000>,
+				<500000000>, <150000000>;
+	clock-pll-mode = <0>, <0>, <1>, <0>, <0>, <0>;
+};
+
+&sspcc {
+	gpio_s = <PD6_S>,
+		<PD7_S>;
+};
diff --git a/fdts/ma35d1-cpu1g-wb-512m.dts b/fdts/ma35d1-cpu1g-wb-512m.dts
new file mode 100644
index 0000000..06b376d
--- /dev/null
+++ b/fdts/ma35d1-cpu1g-wb-512m.dts
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "wb-ddr3-512mb";
+	};
+
+};
+
+&clk {
+	assigned-clocks = <&clk capll>, <&clk syspll>,
+				<&clk ddrpll>, <&clk apll>,
+				<&clk epll>, <&clk vpll>;
+	assigned-clock-rates =<1000000000>, <180000000>,
+				<266000000>, <200000000>,
+				<500000000>, <150000000>;
+	clock-pll-mode = <0>, <0>, <1>, <0>, <0>, <0>;
+};
diff --git a/fdts/ma35d1-cpu1g-zt-1g.dts b/fdts/ma35d1-cpu1g-zt-1g.dts
new file mode 100644
index 0000000..d6e4a25
--- /dev/null
+++ b/fdts/ma35d1-cpu1g-zt-1g.dts
@@ -0,0 +1,32 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "zentel-ddr3-1gb";
+	};
+
+};
+
+&clk {
+	assigned-clocks = <&clk capll>, <&clk syspll>,
+				<&clk ddrpll>, <&clk apll>,
+				<&clk epll>, <&clk vpll>;
+	assigned-clock-rates =<1000000000>, <180000000>,
+				<266000000>, <200000000>,
+				<500000000>, <150000000>;
+	clock-pll-mode = <0>, <0>, <1>, <0>, <0>, <0>;
+};
diff --git a/fdts/ma35d1-cpu800-issi-1g.dts b/fdts/ma35d1-cpu800-issi-1g.dts
new file mode 100644
index 0000000..62427d4
--- /dev/null
+++ b/fdts/ma35d1-cpu800-issi-1g.dts
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "issi-ddr3-1gb";
+	};
+
+};
diff --git a/fdts/ma35d1-cpu800-mc-1g.dts b/fdts/ma35d1-cpu800-mc-1g.dts
new file mode 100644
index 0000000..a5d9793
--- /dev/null
+++ b/fdts/ma35d1-cpu800-mc-1g.dts
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "mt-ddr3-1gb";
+	};
+
+};
diff --git a/fdts/ma35d1-cpu800-wb-128m.dts b/fdts/ma35d1-cpu800-wb-128m.dts
new file mode 100644
index 0000000..262e3bc
--- /dev/null
+++ b/fdts/ma35d1-cpu800-wb-128m.dts
@@ -0,0 +1,27 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "wb-ddr2-128mb";
+	};
+
+};
+
+&sspcc {
+	gpio_s = <PD6_S>,
+		<PD7_S>;
+};
diff --git a/fdts/ma35d1-cpu800-wb-256m.dts b/fdts/ma35d1-cpu800-wb-256m.dts
new file mode 100644
index 0000000..68d8b18
--- /dev/null
+++ b/fdts/ma35d1-cpu800-wb-256m.dts
@@ -0,0 +1,26 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "wb-ddr3-256mb";
+	};
+};
+
+&sspcc {
+	gpio_s = <PD6_S>,
+		<PD7_S>;
+};
diff --git a/fdts/ma35d1-cpu800-wb-512m.dts b/fdts/ma35d1-cpu800-wb-512m.dts
new file mode 100644
index 0000000..db80767
--- /dev/null
+++ b/fdts/ma35d1-cpu800-wb-512m.dts
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "wb-ddr3-512mb";
+	};
+
+};
diff --git a/fdts/ma35d1-cpu800-zt-1g.dts b/fdts/ma35d1-cpu800-zt-1g.dts
new file mode 100644
index 0000000..5d1a3e7
--- /dev/null
+++ b/fdts/ma35d1-cpu800-zt-1g.dts
@@ -0,0 +1,22 @@
+// SPDX-License-Identifier:
+/*
+ * Copyright 2020 - Nuvoton Technology Corporation
+ *
+ */
+
+/dts-v1/;
+#include "ma35d1.dtsi"
+
+/ {
+	model = "Nuvoton MA35D1 EVB board";
+	compatible = "nuvoton,ma35d1";
+
+	aliases {
+
+	};
+
+	ddr: ddr-controller {
+		compatible = "zentel-ddr3-1gb";
+	};
+
+};
diff --git a/fdts/ma35d1.dtsi b/fdts/ma35d1.dtsi
new file mode 100644
index 0000000..db7b469
--- /dev/null
+++ b/fdts/ma35d1.dtsi
@@ -0,0 +1,105 @@
+/*
+ * Device Tree Source for MA35D1
+ *
+ * Copyright (C) 2020 Nuvoton Technology Corp.
+ *
+ * The code contained herein is licensed under the GNU General Public
+ * License. You may obtain a copy of the GNU General Public License
+ * Version 2 or later at the following locations:
+ *
+ * http://www.opensource.org/licenses/gpl-license.html
+ * http://www.gnu.org/copyleft/gpl.html
+ */
+/dts-v1/;
+
+#include <dt-bindings/clock/ma35d1-clk.h>
+#include "../plat/nuvoton/ma35d1/include/sspcc.h"
+
+/{
+	compatible = "nuvoton,ma35d1";
+	#address-cells = <2>;
+	#size-cells = <2>;
+
+	clk: clock-controller@40460200 {
+		compatible = "nuvoton,ma35d1-clk", "syscon", "simple-mfd";
+		#clock-cells = <1>;
+		assigned-clocks = <&clk capll>, <&clk syspll>,
+				<&clk ddrpll>, <&clk apll>,
+				<&clk epll>, <&clk vpll>;
+		assigned-clock-rates =<800000000>, <180000000>,
+				<266000000>, <200000000>,
+				<500000000>, <150000000>;
+		clock-pll-mode = <0>, <0>, <1>, <0>, <0>, <0>;
+		lxt-enable = <1>;
+		/* rtc power control */
+		rtc-pwrctl-enable = <1>;
+		/* Set PH8/PH9 output hight */
+		set-ph8-ph9-hight = <0>;
+	};
+
+	qspi0: qspi@40680000 {
+		compatible = "nuvoton,ma35d1-qspi";
+
+		/* spi information */
+		spi-image-offset = <0x100000>;
+		spi-quad-read-cmd = <0x6B>;
+		spi-status-read-cmd = <0x05>;
+		spi-status-write-cmd = <0x01>;
+		spi-status = <0x02>;
+		spi-dummy1 = <0>;
+		spi-dummy2 = <0x01>;
+		spi-suspend-interval = <0x01>;
+
+		/* spi-nand information */
+		spinand-page-size = <2048>;
+		spinand-oob-size = <64>;
+		spinand-page-count = <64>;
+		spinand-block-count = <4096>;
+	};
+
+	nand: nand@401A0000 {
+		compatible = "nuvoton,ma35d1-nand";
+
+		nand-on-flash-bbt;
+		/* nand information */
+		nand-ecc-strength = <8>;
+		nand-ecc-step-size = <512>;
+		nand-page-size = <2048>;
+		nand-oob-size = <64>;
+		nand-page-count = <64>;
+		nand-block-count = <8192>;
+		nand-image-offset = <0x100000>;
+	};
+
+	sdhci0: sdhci@40180000 {
+		compatible = "snps,dwcmshc-sdhci0";
+		bus-width = <4>;
+		/* sdhc information */
+		mmc-image-offset = <0xc0000>;
+	};
+
+	sdhci1: sdhci@40190000 {
+		compatible = "snps,dwcmshc-sdhci1";
+		bus-width = <4>;
+		/* sdhc information */
+		mmc-image-offset = <0xc0000>;
+	};
+
+	sspcc: sspcc@404F0000 {
+		compatible = "nuvoton,ma35d1-sspcc";
+		reg = <0x0 0x404F0000 0x0 0x1000>;
+		config = <UART0_TZNS>,
+			<SDH0_TZNS>,
+			<SDH1_TZNS>,
+			<NAND_TZNS>,
+			<QSPI0_TZNS>,
+			<CRYPTO_TZNS>,
+			<WDTWWDT1_TZNS>,
+			<HSUSBD_TZNS>,
+			<PDMA0_TZNS>,
+			<PDMA1_TZNS>,
+			<TIMER01_TZNS>,
+			<UART16_SUBM>,
+			<TRNG_TZNS>;
+	};
+};
diff --git a/include/drivers/auth/crypto_mod.h b/include/drivers/auth/crypto_mod.h
index 71cf673..5789cbb 100644
--- a/include/drivers/auth/crypto_mod.h
+++ b/include/drivers/auth/crypto_mod.h
@@ -93,6 +93,16 @@ int crypto_mod_calc_hash(unsigned int alg, void *data_ptr,
 		.calc_hash = _calc_hash, \
 		.auth_decrypt = _auth_decrypt \
 	}
+#define REGISTER_CRYPTO_LIB_MA35(_name, _init, _verify_signature, _verify_hash, \
+			    _calc_hash, _auth_decrypt) \
+	const crypto_lib_desc_t crypto_lib_desc_ma35 = { \
+		.name = _name, \
+		.init = _init, \
+		.verify_signature = _verify_signature, \
+		.verify_hash = _verify_hash, \
+		.calc_hash = _calc_hash, \
+		.auth_decrypt = _auth_decrypt \
+	}
 #else
 #define REGISTER_CRYPTO_LIB(_name, _init, _verify_signature, _verify_hash, \
 			    _auth_decrypt) \
@@ -103,6 +113,15 @@ int crypto_mod_calc_hash(unsigned int alg, void *data_ptr,
 		.verify_hash = _verify_hash, \
 		.auth_decrypt = _auth_decrypt \
 	}
+#define REGISTER_CRYPTO_LIB_MA35(_name, _init, _verify_signature, _verify_hash, \
+			    _auth_decrypt) \
+	const crypto_lib_desc_t crypto_lib_desc_ma35 = { \
+		.name = _name, \
+		.init = _init, \
+		.verify_signature = _verify_signature, \
+		.verify_hash = _verify_hash, \
+		.auth_decrypt = _auth_decrypt \
+	}
 #endif	/* MEASURED_BOOT */
 
 extern const crypto_lib_desc_t crypto_lib_desc;
diff --git a/include/drivers/nuvoton/ma35d1_nand.h b/include/drivers/nuvoton/ma35d1_nand.h
new file mode 100644
index 0000000..a586a92
--- /dev/null
+++ b/include/drivers/nuvoton/ma35d1_nand.h
@@ -0,0 +1,105 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MA35D1_NAND_H
+#define MA35D1_NAND_H
+
+/*-----------------------------------------------------------------------------
+ * NFI Register's Definition
+ *---------------------------------------------------------------------------*/
+#define    NAND_BASE        0x401A0000  /*!< Flash Memory Card Interface */
+
+/* NFI Registers */
+#define     REG_FMI_BUFFER      (NAND_BASE+0x000)   /*!< FMI Embedded Buffer Word */
+#define     REG_FMI_DMACTL      (NAND_BASE+0x400)   /*!< FMI DMA Control Register */
+#define     REG_FMI_DMASA       (NAND_BASE+0x408)   /*!< FMI DMA Transfer Starting Address Register */
+#define     REG_FMI_DMABCNT     (NAND_BASE+0x40C)   /*!< FMI DMA Transfer Byte Count Register */
+#define     REG_FMI_DMAINTEN    (NAND_BASE+0x410)   /*!< FMI DMA Interrupt Enable Register */
+#define     REG_FMI_DMAINTSTS   (NAND_BASE+0x414)   /*!< FMI DMA Interrupt Status Register */
+
+#define     REG_FMI_CTL         (NAND_BASE+0x800)   /*!< Global Control and Status Register */
+#define     REG_FMI_INTEN       (NAND_BASE+0x804)   /*!< Global Interrupt Control Register */
+#define     REG_FMI_INTSTS      (NAND_BASE+0x808)   /*!< Global Interrupt Status Register */
+
+/* NAND-type Flash Registers */
+#define     REG_NANDCTL         (NAND_BASE+0x8A0)   /*!< NAND Flash Control and Status Register */
+#define     REG_NANDTMCTL       (NAND_BASE+0x8A4)   /*!< NAND Flash Timing Control Register */
+#define     REG_NANDINTEN       (NAND_BASE+0x8A8)   /*!< NAND Flash Interrupt Control Register */
+#define     REG_NANDINTSTS      (NAND_BASE+0x8AC)   /*!< NAND Flash Interrupt Status Register */
+#define     REG_NANDCMD         (NAND_BASE+0x8B0)   /*!< NAND Flash Command Port Register */
+#define     REG_NANDADDR        (NAND_BASE+0x8B4)   /*!< NAND Flash Address Port Register */
+#define     REG_NANDDATA        (NAND_BASE+0x8B8)   /*!< NAND Flash Data Port Register */
+#define     REG_NANDRACTL       (NAND_BASE+0x8BC)   /*!< NAND Flash Redundant Area Control Register */
+#define     REG_NANDECTL        (NAND_BASE+0x8C0)   /*!< NAND Flash Extend Control Regsiter */
+#define     REG_NANDECCES0      (NAND_BASE+0x8D0)   /*!< NAND Flash ECC Error Status 0 */
+#define     REG_NANDECCES1      (NAND_BASE+0x8D4)   /*!< NAND Flash ECC Error Status 1 */
+#define     REG_NANDECCES2      (NAND_BASE+0x8D8)   /*!< NAND Flash ECC Error Status 2 */
+#define     REG_NANDECCES3      (NAND_BASE+0x8DC)   /*!< NAND Flash ECC Error Status 3 */
+
+/* NAND-type Flash BCH Error Address Registers */
+#define     REG_NANDECCEA0      (NAND_BASE+0x900)   /*!< NAND Flash ECC Error Byte Address 0 */
+#define     REG_NANDECCEA1      (NAND_BASE+0x904)   /*!< NAND Flash ECC Error Byte Address 1 */
+#define     REG_NANDECCEA2      (NAND_BASE+0x908)   /*!< NAND Flash ECC Error Byte Address 2 */
+#define     REG_NANDECCEA3      (NAND_BASE+0x90C)   /*!< NAND Flash ECC Error Byte Address 3 */
+#define     REG_NANDECCEA4      (NAND_BASE+0x910)   /*!< NAND Flash ECC Error Byte Address 4 */
+#define     REG_NANDECCEA5      (NAND_BASE+0x914)   /*!< NAND Flash ECC Error Byte Address 5 */
+#define     REG_NANDECCEA6      (NAND_BASE+0x918)   /*!< NAND Flash ECC Error Byte Address 6 */
+#define     REG_NANDECCEA7      (NAND_BASE+0x91C)   /*!< NAND Flash ECC Error Byte Address 7 */
+#define     REG_NANDECCEA8      (NAND_BASE+0x920)   /*!< NAND Flash ECC Error Byte Address 8 */
+#define     REG_NANDECCEA9      (NAND_BASE+0x924)   /*!< NAND Flash ECC Error Byte Address 9 */
+#define     REG_NANDECCEA10     (NAND_BASE+0x928)   /*!< NAND Flash ECC Error Byte Address 10 */
+#define     REG_NANDECCEA11     (NAND_BASE+0x92C)   /*!< NAND Flash ECC Error Byte Address 11 */
+
+/* NAND-type Flash BCH Error Data Registers */
+#define     REG_NANDECCED0      (NAND_BASE+0x960)   /*!< NAND Flash ECC Error Data Register 0 */
+#define     REG_NANDECCED1      (NAND_BASE+0x964)   /*!< NAND Flash ECC Error Data Register 1 */
+#define     REG_NANDECCED2      (NAND_BASE+0x968)   /*!< NAND Flash ECC Error Data Register 2 */
+#define     REG_NANDECCED3      (NAND_BASE+0x96C)   /*!< NAND Flash ECC Error Data Register 3 */
+#define     REG_NANDECCED4      (NAND_BASE+0x970)   /*!< NAND Flash ECC Error Data Register 4 */
+#define     REG_NANDECCED5      (NAND_BASE+0x974)   /*!< NAND Flash ECC Error Data Register 5 */
+
+/* NAND-type Flash Redundant Area Registers */
+#define     REG_NANDRA0         (NAND_BASE+0xA00)   /*!< NAND Flash Redundant Area Register */
+#define     REG_NANDRA1         (NAND_BASE+0xA04)   /*!< NAND Flash Redundant Area Register */
+
+/*-----------------------------------------------------------------------------
+ * Define some constants
+ *---------------------------------------------------------------------------*/
+/* SMCR */
+#define ECC_EN          0x00800000
+#define PROT_3BEN       0x00000100
+#define REDUN_AUTO_WEN  0x00000010
+#define REDUN_REN       0x00000008
+
+#define BCH_TSEL        0x007C0000
+#define BCH_24          0x00040000
+#define BCH_4           0x00080000
+#define BCH_8           0x00100000
+#define BCH_12          0x00200000
+#define BCH_15          0x00400000
+
+#define PSIZE           0x00030000
+#define PSIZE_8K        0x00030000
+#define PSIZE_4K        0x00020000
+#define PSIZE_2K        0x00010000
+#define PSIZE_512       0x00000000
+
+/* SMREACTL */
+#define MECC_Msk        0xFFFF0000
+#define REA128_EXT      0x000001FF
+
+/* SMADDR */
+#define NAND_EOA        0x80000000
+
+/* NAND commands */
+#define NAND_CMD_READ_1ST		0x00U
+#define NAND_CMD_READ_2ND		0x30U
+#define NAND_CMD_STATUS			0x70U
+#define NAND_CMD_RESET			0xFFU
+
+
+
+#endif /* MA35D1_NAND_H */
diff --git a/include/drivers/nuvoton/ma35d1_pmic.h b/include/drivers/nuvoton/ma35d1_pmic.h
new file mode 100644
index 0000000..e075420
--- /dev/null
+++ b/include/drivers/nuvoton/ma35d1_pmic.h
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2021 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MA35D1_PMIC_H
+#define MA35D1_PMIC_H
+
+/*-----------------------------------------------------------------------------
+ * I2C Register's Definition
+ *---------------------------------------------------------------------------*/
+#define    I2C0_BASE        0x40800000  /*!< I2C0 */
+
+#define    REG_I2C0_CTL      (I2C0_BASE+0x000)   /*!< I2C Control Register */
+#define    REG_I2C0_ADDR0    (I2C0_BASE+0x000)   /*!< I2C Slave Address Register0 */
+#define    REG_I2C0_DAT      (I2C0_BASE+0x008)   /*!< I2C Data Register */
+#define    REG_I2C0_STATUS   (I2C0_BASE+0x00C)   /*!< I2C Status Register */
+#define    REG_I2C0_CLKDIV   (I2C0_BASE+0x010)   /*!< I2C Clock Divided Register */
+#define    REG_I2C0_TOCTL    (I2C0_BASE+0x014)   /*!< I2C Time-out Control Register */
+
+
+/*-----------------------------------------*/
+/* global interface variables declarations */
+/*-----------------------------------------*/
+#define I2C_CTL_STA_SI     0x28UL /*!< I2C_CTL setting for I2C control bits. It would set STA and SI bits     */
+#define I2C_CTL_STA_SI_AA  0x2CUL /*!< I2C_CTL setting for I2C control bits. It would set STA, SI and AA bits */
+#define I2C_CTL_STO_SI     0x18UL /*!< I2C_CTL setting for I2C control bits. It would set STO and SI bits     */
+#define I2C_CTL_STO_SI_AA  0x1CUL /*!< I2C_CTL setting for I2C control bits. It would set STO, SI and AA bits */
+#define I2C_CTL_SI         0x08UL /*!< I2C_CTL setting for I2C control bits. It would set SI bit              */
+#define I2C_CTL_SI_AA      0x0CUL /*!< I2C_CTL setting for I2C control bits. It would set SI and AA bits      */
+#define I2C_CTL_STA        0x20UL /*!< I2C_CTL setting for I2C control bits. It would set STA bit             */
+#define I2C_CTL_STO        0x10UL /*!< I2C_CTL setting for I2C control bits. It would set STO bit             */
+#define I2C_CTL_AA         0x04UL /*!< I2C_CTL setting for I2C control bits. It would set AA bit              */
+#define I2C_CTL_ALL        0x3CUL /*!< I2C_CTL setting for I2C control bits. It would set ALL bit             */
+
+#define I2C_CTL_ENABLE     0x40UL /*!< I2C_CTL setting for I2C control bits. It would set I2C Enable bit      */
+
+/*****************************************************************************
+ * PMIC
+ *****************************************************************************/
+#define VOL_CPU 0x01
+#define VOL_SD  0x02
+
+enum {
+	VOL_1_00 = 100,
+	VOL_1_10 = 110,
+	VOL_1_15 = 115,
+	VOL_1_20 = 120,
+	VOL_1_25 = 125,
+	VOL_1_29 = 129,
+	VOL_1_30 = 130,
+	VOL_1_80 = 180,
+	VOL_3_30 = 330
+};
+
+static volatile int pmic_state[3]={0, VOL_1_20 /*CPU*/, VOL_3_30 /*SD*/};
+static volatile int pmicIsInit=0;
+static volatile unsigned long pmic_clk;
+
+int ma35d1_set_pmic(int type, int vol);
+int ma35d1_get_pmic(int type);
+
+#endif /* MA35D1_PMIC_H */
diff --git a/include/drivers/nuvoton/ma35d1_qspi.h b/include/drivers/nuvoton/ma35d1_qspi.h
new file mode 100644
index 0000000..486cdd4
--- /dev/null
+++ b/include/drivers/nuvoton/ma35d1_qspi.h
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MA35D1_QSPI_H
+#define MA35D1_QSPI_H
+
+/*-----------------------------------------------------------------------------
+ * QSPI Register's Definition
+ *---------------------------------------------------------------------------*/
+#define    QSPI0_BASE       0x40680000  /*!< Serial Peripheral Interface 0 */
+
+/* QSPI0 Registers */
+#define     REG_QSPI0_CTL        (QSPI0_BASE+0x00)  /*!< SPI Control Register */
+#define     REG_QSPI0_CLKDIV     (QSPI0_BASE+0x04)  /*!< SPI Clock Divider Register */
+#define     REG_QSPI0_SSCTL      (QSPI0_BASE+0x08)  /*!< SPI Slave Select Control Register */
+#define     REG_QSPI0_PDMACTL    (QSPI0_BASE+0x0c)  /*!< SPI PDMA Control Register */
+#define     REG_QSPI0_FIFOCTL    (QSPI0_BASE+0x10)  /*!< SPI FIFO Control Register */
+#define     REG_QSPI0_STATUS     (QSPI0_BASE+0x14)  /*!< SPI Status Register */
+#define     REG_QSPI0_TX         (QSPI0_BASE+0x20)  /*!< SPI Data Transmit Register */
+#define     REG_QSPI0_RX         (QSPI0_BASE+0x30)  /*!< SPI Data Receive Register */
+
+
+/*-----------------------------------------------------------------------------
+ * Define some constants
+ *---------------------------------------------------------------------------*/
+/* SPI */
+/* Write commands */
+#define CMD_WRITE_STATUS        0x01
+#define CMD_WRITE_DISABLE       0x04
+#define CMD_WRITE_ENABLE        0x06
+#define CMD_WRITE_EVCR          0x61
+
+/* Read commands */
+#define CMD_READ_ARRAY_SLOW         0x03
+#define CMD_READ_QUAD_OUTPUT_FAST   0x6b
+#define CMD_READ_QUAD_IO_FAST       0xeb
+#define CMD_READ_ID                 0x9f
+#define CMD_READ_STATUS             0x05
+#define CMD_READ_STATUS1            0x35
+#define CMD_READ_CONFIG             0x35
+#define CMD_READ_EVCR               0x65
+
+
+#define     GPIO_BASE        0x40040000  /*!< GPIO Control */
+
+#define     GPIOD_MODE          (GPIO_BASE+0xC0) /*!< Port A-H I/O Mode Control                       */
+#define     GPIOD_DOUT          (GPIO_BASE+0xC8) /*!< Port A-H Data Output Value                      */
+#define     GPIOD_SLEWCTL       (GPIO_BASE+0xE8) /*!< Port A-H High Slew Rate Control Register        */
+
+
+
+#endif /* MA35D1_QSPI_H */
diff --git a/include/drivers/nuvoton/ma35d1_sdhc.h b/include/drivers/nuvoton/ma35d1_sdhc.h
new file mode 100644
index 0000000..e79fe3f
--- /dev/null
+++ b/include/drivers/nuvoton/ma35d1_sdhc.h
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MA35D1_SDHC_H
+#define MA35D1_SDHC_H
+
+/*-----------------------------------------------------------------------------
+ * SDHC Register's Definition
+ *---------------------------------------------------------------------------*/
+#define    SDH0_BASE        0x40180000  /*!< SD/SDIO Host Controller */
+#define    SDH1_BASE        0x40190000  /*!< SD/SDIO Host Controller */
+
+/* only define offset */
+#define SDH_DMA_ADDRESS         (0x00)
+#define SDH_BLOCK_SIZE          (0x04)
+#define SDH_BLOCK_COUNT         (0x06)
+#define SDH_ARGUMENT            (0x08)
+#define SDH_XFER_MODE           (0x0C)
+#define SDH_COMMAND             (0x0E)
+	#define SDH_MAKE_CMD(c, f) (((c & 0xff) << 8) | (f & 0xff))
+	#define SDH_GET_CMD(c) ((c>>8) & 0x3f)
+#define SDH_RESPONSE            (0x10)  /* 0x10 ~ 0x1C */
+#define SDH_BUFFER              (0x20)
+#define SDH_PRESENT_STATE       (0x24)
+#define SDH_HOST_CONTROL        (0x28)
+#define SDH_POWER_CONTROL       (0x29)
+#define SDH_BGAP_CONTROL        (0x2A)
+#define SDH_WUP_CONTROL         (0x2B)
+#define SDH_CLOCK_CONTROL       (0x2C)
+#define SDH_TOUT_CONTROL        (0x2E)
+#define SDH_SW_RESET            (0x2F)
+#define SDH_INT_STATUS          (0x30)
+#define SDH_INT_ENABLE          (0x34)
+#define SDH_SIGNAL_ENABLE       (0x38)
+#define SDH_ACMD12_ERR          (0x3C)
+#define SDH_HOST_CONTROL2       (0x3E)
+#define SDH_CAPABILITIES        (0x40)
+#define SDH_CAPABILITIES_1      (0x44)
+#define SDH_MAX_CURRENT         (0x48)  /* 0x48 ~ 0x4C */
+#define SDH_SET_ACMD12_ERROR    (0x50)
+#define SDH_SET_INT_ERROR       (0x52)
+#define SDH_ADMA_ERROR          (0x54)
+#define SDH_ADMA_ADDRESS        (0x58)
+#define SDH_ADMA_ADDRESS_HI     (0x5c)
+#define SDH_SLOT_INT_STATUS     (0xFC)
+#define SDH_HOST_VERSION        (0xFE)
+
+
+/*-----------------------------------------------------------------------------
+ * Define some constants
+ *---------------------------------------------------------------------------*/
+/* SDH */
+#define  SDH_POWER_ON            0x01
+#define  SDH_POWER_180           0x0A
+#define  SDH_POWER_300           0x0C
+#define  SDH_POWER_330           0x0E
+
+#define  SDH_RESET_ALL           0x01
+#define  SDH_RESET_CMD           0x02
+#define  SDH_RESET_DATA          0x04
+
+#define  SDH_CMD_RESP_MASK       0x03
+#define  SDH_CMD_CRC             0x08
+#define  SDH_CMD_INDEX           0x10
+#define  SDH_CMD_DATA            0x20
+#define  SDH_CMD_ABORTCMD        0xC0
+
+#define  SDH_CMD_RESP_NONE       0x00
+#define  SDH_CMD_RESP_LONG       0x01
+#define  SDH_CMD_RESP_SHORT      0x02
+#define  SDH_CMD_RESP_SHORT_BUSY 0x03
+
+
+/* MMC command */
+#define MMC_CMD_GO_IDLE_STATE           0
+#define MMC_CMD_SEND_OP_COND            1
+#define MMC_CMD_ALL_SEND_CID            2
+#define MMC_CMD_SET_RELATIVE_ADDR       3
+#define MMC_CMD_SET_DSR                 4
+#define MMC_CMD_SWITCH                  6
+#define MMC_CMD_SELECT_CARD             7
+#define MMC_CMD_SEND_EXT_CSD            8
+#define MMC_CMD_SEND_CSD                9
+#define MMC_CMD_SEND_CID                10
+#define MMC_CMD_STOP_TRANSMISSION       12
+#define MMC_CMD_SEND_STATUS             13
+#define MMC_CMD_SET_BLOCKLEN            16
+#define MMC_CMD_READ_SINGLE_BLOCK       17
+#define MMC_CMD_READ_MULTIPLE_BLOCK     18
+#define MMC_CMD_SEND_TUNING_BLOCK       19
+#define MMC_CMD_SEND_TUNING_BLOCK_HS200 21
+#define MMC_CMD_SET_BLOCK_COUNT         23
+#define MMC_CMD_WRITE_SINGLE_BLOCK      24
+#define MMC_CMD_WRITE_MULTIPLE_BLOCK    25
+#define MMC_CMD_ERASE_GROUP_START       35
+#define MMC_CMD_ERASE_GROUP_END         36
+#define MMC_CMD_ERASE                   38
+#define MMC_CMD_APP_CMD                 55
+#define MMC_CMD_SPI_READ_OCR            58
+#define MMC_CMD_SPI_CRC_ON_OFF          59
+#define MMC_CMD_RES_MAN                 62
+
+#define SD_CMD_SEND_RELATIVE_ADDR       3
+#define SD_CMD_SWITCH_FUNC              6
+#define SD_CMD_SEND_IF_COND             8
+#define SD_CMD_SWITCH_UHS18V            11
+
+#define SD_CMD_APP_SET_BUS_WIDTH        6
+#define SD_CMD_APP_SD_STATUS            13
+#define SD_CMD_ERASE_WR_BLK_START       32
+#define SD_CMD_ERASE_WR_BLK_END         33
+#define SD_CMD_APP_SEND_OP_COND         41
+#define SD_CMD_APP_SEND_SCR             51
+
+/* MMC response */
+#define MMC_RSP_PRESENT (1 << 0)
+#define MMC_RSP_136     (1 << 1)        /* 136 bit response */
+#define MMC_RSP_CRC     (1 << 2)        /* expect valid crc */
+#define MMC_RSP_BUSY    (1 << 3)        /* card may send busy */
+#define MMC_RSP_OPCODE  (1 << 4)        /* response contains opcode */
+
+#define MMC_RSP_NONE    (0)
+#define MMC_RSP_R1  (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R1b (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE|MMC_RSP_BUSY)
+#define MMC_RSP_R2  (MMC_RSP_PRESENT|MMC_RSP_136|MMC_RSP_CRC)
+#define MMC_RSP_R3  (MMC_RSP_PRESENT)
+#define MMC_RSP_R4  (MMC_RSP_PRESENT)
+#define MMC_RSP_R5  (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R6  (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+#define MMC_RSP_R7  (MMC_RSP_PRESENT|MMC_RSP_CRC|MMC_RSP_OPCODE)
+
+#define DEVICE_UNKNOWN      0
+#define SD_VERSION_2        1
+#define SD_VERSION_1_0      2
+#define MMC_VERSION         3
+
+#define MMC_DATA_READ       1
+#define MMC_DATA_WRITE      2
+
+#endif /* MA35D1_SDHC_H */
diff --git a/include/drivers/nuvoton/uart_ma35d1.h b/include/drivers/nuvoton/uart_ma35d1.h
new file mode 100644
index 0000000..e13b64f
--- /dev/null
+++ b/include/drivers/nuvoton/uart_ma35d1.h
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef UART_MA35D1_H
+#define UART_MA35D1_H
+
+#include <drivers/console.h>
+
+/* UART MA35D1 Registers */
+#define UARTTX			0x0
+#define UARTRX			0x0
+#define UARTIER			0x4
+#define UARTFCR			0x8
+#define UARTLCR			0xc
+#define UARTMCR			0x10
+#define UARTMSR			0x14
+#define UARTFSR			0x18
+#define UARTISR			0x1c
+#define UARTTOR			0x20
+#define UARTBAUD		0x24
+#define UARTIRCR		0x28
+#define UARTALTCSR		0x2c
+#define UARTFUNSEL		0x30
+#define UARTLINCTL		0x34
+#define UARTLINSR		0x38
+
+/* FIFO Control Register bits */
+#define UARTFCR_RXTRIG_1	(0 << 16)
+#define UARTFCR_RXTRIG_4	(1 << 16)
+#define UARTFCR_RXTRIG_8	(2 << 16)
+#define UARTFCR_RXTRIG_14	(3 << 16)
+#define UARTFCR_DMAEN		(1 << 3)	/* Enable DMA mode */
+#define UARTFCR_TXCLR		(1 << 2)	/* Clear contents of Tx FIFO */
+#define UARTFCR_RXCLR		(1 << 1)	/* Clear contents of Rx FIFO */
+
+/* FIFO Status Register bits */
+#define UARTFSR_TXFIFOFULL	(1 << 23)	/* Tx Fifo Full */
+#define UARTFSR_THRE		(1 << 22)	/* Tx Holding Register Empty */
+#define UARTFSR_RXFIFOFULL	(1 << 15)	/* Rx Fifo Full */
+#define UARTFSR_RXFIFOEMT	(1 << 14)	/* Rx Fifo Empty */
+#define UARTFSR_BRK		(1 << 6)	/* Break Condition Detected */
+#define UARTFSR_FERR		(1 << 5)	/* Framing Error */
+#define UARTFSR_PERR		(1 << 4)	/* Parity Error */
+#define UARTFSR_OVRF		(1 << 0)	/* Rx Overrun Error */
+
+/* Line Control Register bits */
+#define UARTLCR_SETB		(1 << 6)	/* Set BREAK Condition */
+#define UARTLCR_SETP		(1 << 5)	/* Set Parity to LCR[4] */
+#define UARTLCR_EVEN		(1 << 4)	/* Even Parity Format */
+#define UARTLCR_PAR		(1 << 3)	/* Parity */
+#define UARTLCR_STOP		(1 << 2)	/* Stop Bit */
+#define UARTLCR_WORDSZ_5	0		/* Word Length of 5 */
+#define UARTLCR_WORDSZ_6	1		/* Word Length of 6 */
+#define UARTLCR_WORDSZ_7	2		/* Word Length of 7 */
+#define UARTLCR_WORDSZ_8	3		/* Word Length of 8 */
+
+/* Interrupt Status Register bits */
+#define UARTISR_THRE		(1 << 1)	/* Tx Holding Register Empty */
+#define UARTISR_RDR_BIT		(0)		/* Rx Data Ready Bit */
+#define UARTISR_RDR		(1 << UARTISR_RDR_BIT)	/* Rx Data Ready */
+
+#ifndef __ASSEMBLER__
+
+#include <stdint.h>
+
+/*
+ * Initialize a new MA35D1 console instance and register it with the console
+ * framework. The |console| pointer must point to storage that will be valid
+ * for the lifetime of the console, such as a global or static local variable.
+ * Its contents will be reinitialized from scratch.
+ * When |clock| has a value of 0, the UART will *not* be initialised. This
+ * means the UART should already be enabled and the baudrate and clock setup
+ * should have been done already, either by platform specific code or by
+ * previous firmware stages. The |baud| parameter will be ignored in this
+ * case as well.
+ */
+int console_ma35d1_register(uintptr_t baseaddr, uint32_t clock, uint32_t baud,
+			   console_t *console);
+
+#endif /*__ASSEMBLER__*/
+
+#endif /* UART_MA35D1_H */
diff --git a/include/dt-bindings/clock/ma35d1-clk.h b/include/dt-bindings/clock/ma35d1-clk.h
new file mode 100644
index 0000000..292bd03
--- /dev/null
+++ b/include/dt-bindings/clock/ma35d1-clk.h
@@ -0,0 +1,78 @@
+/* SPDX-License-Identifier: GPL-2.0-only */
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corporation.
+ */
+
+#ifndef __DT_BINDINGS_CLOCK_MA35D1_H
+#define __DT_BINDINGS_CLOCK_MA35D1_H
+
+#define	capll		0
+#define	syspll		1
+#define	ddrpll		2
+#define	apll		3
+#define	epll		4
+#define	vpll		5
+#define	hxt_gate	6
+#define	lxt_gate	7
+#define	hirc_gate	8
+#define	lirc_gate	9
+#define	ddr0_gate	10
+#define	ddr6_gate	11
+#define	sdh0_gate	12
+#define	sdh1_gate	13
+#define	nand_gate	14
+#define	usbh_gate	15
+#define	husbh0_gate	16
+#define	husbh1_gate	17
+#define	dcu_gate	18
+#define	emac0_gate	19
+#define	emac1_gate	20
+#define	rtc_gate	21
+#define	ddr_gate	22
+#define	i2c0_gate	23
+#define	i2c1_gate	24
+#define	i2c2_gate	25
+#define	i2c3_gate	26
+#define	i2c4_gate	27
+#define	i2c5_gate	28
+#define	qspi0_gate	29
+#define	qspi1_gate	30
+#define	spi0_gate	31
+#define	spi1_gate	32
+#define	spi2_gate	33
+#define	spi3_gate	34
+#define	gpa_gate	35
+#define	gpb_gate	36
+#define	gpc_gate	37
+#define	gpd_gate	38
+#define	gpe_gate	39
+#define	gpf_gate	40
+#define	gpg_gate	41
+#define	gph_gate	42
+#define	gpi_gate	43
+#define	gpj_gate	44
+#define	gpk_gate	45
+#define	gpl_gate	46
+#define	gpm_gate	47
+#define	gpn_gate	48
+#define	ca35clk_mux	49
+#define	sysclk0_mux	50
+#define	sysclk1_mux	51
+#define	sdh0_mux	52
+#define	sdh1_mux	53
+#define	dcu_mux		54
+#define	dcup_mux	55
+#define	spi0_mux	56
+#define	spi1_mux	57
+#define	spi2_mux	58
+#define	spi3_mux	59
+#define	qspi0_mux	60
+#define	qspi1_mux	61
+#define	dcup_div	62
+#define	emac0_div	63
+#define	emac1_div	64
+#define	aclk0_div	65
+
+#define	clk_max		66
+
+#endif
diff --git a/include/dt-bindings/pinctrl/ma35d1-pinfunc.h b/include/dt-bindings/pinctrl/ma35d1-pinfunc.h
new file mode 100644
index 0000000..2ed5363
--- /dev/null
+++ b/include/dt-bindings/pinctrl/ma35d1-pinfunc.h
@@ -0,0 +1,1617 @@
+#ifndef _MA35D1_PINFUNC_
+#define _MA35D1_PINFUNC_
+
+/*
+ * The pin function    <REGISTER_OFFSET    BitMask_OFFSET    MFP_VALUE>
+ */
+
+/********************* Bit definition of GPA_MFPL register **********************/
+#define SYS_GPA_MFPL_PA0MFP_EBI_AD0          0x080    0x00    0x7
+#define SYS_GPA_MFPL_PA0MFP_EBI_ADR0         0x080    0x00    0x9
+#define SYS_GPA_MFPL_PA0MFP_GPIO             0x080    0x00    0x0
+#define SYS_GPA_MFPL_PA0MFP_NAND_DATA0       0x080    0x00    0x6
+#define SYS_GPA_MFPL_PA0MFP_UART1_nCTS       0x080    0x00    0x2
+#define SYS_GPA_MFPL_PA0MFP_UART16_RXD       0x080    0x00    0x3
+#define SYS_GPA_MFPL_PA1MFP_EBI_AD1          0x080    0x04    0x7
+#define SYS_GPA_MFPL_PA1MFP_EBI_ADR1         0x080    0x04    0x9
+#define SYS_GPA_MFPL_PA1MFP_GPIO             0x080    0x04    0x0
+#define SYS_GPA_MFPL_PA1MFP_NAND_DATA1       0x080    0x04    0x6
+#define SYS_GPA_MFPL_PA1MFP_UART1_nRTS       0x080    0x04    0x2
+#define SYS_GPA_MFPL_PA1MFP_UART16_TXD       0x080    0x04    0x3
+#define SYS_GPA_MFPL_PA2MFP_EBI_AD2          0x080    0x08    0x7
+#define SYS_GPA_MFPL_PA2MFP_EBI_ADR2         0x080    0x08    0x9
+#define SYS_GPA_MFPL_PA2MFP_GPIO             0x080    0x08    0x0
+#define SYS_GPA_MFPL_PA2MFP_NAND_DATA2       0x080    0x08    0x6
+#define SYS_GPA_MFPL_PA2MFP_UART1_RXD        0x080    0x08    0x2
+#define SYS_GPA_MFPL_PA3MFP_EBI_AD3          0x080    0x0C    0x7
+#define SYS_GPA_MFPL_PA3MFP_EBI_ADR3         0x080    0x0C    0x9
+#define SYS_GPA_MFPL_PA3MFP_GPIO             0x080    0x0C    0x0
+#define SYS_GPA_MFPL_PA3MFP_NAND_DATA3       0x080    0x0C    0x6
+#define SYS_GPA_MFPL_PA3MFP_UART1_TXD        0x080    0x0C    0x2
+#define SYS_GPA_MFPL_PA4MFP_EBI_AD4          0x080    0x10    0x7
+#define SYS_GPA_MFPL_PA4MFP_EBI_ADR4         0x080    0x10    0x9
+#define SYS_GPA_MFPL_PA4MFP_GPIO             0x080    0x10    0x0
+#define SYS_GPA_MFPL_PA4MFP_NAND_DATA4       0x080    0x10    0x6
+#define SYS_GPA_MFPL_PA4MFP_UART2_RXD        0x080    0x10    0x3
+#define SYS_GPA_MFPL_PA4MFP_UART3_nCTS       0x080    0x10    0x2
+#define SYS_GPA_MFPL_PA5MFP_EBI_AD5          0x080    0x14    0x7
+#define SYS_GPA_MFPL_PA5MFP_EBI_ADR5         0x080    0x14    0x9
+#define SYS_GPA_MFPL_PA5MFP_GPIO             0x080    0x14    0x0
+#define SYS_GPA_MFPL_PA5MFP_NAND_DATA5       0x080    0x14    0x6
+#define SYS_GPA_MFPL_PA5MFP_UART2_TXD        0x080    0x14    0x3
+#define SYS_GPA_MFPL_PA5MFP_UART3_nRTS       0x080    0x14    0x2
+#define SYS_GPA_MFPL_PA6MFP_EBI_AD6          0x080    0x18    0x7
+#define SYS_GPA_MFPL_PA6MFP_EBI_ADR6         0x080    0x18    0x9
+#define SYS_GPA_MFPL_PA6MFP_GPIO             0x080    0x18    0x0
+#define SYS_GPA_MFPL_PA6MFP_NAND_DATA6       0x080    0x18    0x6
+#define SYS_GPA_MFPL_PA6MFP_UART3_RXD        0x080    0x18    0x2
+#define SYS_GPA_MFPL_PA7MFP_EBI_AD7          0x080    0x1C    0x7
+#define SYS_GPA_MFPL_PA7MFP_EBI_ADR7         0x080    0x1C    0x9
+#define SYS_GPA_MFPL_PA7MFP_GPIO             0x080    0x1C    0x0
+#define SYS_GPA_MFPL_PA7MFP_NAND_DATA7       0x080    0x1C    0x6
+#define SYS_GPA_MFPL_PA7MFP_UART3_TXD        0x080    0x1C    0x2
+/********************* Bit definition of GPA_MFPH register **********************/
+#define SYS_GPA_MFPH_PA8MFP_EBI_AD8          0x084    0x00    0x7
+#define SYS_GPA_MFPH_PA8MFP_EBI_ADR8         0x084    0x00    0x9
+#define SYS_GPA_MFPH_PA8MFP_GPIO             0x084    0x00    0x0
+#define SYS_GPA_MFPH_PA8MFP_NAND_RDY         0x084    0x00    0x6
+#define SYS_GPA_MFPH_PA8MFP_UART4_RXD        0x084    0x00    0x3
+#define SYS_GPA_MFPH_PA8MFP_UART5_nCTS       0x084    0x00    0x2
+#define SYS_GPA_MFPH_PA9MFP_EBI_AD9          0x084    0x04    0x7
+#define SYS_GPA_MFPH_PA9MFP_EBI_ADR9         0x084    0x04    0x9
+#define SYS_GPA_MFPH_PA9MFP_GPIO             0x084    0x04    0x0
+#define SYS_GPA_MFPH_PA9MFP_NAND_nRE         0x084    0x04    0x6
+#define SYS_GPA_MFPH_PA9MFP_UART4_TXD        0x084    0x04    0x3
+#define SYS_GPA_MFPH_PA9MFP_UART5_nRTS       0x084    0x04    0x2
+#define SYS_GPA_MFPH_PA10MFP_EBI_AD10        0x084    0x08    0x7
+#define SYS_GPA_MFPH_PA10MFP_EBI_ADR10       0x084    0x08    0x9
+#define SYS_GPA_MFPH_PA10MFP_GPIO            0x084    0x08    0x0
+#define SYS_GPA_MFPH_PA10MFP_NAND_nWE        0x084    0x08    0x6
+#define SYS_GPA_MFPH_PA10MFP_UART5_RXD       0x084    0x08    0x2
+#define SYS_GPA_MFPH_PA11MFP_EBI_AD11        0x084    0x0C    0x7
+#define SYS_GPA_MFPH_PA11MFP_EBI_ADR11       0x084    0x0C    0x9
+#define SYS_GPA_MFPH_PA11MFP_GPIO            0x084    0x0C    0x0
+#define SYS_GPA_MFPH_PA11MFP_NAND_CLE        0x084    0x0C    0x6
+#define SYS_GPA_MFPH_PA11MFP_UART5_TXD       0x084    0x0C    0x2
+#define SYS_GPA_MFPH_PA12MFP_EBI_AD12        0x084    0x10    0x7
+#define SYS_GPA_MFPH_PA12MFP_EBI_ADR12       0x084    0x10    0x9
+#define SYS_GPA_MFPH_PA12MFP_GPIO            0x084    0x10    0x0
+#define SYS_GPA_MFPH_PA12MFP_NAND_ALE        0x084    0x10    0x6
+#define SYS_GPA_MFPH_PA12MFP_UART7_nCTS      0x084    0x10    0x2
+#define SYS_GPA_MFPH_PA12MFP_UART8_RXD       0x084    0x10    0x3
+#define SYS_GPA_MFPH_PA13MFP_EBI_AD13        0x084    0x14    0x7
+#define SYS_GPA_MFPH_PA13MFP_EBI_ADR13       0x084    0x14    0x9
+#define SYS_GPA_MFPH_PA13MFP_GPIO            0x084    0x14    0x0
+#define SYS_GPA_MFPH_PA13MFP_NAND_nCS        0x084    0x14    0x6
+#define SYS_GPA_MFPH_PA13MFP_UART7_nRTS      0x084    0x14    0x2
+#define SYS_GPA_MFPH_PA13MFP_UART8_TXD       0x084    0x14    0x3
+#define SYS_GPA_MFPH_PA14MFP_CAN3_RXD        0x084    0x18    0x3
+#define SYS_GPA_MFPH_PA14MFP_EBI_AD14        0x084    0x18    0x7
+#define SYS_GPA_MFPH_PA14MFP_EBI_ADR14       0x084    0x18    0x9
+#define SYS_GPA_MFPH_PA14MFP_GPIO            0x084    0x18    0x0
+#define SYS_GPA_MFPH_PA14MFP_NAND_nWP        0x084    0x18    0x6
+#define SYS_GPA_MFPH_PA14MFP_UART7_RXD       0x084    0x18    0x2
+#define SYS_GPA_MFPH_PA14MFP_USBHL3_DM       0x084    0x18    0x4
+#define SYS_GPA_MFPH_PA15MFP_CAN2_RXD        0x084    0x1C    0x5
+#define SYS_GPA_MFPH_PA15MFP_EBI_ALE         0x084    0x1C    0x7
+#define SYS_GPA_MFPH_PA15MFP_EPWM0_CH2       0x084    0x1C    0x1
+#define SYS_GPA_MFPH_PA15MFP_GPIO            0x084    0x1C    0x0
+#define SYS_GPA_MFPH_PA15MFP_I2C4_SDA        0x084    0x1C    0x4
+#define SYS_GPA_MFPH_PA15MFP_QEI0_A          0x084    0x1C    0x9
+#define SYS_GPA_MFPH_PA15MFP_RGMII0_PPS      0x084    0x1C    0xE
+#define SYS_GPA_MFPH_PA15MFP_RMII0_PPS       0x084    0x1C    0xF
+#define SYS_GPA_MFPH_PA15MFP_TM1             0x084    0x1C    0xB
+#define SYS_GPA_MFPH_PA15MFP_UART6_RXD       0x084    0x1C    0x3
+#define SYS_GPA_MFPH_PA15MFP_UART9_nCTS      0x084    0x1C    0x2
+#define SYS_GPA_MFPH_PA15MFP_USBHL0_DM       0x084    0x1C    0x6
+/********************* Bit definition of GPB_MFPL register **********************/
+#define SYS_GPB_MFPL_PB0MFP_EADC0_CH0        0x088    0x00    0x8
+#define SYS_GPB_MFPL_PB0MFP_GPIO             0x088    0x00    0x0
+#define SYS_GPB_MFPL_PB1MFP_EADC0_CH1        0x088    0x04    0x8
+#define SYS_GPB_MFPL_PB1MFP_GPIO             0x088    0x04    0x0
+#define SYS_GPB_MFPL_PB2MFP_EADC0_CH2        0x088    0x08    0x8
+#define SYS_GPB_MFPL_PB2MFP_GPIO             0x088    0x08    0x0
+#define SYS_GPB_MFPL_PB3MFP_EADC0_CH3        0x088    0x0C    0x8
+#define SYS_GPB_MFPL_PB3MFP_GPIO             0x088    0x0C    0x0
+#define SYS_GPB_MFPL_PB4MFP_EADC0_CH4        0x088    0x10    0x8
+#define SYS_GPB_MFPL_PB4MFP_GPIO             0x088    0x10    0x0
+#define SYS_GPB_MFPL_PB5MFP_EADC0_CH5        0x088    0x14    0x8
+#define SYS_GPB_MFPL_PB5MFP_GPIO             0x088    0x14    0x0
+#define SYS_GPB_MFPL_PB6MFP_EADC0_CH6        0x088    0x18    0x8
+#define SYS_GPB_MFPL_PB6MFP_GPIO             0x088    0x18    0x0
+#define SYS_GPB_MFPL_PB7MFP_EADC0_CH7        0x088    0x1C    0x8
+#define SYS_GPB_MFPL_PB7MFP_GPIO             0x088    0x1C    0x0
+/********************* Bit definition of GPB_MFPH register **********************/
+#define SYS_GPB_MFPH_PB8MFP_ADC0_CH0         0x08C    0x00    0x8
+#define SYS_GPB_MFPH_PB8MFP_EBI_nCS0         0x08C    0x00    0x9
+#define SYS_GPB_MFPH_PB8MFP_EPWM2_BRAKE0     0x08C    0x00    0x1
+#define SYS_GPB_MFPH_PB8MFP_GPIO             0x08C    0x00    0x0
+#define SYS_GPB_MFPH_PB8MFP_I2C2_SDA         0x08C    0x00    0x4
+#define SYS_GPB_MFPH_PB8MFP_QEI2_INDEX       0x08C    0x00    0xE
+#define SYS_GPB_MFPH_PB8MFP_SPI0_I2SMCLK     0x08C    0x00    0x6
+#define SYS_GPB_MFPH_PB8MFP_SPI0_SS1         0x08C    0x00    0x5
+#define SYS_GPB_MFPH_PB8MFP_TM4              0x08C    0x00    0xB
+#define SYS_GPB_MFPH_PB8MFP_UART1_RXD        0x08C    0x00    0x3
+#define SYS_GPB_MFPH_PB8MFP_UART2_nCTS       0x08C    0x00    0x2
+#define SYS_GPB_MFPH_PB9MFP_ADC0_CH1         0x08C    0x04    0x8
+#define SYS_GPB_MFPH_PB9MFP_EBI_AD13         0x08C    0x04    0xA
+#define SYS_GPB_MFPH_PB9MFP_EBI_ALE          0x08C    0x04    0x9
+#define SYS_GPB_MFPH_PB9MFP_EPWM2_CH4        0x08C    0x04    0x1
+#define SYS_GPB_MFPH_PB9MFP_GPIO             0x08C    0x04    0x0
+#define SYS_GPB_MFPH_PB9MFP_I2C2_SCL         0x08C    0x04    0x4
+#define SYS_GPB_MFPH_PB9MFP_I2S0_MCLK        0x08C    0x04    0x6
+#define SYS_GPB_MFPH_PB9MFP_I2S1_MCLK        0x08C    0x04    0xC
+#define SYS_GPB_MFPH_PB9MFP_QEI2_A           0x08C    0x04    0xE
+#define SYS_GPB_MFPH_PB9MFP_SC0_nCD          0x08C    0x04    0xD
+#define SYS_GPB_MFPH_PB9MFP_SPI0_CLK         0x08C    0x04    0x5
+#define SYS_GPB_MFPH_PB9MFP_TM0_EXT          0x08C    0x04    0xB
+#define SYS_GPB_MFPH_PB9MFP_UART1_TXD        0x08C    0x04    0x3
+#define SYS_GPB_MFPH_PB9MFP_UART2_nRTS       0x08C    0x04    0x2
+#define SYS_GPB_MFPH_PB9MFP_VCAP1_HSYNC      0x08C    0x04    0x7
+#define SYS_GPB_MFPH_PB10MFP_ADC0_CH2        0x08C    0x08    0x8
+#define SYS_GPB_MFPH_PB10MFP_CAN0_RXD        0x08C    0x08    0x3
+#define SYS_GPB_MFPH_PB10MFP_EBI_AD14        0x08C    0x08    0xA
+#define SYS_GPB_MFPH_PB10MFP_EBI_ADR15       0x08C    0x08    0x9
+#define SYS_GPB_MFPH_PB10MFP_EBI_MCLK        0x08C    0x08    0x6
+#define SYS_GPB_MFPH_PB10MFP_EPWM2_CH5       0x08C    0x08    0x1
+#define SYS_GPB_MFPH_PB10MFP_GPIO            0x08C    0x08    0x0
+#define SYS_GPB_MFPH_PB10MFP_I2C1_SDA        0x08C    0x08    0xC
+#define SYS_GPB_MFPH_PB10MFP_INT1            0x08C    0x08    0xD
+#define SYS_GPB_MFPH_PB10MFP_QEI2_B          0x08C    0x08    0xE
+#define SYS_GPB_MFPH_PB10MFP_SPI0_MOSI       0x08C    0x08    0x5
+#define SYS_GPB_MFPH_PB10MFP_TM5             0x08C    0x08    0xB
+#define SYS_GPB_MFPH_PB10MFP_UART2_RXD       0x08C    0x08    0x2
+#define SYS_GPB_MFPH_PB10MFP_USBHL2_DM       0x08C    0x08    0x4
+#define SYS_GPB_MFPH_PB10MFP_VCAP1_VSYNC     0x08C    0x08    0x7
+#define SYS_GPB_MFPH_PB11MFP_ADC0_CH3        0x08C    0x0C    0x8
+#define SYS_GPB_MFPH_PB11MFP_CAN0_TXD        0x08C    0x0C    0x3
+#define SYS_GPB_MFPH_PB11MFP_EBI_ALE         0x08C    0x0C    0xA
+#define SYS_GPB_MFPH_PB11MFP_EBI_nCS2        0x08C    0x0C    0x9
+#define SYS_GPB_MFPH_PB11MFP_EPWM2_BRAKE1    0x08C    0x0C    0x1
+#define SYS_GPB_MFPH_PB11MFP_GPIO            0x08C    0x0C    0x0
+#define SYS_GPB_MFPH_PB11MFP_I2C1_SCL        0x08C    0x0C    0xC
+#define SYS_GPB_MFPH_PB11MFP_I2S1_MCLK       0x08C    0x0C    0x6
+#define SYS_GPB_MFPH_PB11MFP_INT2            0x08C    0x0C    0xD
+#define SYS_GPB_MFPH_PB11MFP_QEI2_INDEX      0x08C    0x0C    0xE
+#define SYS_GPB_MFPH_PB11MFP_SPI0_MISO       0x08C    0x0C    0x5
+#define SYS_GPB_MFPH_PB11MFP_TM5_EXT         0x08C    0x0C    0xB
+#define SYS_GPB_MFPH_PB11MFP_UART2_TXD       0x08C    0x0C    0x2
+#define SYS_GPB_MFPH_PB11MFP_USBHL2_DP       0x08C    0x0C    0x4
+#define SYS_GPB_MFPH_PB11MFP_VCAP1_SFIELD    0x08C    0x0C    0x7
+#define SYS_GPB_MFPH_PB12MFP_ADC0_CH4        0x08C    0x10    0x8
+#define SYS_GPB_MFPH_PB12MFP_CAN2_RXD        0x08C    0x10    0x5
+#define SYS_GPB_MFPH_PB12MFP_EBI_ADR16       0x08C    0x10    0x9
+#define SYS_GPB_MFPH_PB12MFP_ECAP2_IC0       0x08C    0x10    0xE
+#define SYS_GPB_MFPH_PB12MFP_EPWM2_CH0       0x08C    0x10    0x1
+#define SYS_GPB_MFPH_PB12MFP_GPIO            0x08C    0x10    0x0
+#define SYS_GPB_MFPH_PB12MFP_I2C3_SDA        0x08C    0x10    0x4
+#define SYS_GPB_MFPH_PB12MFP_I2S1_LRCK       0x08C    0x10    0x6
+#define SYS_GPB_MFPH_PB12MFP_UART3_RXD       0x08C    0x10    0x3
+#define SYS_GPB_MFPH_PB12MFP_UART4_nCTS      0x08C    0x10    0x2
+#define SYS_GPB_MFPH_PB12MFP_USBHL1_DM       0x08C    0x10    0x7
+#define SYS_GPB_MFPH_PB13MFP_ADC0_CH5        0x08C    0x14    0x8
+#define SYS_GPB_MFPH_PB13MFP_CAN2_TXD        0x08C    0x14    0x5
+#define SYS_GPB_MFPH_PB13MFP_EBI_ADR17       0x08C    0x14    0x9
+#define SYS_GPB_MFPH_PB13MFP_ECAP2_IC1       0x08C    0x14    0xE
+#define SYS_GPB_MFPH_PB13MFP_EPWM2_CH1       0x08C    0x14    0x1
+#define SYS_GPB_MFPH_PB13MFP_GPIO            0x08C    0x14    0x0
+#define SYS_GPB_MFPH_PB13MFP_I2C3_SCL        0x08C    0x14    0x4
+#define SYS_GPB_MFPH_PB13MFP_I2S1_BCLK       0x08C    0x14    0x6
+#define SYS_GPB_MFPH_PB13MFP_UART3_TXD       0x08C    0x14    0x3
+#define SYS_GPB_MFPH_PB13MFP_UART4_nRTS      0x08C    0x14    0x2
+#define SYS_GPB_MFPH_PB13MFP_USBHL1_DP       0x08C    0x14    0x7
+#define SYS_GPB_MFPH_PB14MFP_ADC0_CH6        0x08C    0x18    0x8
+#define SYS_GPB_MFPH_PB14MFP_CAN1_RXD        0x08C    0x18    0x3
+#define SYS_GPB_MFPH_PB14MFP_EBI_ADR18       0x08C    0x18    0x9
+#define SYS_GPB_MFPH_PB14MFP_ECAP2_IC2       0x08C    0x18    0xE
+#define SYS_GPB_MFPH_PB14MFP_EPWM2_CH2       0x08C    0x18    0x1
+#define SYS_GPB_MFPH_PB14MFP_GPIO            0x08C    0x18    0x0
+#define SYS_GPB_MFPH_PB14MFP_I2C4_SDA        0x08C    0x18    0x5
+#define SYS_GPB_MFPH_PB14MFP_I2S1_DI         0x08C    0x18    0x6
+#define SYS_GPB_MFPH_PB14MFP_UART4_RXD       0x08C    0x18    0x2
+#define SYS_GPB_MFPH_PB14MFP_USBHL3_DM       0x08C    0x18    0x4
+#define SYS_GPB_MFPH_PB15MFP_ADC0_CH7        0x08C    0x1C    0x8
+#define SYS_GPB_MFPH_PB15MFP_CAN1_TXD        0x08C    0x1C    0x3
+#define SYS_GPB_MFPH_PB15MFP_EBI_ADR19       0x08C    0x1C    0x9
+#define SYS_GPB_MFPH_PB15MFP_EPWM2_CH3       0x08C    0x1C    0x1
+#define SYS_GPB_MFPH_PB15MFP_GPIO            0x08C    0x1C    0x0
+#define SYS_GPB_MFPH_PB15MFP_I2C4_SCL        0x08C    0x1C    0x5
+#define SYS_GPB_MFPH_PB15MFP_I2S1_DO         0x08C    0x1C    0x6
+#define SYS_GPB_MFPH_PB15MFP_UART4_TXD       0x08C    0x1C    0x2
+#define SYS_GPB_MFPH_PB15MFP_USBHL3_DP       0x08C    0x1C    0x4
+/********************* Bit definition of GPC_MFPL register **********************/
+#define SYS_GPC_MFPL_PC0MFP_eMMC0_CMD        0x090    0x00    0x6
+#define SYS_GPC_MFPL_PC0MFP_GPIO             0x090    0x00    0x0
+#define SYS_GPC_MFPL_PC0MFP_I2C4_SDA         0x090    0x00    0x4
+#define SYS_GPC_MFPL_PC0MFP_SD0_CMD          0x090    0x00    0x6
+#define SYS_GPC_MFPL_PC1MFP_eMMC0_CLK        0x090    0x04    0x6
+#define SYS_GPC_MFPL_PC1MFP_GPIO             0x090    0x04    0x0
+#define SYS_GPC_MFPL_PC1MFP_I2C4_SCL         0x090    0x04    0x4
+#define SYS_GPC_MFPL_PC1MFP_SD0_CLK          0x090    0x04    0x6
+#define SYS_GPC_MFPL_PC2MFP_CAN0_RXD         0x090    0x08    0x3
+#define SYS_GPC_MFPL_PC2MFP_eMMC0_DAT0       0x090    0x08    0x6
+#define SYS_GPC_MFPL_PC2MFP_GPIO             0x090    0x08    0x0
+#define SYS_GPC_MFPL_PC2MFP_SD0_DAT0         0x090    0x08    0x6
+#define SYS_GPC_MFPL_PC2MFP_USBHL4_DM        0x090    0x08    0x4
+#define SYS_GPC_MFPL_PC3MFP_CAN0_TXD         0x090    0x0C    0x3
+#define SYS_GPC_MFPL_PC3MFP_eMMC0_DAT1       0x090    0x0C    0x6
+#define SYS_GPC_MFPL_PC3MFP_GPIO             0x090    0x0C    0x0
+#define SYS_GPC_MFPL_PC3MFP_SD0_DAT1         0x090    0x0C    0x6
+#define SYS_GPC_MFPL_PC3MFP_USBHL4_DP        0x090    0x0C    0x4
+#define SYS_GPC_MFPL_PC4MFP_eMMC0_DAT2       0x090    0x10    0x6
+#define SYS_GPC_MFPL_PC4MFP_GPIO             0x090    0x10    0x0
+#define SYS_GPC_MFPL_PC4MFP_I2C5_SDA         0x090    0x10    0x4
+#define SYS_GPC_MFPL_PC4MFP_SD0_DAT2         0x090    0x10    0x6
+#define SYS_GPC_MFPL_PC5MFP_eMMC0_DAT3       0x090    0x14    0x6
+#define SYS_GPC_MFPL_PC5MFP_GPIO             0x090    0x14    0x0
+#define SYS_GPC_MFPL_PC5MFP_I2C5_SCL         0x090    0x14    0x4
+#define SYS_GPC_MFPL_PC5MFP_SD0_DAT3         0x090    0x14    0x6
+#define SYS_GPC_MFPL_PC6MFP_CAN1_RXD         0x090    0x18    0x3
+#define SYS_GPC_MFPL_PC6MFP_GPIO             0x090    0x18    0x0
+#define SYS_GPC_MFPL_PC6MFP_SD0_nCD          0x090    0x18    0x6
+#define SYS_GPC_MFPL_PC6MFP_USBHL5_DM        0x090    0x18    0x4
+#define SYS_GPC_MFPL_PC7MFP_CAN1_TXD         0x090    0x1C    0x3
+#define SYS_GPC_MFPL_PC7MFP_GPIO             0x090    0x1C    0x0
+#define SYS_GPC_MFPL_PC7MFP_SD0_WP           0x090    0x1C    0x6
+#define SYS_GPC_MFPL_PC7MFP_USBHL5_DP        0x090    0x1C    0x4
+/********************* Bit definition of GPC_MFPH register **********************/
+#define SYS_GPC_MFPH_PC8MFP_eMMC0_DAT4       0x094    0x00    0x6
+#define SYS_GPC_MFPH_PC8MFP_EPWM2_CH0        0x094    0x00    0x1
+#define SYS_GPC_MFPH_PC8MFP_GPIO             0x094    0x00    0x0
+#define SYS_GPC_MFPH_PC8MFP_I2C0_SDA         0x094    0x00    0x4
+#define SYS_GPC_MFPH_PC8MFP_SPI1_SS0         0x094    0x00    0x5
+#define SYS_GPC_MFPH_PC8MFP_UART10_nCTS      0x094    0x00    0x2
+#define SYS_GPC_MFPH_PC8MFP_UART9_RXD        0x094    0x00    0x3
+#define SYS_GPC_MFPH_PC9MFP_eMMC0_DAT5       0x094    0x04    0x6
+#define SYS_GPC_MFPH_PC9MFP_EPWM2_CH1        0x094    0x04    0x1
+#define SYS_GPC_MFPH_PC9MFP_GPIO             0x094    0x04    0x0
+#define SYS_GPC_MFPH_PC9MFP_I2C0_SCL         0x094    0x04    0x4
+#define SYS_GPC_MFPH_PC9MFP_SPI1_CLK         0x094    0x04    0x5
+#define SYS_GPC_MFPH_PC9MFP_UART10_nRTS      0x094    0x04    0x2
+#define SYS_GPC_MFPH_PC9MFP_UART9_TXD        0x094    0x04    0x3
+#define SYS_GPC_MFPH_PC10MFP_CAN2_RXD        0x094    0x08    0x3
+#define SYS_GPC_MFPH_PC10MFP_eMMC0_DAT6      0x094    0x08    0x6
+#define SYS_GPC_MFPH_PC10MFP_EPWM2_CH2       0x094    0x08    0x1
+#define SYS_GPC_MFPH_PC10MFP_GPIO            0x094    0x08    0x0
+#define SYS_GPC_MFPH_PC10MFP_SPI1_MOSI       0x094    0x08    0x5
+#define SYS_GPC_MFPH_PC10MFP_UART10_RXD      0x094    0x08    0x2
+#define SYS_GPC_MFPH_PC10MFP_USBHL0_DM       0x094    0x08    0x4
+#define SYS_GPC_MFPH_PC11MFP_CAN2_TXD        0x094    0x0C    0x3
+#define SYS_GPC_MFPH_PC11MFP_eMMC0_DAT7      0x094    0x0C    0x6
+#define SYS_GPC_MFPH_PC11MFP_EPWM2_CH3       0x094    0x0C    0x1
+#define SYS_GPC_MFPH_PC11MFP_GPIO            0x094    0x0C    0x0
+#define SYS_GPC_MFPH_PC11MFP_SPI1_MISO       0x094    0x0C    0x5
+#define SYS_GPC_MFPH_PC11MFP_UART10_TXD      0x094    0x0C    0x2
+#define SYS_GPC_MFPH_PC11MFP_USBHL0_DP       0x094    0x0C    0x4
+#define SYS_GPC_MFPH_PC12MFP_GPIO            0x094    0x10    0x0
+#define SYS_GPC_MFPH_PC12MFP_LCM_DATA16      0x094    0x10    0x6
+#define SYS_GPC_MFPH_PC12MFP_UART11_RXD      0x094    0x10    0x3
+#define SYS_GPC_MFPH_PC12MFP_UART12_nCTS     0x094    0x10    0x2
+#define SYS_GPC_MFPH_PC13MFP_GPIO            0x094    0x14    0x0
+#define SYS_GPC_MFPH_PC13MFP_LCM_DATA17      0x094    0x14    0x6
+#define SYS_GPC_MFPH_PC13MFP_UART11_TXD      0x094    0x14    0x3
+#define SYS_GPC_MFPH_PC13MFP_UART12_nRTS     0x094    0x14    0x2
+#define SYS_GPC_MFPH_PC14MFP_GPIO            0x094    0x18    0x0
+#define SYS_GPC_MFPH_PC14MFP_LCM_DATA18      0x094    0x18    0x6
+#define SYS_GPC_MFPH_PC14MFP_UART12_RXD      0x094    0x18    0x2
+#define SYS_GPC_MFPH_PC15MFP_GPIO            0x094    0x1C    0x0
+#define SYS_GPC_MFPH_PC15MFP_LCM_DATA19      0x094    0x1C    0x6
+#define SYS_GPC_MFPH_PC15MFP_LCM_MPU_TE      0x094    0x1C    0x7
+#define SYS_GPC_MFPH_PC15MFP_LCM_MPU_VSYNC   0x094    0x1C    0x8
+#define SYS_GPC_MFPH_PC15MFP_UART12_TXD      0x094    0x1C    0x2
+/********************* Bit definition of GPD_MFPL register **********************/
+#define SYS_GPD_MFPL_PD0MFP_GPIO             0x098    0x00    0x0
+#define SYS_GPD_MFPL_PD0MFP_QSPI0_SS0        0x098    0x00    0x5
+#define SYS_GPD_MFPL_PD0MFP_UART3_nCTS       0x098    0x00    0x2
+#define SYS_GPD_MFPL_PD0MFP_UART4_RXD        0x098    0x00    0x3
+#define SYS_GPD_MFPL_PD1MFP_GPIO             0x098    0x04    0x0
+#define SYS_GPD_MFPL_PD1MFP_QSPI0_CLK        0x098    0x04    0x5
+#define SYS_GPD_MFPL_PD1MFP_UART3_nRTS       0x098    0x04    0x2
+#define SYS_GPD_MFPL_PD1MFP_UART4_TXD        0x098    0x04    0x3
+#define SYS_GPD_MFPL_PD2MFP_GPIO             0x098    0x08    0x0
+#define SYS_GPD_MFPL_PD2MFP_QSPI0_MOSI0      0x098    0x08    0x5
+#define SYS_GPD_MFPL_PD2MFP_UART3_RXD        0x098    0x08    0x2
+#define SYS_GPD_MFPL_PD3MFP_GPIO             0x098    0x0C    0x0
+#define SYS_GPD_MFPL_PD3MFP_QSPI0_MISO0      0x098    0x0C    0x5
+#define SYS_GPD_MFPL_PD3MFP_UART3_TXD        0x098    0x0C    0x2
+#define SYS_GPD_MFPL_PD4MFP_GPIO             0x098    0x10    0x0
+#define SYS_GPD_MFPL_PD4MFP_I2C2_SDA         0x098    0x10    0x4
+#define SYS_GPD_MFPL_PD4MFP_QSPI0_MOSI1      0x098    0x10    0x5
+#define SYS_GPD_MFPL_PD4MFP_UART1_nCTS       0x098    0x10    0x2
+#define SYS_GPD_MFPL_PD4MFP_UART2_RXD        0x098    0x10    0x3
+#define SYS_GPD_MFPL_PD5MFP_GPIO             0x098    0x14    0x0
+#define SYS_GPD_MFPL_PD5MFP_I2C2_SCL         0x098    0x14    0x4
+#define SYS_GPD_MFPL_PD5MFP_QSPI0_MISO1      0x098    0x14    0x5
+#define SYS_GPD_MFPL_PD5MFP_UART1_nRTS       0x098    0x14    0x2
+#define SYS_GPD_MFPL_PD5MFP_UART2_TXD        0x098    0x14    0x3
+#define SYS_GPD_MFPL_PD6MFP_EBI_AD5          0x098    0x18    0x9
+#define SYS_GPD_MFPL_PD6MFP_EPWM0_CH0        0x098    0x18    0x8
+#define SYS_GPD_MFPL_PD6MFP_EPWM0_SYNC_IN    0x098    0x18    0x1
+#define SYS_GPD_MFPL_PD6MFP_GPIO             0x098    0x18    0x0
+#define SYS_GPD_MFPL_PD6MFP_I2C0_SDA         0x098    0x18    0x6
+#define SYS_GPD_MFPL_PD6MFP_I2S0_MCLK        0x098    0x18    0x7
+#define SYS_GPD_MFPL_PD6MFP_QSPI1_MOSI1      0x098    0x18    0x5
+#define SYS_GPD_MFPL_PD6MFP_SPI3_SS1         0x098    0x18    0xA
+#define SYS_GPD_MFPL_PD6MFP_TRACE_CLK        0x098    0x18    0xB
+#define SYS_GPD_MFPL_PD6MFP_UART1_RXD        0x098    0x18    0x2
+#define SYS_GPD_MFPL_PD6MFP_USBHL3_DM        0x098    0x18    0x4
+#define SYS_GPD_MFPL_PD7MFP_EADC0_ST         0x098    0x1C    0xB
+#define SYS_GPD_MFPL_PD7MFP_EBI_AD6          0x098    0x1C    0x9
+#define SYS_GPD_MFPL_PD7MFP_EPWM0_CH1        0x098    0x1C    0x8
+#define SYS_GPD_MFPL_PD7MFP_EPWM0_SYNC_OUT   0x098    0x1C    0x1
+#define SYS_GPD_MFPL_PD7MFP_GPIO             0x098    0x1C    0x0
+#define SYS_GPD_MFPL_PD7MFP_I2C0_SCL         0x098    0x1C    0x6
+#define SYS_GPD_MFPL_PD7MFP_I2S1_MCLK        0x098    0x1C    0x7
+#define SYS_GPD_MFPL_PD7MFP_QSPI1_MISO1      0x098    0x1C    0x5
+#define SYS_GPD_MFPL_PD7MFP_SC1_nCD          0x098    0x1C    0xA
+#define SYS_GPD_MFPL_PD7MFP_UART1_TXD        0x098    0x1C    0x2
+#define SYS_GPD_MFPL_PD7MFP_USBHL3_DP        0x098    0x1C    0x4
+/********************* Bit definition of GPD_MFPH register **********************/
+#define SYS_GPD_MFPH_PD8MFP_EBI_AD7          0x09C    0x00    0x9
+#define SYS_GPD_MFPH_PD8MFP_EPWM0_BRAKE0     0x09C    0x00    0x1
+#define SYS_GPD_MFPH_PD8MFP_EPWM0_CH2        0x09C    0x00    0x8
+#define SYS_GPD_MFPH_PD8MFP_GPIO             0x09C    0x00    0x0
+#define SYS_GPD_MFPH_PD8MFP_I2S1_LRCK        0x09C    0x00    0x7
+#define SYS_GPD_MFPH_PD8MFP_QSPI1_SS0        0x09C    0x00    0x5
+#define SYS_GPD_MFPH_PD8MFP_SC1_CLK          0x09C    0x00    0xA
+#define SYS_GPD_MFPH_PD8MFP_TM0              0x09C    0x00    0xB
+#define SYS_GPD_MFPH_PD8MFP_UART15_RXD       0x09C    0x00    0x3
+#define SYS_GPD_MFPH_PD8MFP_UART16_nCTS      0x09C    0x00    0x2
+#define SYS_GPD_MFPH_PD9MFP_EBI_AD8          0x09C    0x04    0x9
+#define SYS_GPD_MFPH_PD9MFP_EPWM0_BRAKE1     0x09C    0x04    0x1
+#define SYS_GPD_MFPH_PD9MFP_EPWM0_CH3        0x09C    0x04    0x8
+#define SYS_GPD_MFPH_PD9MFP_GPIO             0x09C    0x04    0x0
+#define SYS_GPD_MFPH_PD9MFP_I2S1_BCLK        0x09C    0x04    0x7
+#define SYS_GPD_MFPH_PD9MFP_QSPI1_CLK        0x09C    0x04    0x5
+#define SYS_GPD_MFPH_PD9MFP_SC1_DAT          0x09C    0x04    0xA
+#define SYS_GPD_MFPH_PD9MFP_TM0_EXT          0x09C    0x04    0xB
+#define SYS_GPD_MFPH_PD9MFP_UART15_TXD       0x09C    0x04    0x3
+#define SYS_GPD_MFPH_PD9MFP_UART16_nRTS      0x09C    0x04    0x2
+#define SYS_GPD_MFPH_PD10MFP_EBI_AD9         0x09C    0x08    0x9
+#define SYS_GPD_MFPH_PD10MFP_EPWM0_CH4       0x09C    0x08    0x8
+#define SYS_GPD_MFPH_PD10MFP_EPWM1_BRAKE0    0x09C    0x08    0x1
+#define SYS_GPD_MFPH_PD10MFP_GPIO            0x09C    0x08    0x0
+#define SYS_GPD_MFPH_PD10MFP_I2S1_DI         0x09C    0x08    0x7
+#define SYS_GPD_MFPH_PD10MFP_QSPI1_MOSI0     0x09C    0x08    0x5
+#define SYS_GPD_MFPH_PD10MFP_SC1_RST         0x09C    0x08    0xA
+#define SYS_GPD_MFPH_PD10MFP_TM2             0x09C    0x08    0xB
+#define SYS_GPD_MFPH_PD10MFP_UART16_RXD      0x09C    0x08    0x2
+#define SYS_GPD_MFPH_PD11MFP_EBI_AD10        0x09C    0x0C    0x9
+#define SYS_GPD_MFPH_PD11MFP_EPWM0_CH5       0x09C    0x0C    0x8
+#define SYS_GPD_MFPH_PD11MFP_EPWM1_BRAKE1    0x09C    0x0C    0x1
+#define SYS_GPD_MFPH_PD11MFP_GPIO            0x09C    0x0C    0x0
+#define SYS_GPD_MFPH_PD11MFP_I2S1_DO         0x09C    0x0C    0x7
+#define SYS_GPD_MFPH_PD11MFP_QSPI1_MISO0     0x09C    0x0C    0x5
+#define SYS_GPD_MFPH_PD11MFP_SC1_PWR         0x09C    0x0C    0xA
+#define SYS_GPD_MFPH_PD11MFP_TM2_EXT         0x09C    0x0C    0xB
+#define SYS_GPD_MFPH_PD11MFP_UART16_TXD      0x09C    0x0C    0x2
+#define SYS_GPD_MFPH_PD12MFP_EBI_AD4         0x09C    0x10    0x8
+#define SYS_GPD_MFPH_PD12MFP_EBI_nCS1        0x09C    0x10    0x7
+#define SYS_GPD_MFPH_PD12MFP_EPWM0_BRAKE0    0x09C    0x10    0x1
+#define SYS_GPD_MFPH_PD12MFP_GPIO            0x09C    0x10    0x0
+#define SYS_GPD_MFPH_PD12MFP_I2C4_SDA        0x09C    0x10    0x4
+#define SYS_GPD_MFPH_PD12MFP_I2S1_LRCK       0x09C    0x10    0xC
+#define SYS_GPD_MFPH_PD12MFP_INT1            0x09C    0x10    0xD
+#define SYS_GPD_MFPH_PD12MFP_QEI0_INDEX      0x09C    0x10    0x9
+#define SYS_GPD_MFPH_PD12MFP_TM5             0x09C    0x10    0xB
+#define SYS_GPD_MFPH_PD12MFP_TRACE_DATA0     0x09C    0x10    0x6
+#define SYS_GPD_MFPH_PD12MFP_UART10_RXD      0x09C    0x10    0x3
+#define SYS_GPD_MFPH_PD12MFP_UART11_TXD      0x09C    0x10    0x2
+#define SYS_GPD_MFPH_PD13MFP_EBI_AD5         0x09C    0x14    0x8
+#define SYS_GPD_MFPH_PD13MFP_EBI_nCS2        0x09C    0x14    0x7
+#define SYS_GPD_MFPH_PD13MFP_ECAP0_IC0       0x09C    0x14    0x9
+#define SYS_GPD_MFPH_PD13MFP_EPWM0_BRAKE1    0x09C    0x14    0x1
+#define SYS_GPD_MFPH_PD13MFP_GPIO            0x09C    0x14    0x0
+#define SYS_GPD_MFPH_PD13MFP_I2C4_SCL        0x09C    0x14    0x4
+#define SYS_GPD_MFPH_PD13MFP_I2S1_BCLK       0x09C    0x14    0xC
+#define SYS_GPD_MFPH_PD13MFP_TM5_EXT         0x09C    0x14    0xB
+#define SYS_GPD_MFPH_PD13MFP_TRACE_DATA1     0x09C    0x14    0x6
+#define SYS_GPD_MFPH_PD13MFP_UART10_TXD      0x09C    0x14    0x3
+#define SYS_GPD_MFPH_PD13MFP_UART11_RXD      0x09C    0x14    0x2
+#define SYS_GPD_MFPH_PD14MFP_CAN3_RXD        0x09C    0x18    0x3
+#define SYS_GPD_MFPH_PD14MFP_EBI_AD6         0x09C    0x18    0x8
+#define SYS_GPD_MFPH_PD14MFP_EBI_MCLK        0x09C    0x18    0x7
+#define SYS_GPD_MFPH_PD14MFP_ECAP0_IC1       0x09C    0x18    0x9
+#define SYS_GPD_MFPH_PD14MFP_EPWM0_SYNC_IN   0x09C    0x18    0x1
+#define SYS_GPD_MFPH_PD14MFP_GPIO            0x09C    0x18    0x0
+#define SYS_GPD_MFPH_PD14MFP_I2S1_DI         0x09C    0x18    0xC
+#define SYS_GPD_MFPH_PD14MFP_INT3            0x09C    0x18    0xD
+#define SYS_GPD_MFPH_PD14MFP_TM6             0x09C    0x18    0xB
+#define SYS_GPD_MFPH_PD14MFP_TRACE_DATA2     0x09C    0x18    0x6
+#define SYS_GPD_MFPH_PD14MFP_UART11_nCTS     0x09C    0x18    0x2
+#define SYS_GPD_MFPH_PD14MFP_USBHL5_DM       0x09C    0x18    0x4
+#define SYS_GPD_MFPH_PD15MFP_CAN3_TXD        0x09C    0x1C    0x3
+#define SYS_GPD_MFPH_PD15MFP_EBI_AD7         0x09C    0x1C    0x8
+#define SYS_GPD_MFPH_PD15MFP_EBI_ALE         0x09C    0x1C    0x7
+#define SYS_GPD_MFPH_PD15MFP_ECAP0_IC2       0x09C    0x1C    0x9
+#define SYS_GPD_MFPH_PD15MFP_EPWM0_SYNC_OUT  0x09C    0x1C    0x1
+#define SYS_GPD_MFPH_PD15MFP_GPIO            0x09C    0x1C    0x0
+#define SYS_GPD_MFPH_PD15MFP_I2S1_DO         0x09C    0x1C    0xC
+#define SYS_GPD_MFPH_PD15MFP_TM6_EXT         0x09C    0x1C    0xB
+#define SYS_GPD_MFPH_PD15MFP_TRACE_DATA3     0x09C    0x1C    0x6
+#define SYS_GPD_MFPH_PD15MFP_UART11_nRTS     0x09C    0x1C    0x2
+#define SYS_GPD_MFPH_PD15MFP_USBHL5_DP       0x09C    0x1C    0x4
+/********************* Bit definition of GPE_MFPL register **********************/
+#define SYS_GPE_MFPL_PE0MFP_GPIO             0x0A0    0x00    0x0
+#define SYS_GPE_MFPL_PE0MFP_RGMII0_MDC       0x0A0    0x00    0x8
+#define SYS_GPE_MFPL_PE0MFP_RMII0_MDC        0x0A0    0x00    0x9
+#define SYS_GPE_MFPL_PE0MFP_UART8_RXD        0x0A0    0x00    0x3
+#define SYS_GPE_MFPL_PE0MFP_UART9_nCTS       0x0A0    0x00    0x2
+#define SYS_GPE_MFPL_PE0MFP_VCAP1_DATA0      0x0A0    0x00    0x7
+#define SYS_GPE_MFPL_PE1MFP_GPIO             0x0A0    0x04    0x0
+#define SYS_GPE_MFPL_PE1MFP_RGMII0_MDIO      0x0A0    0x04    0x8
+#define SYS_GPE_MFPL_PE1MFP_RMII0_MDIO       0x0A0    0x04    0x9
+#define SYS_GPE_MFPL_PE1MFP_UART8_TXD        0x0A0    0x04    0x3
+#define SYS_GPE_MFPL_PE1MFP_UART9_nRTS       0x0A0    0x04    0x2
+#define SYS_GPE_MFPL_PE1MFP_VCAP1_DATA1      0x0A0    0x04    0x7
+#define SYS_GPE_MFPL_PE2MFP_GPIO             0x0A0    0x08    0x0
+#define SYS_GPE_MFPL_PE2MFP_RGMII0_TXCTL     0x0A0    0x08    0x8
+#define SYS_GPE_MFPL_PE2MFP_RMII0_TXEN       0x0A0    0x08    0x9
+#define SYS_GPE_MFPL_PE2MFP_UART9_RXD        0x0A0    0x08    0x2
+#define SYS_GPE_MFPL_PE2MFP_VCAP1_DATA2      0x0A0    0x08    0x7
+#define SYS_GPE_MFPL_PE3MFP_GPIO             0x0A0    0x0C    0x0
+#define SYS_GPE_MFPL_PE3MFP_RGMII0_TXD0      0x0A0    0x0C    0x8
+#define SYS_GPE_MFPL_PE3MFP_RMII0_TXD0       0x0A0    0x0C    0x9
+#define SYS_GPE_MFPL_PE3MFP_UART9_TXD        0x0A0    0x0C    0x2
+#define SYS_GPE_MFPL_PE3MFP_VCAP1_DATA3      0x0A0    0x0C    0x7
+#define SYS_GPE_MFPL_PE4MFP_GPIO             0x0A0    0x10    0x0
+#define SYS_GPE_MFPL_PE4MFP_RGMII0_TXD1      0x0A0    0x10    0x8
+#define SYS_GPE_MFPL_PE4MFP_RMII0_TXD1       0x0A0    0x10    0x9
+#define SYS_GPE_MFPL_PE4MFP_UART3_RXD        0x0A0    0x10    0x3
+#define SYS_GPE_MFPL_PE4MFP_UART4_nCTS       0x0A0    0x10    0x2
+#define SYS_GPE_MFPL_PE4MFP_VCAP1_DATA4      0x0A0    0x10    0x7
+#define SYS_GPE_MFPL_PE5MFP_GPIO             0x0A0    0x14    0x0
+#define SYS_GPE_MFPL_PE5MFP_RGMII0_RXCLK     0x0A0    0x14    0x8
+#define SYS_GPE_MFPL_PE5MFP_RMII0_REFCLK     0x0A0    0x14    0x9
+#define SYS_GPE_MFPL_PE5MFP_UART3_TXD        0x0A0    0x14    0x3
+#define SYS_GPE_MFPL_PE5MFP_UART4_nRTS       0x0A0    0x14    0x2
+#define SYS_GPE_MFPL_PE5MFP_VCAP1_DATA5      0x0A0    0x14    0x7
+#define SYS_GPE_MFPL_PE6MFP_GPIO             0x0A0    0x18    0x0
+#define SYS_GPE_MFPL_PE6MFP_RGMII0_RXCTL     0x0A0    0x18    0x8
+#define SYS_GPE_MFPL_PE6MFP_RMII0_CRSDV      0x0A0    0x18    0x9
+#define SYS_GPE_MFPL_PE6MFP_UART4_RXD        0x0A0    0x18    0x2
+#define SYS_GPE_MFPL_PE6MFP_VCAP1_DATA6      0x0A0    0x18    0x7
+#define SYS_GPE_MFPL_PE7MFP_GPIO             0x0A0    0x1C    0x0
+#define SYS_GPE_MFPL_PE7MFP_RGMII0_RXD0      0x0A0    0x1C    0x8
+#define SYS_GPE_MFPL_PE7MFP_RMII0_RXD0       0x0A0    0x1C    0x9
+#define SYS_GPE_MFPL_PE7MFP_UART4_TXD        0x0A0    0x1C    0x2
+#define SYS_GPE_MFPL_PE7MFP_VCAP1_DATA7      0x0A0    0x1C    0x7
+/********************* Bit definition of GPE_MFPH register **********************/
+#define SYS_GPE_MFPH_PE8MFP_GPIO             0x0A4    0x00    0x0
+#define SYS_GPE_MFPH_PE8MFP_RGMII0_RXD1      0x0A4    0x00    0x8
+#define SYS_GPE_MFPH_PE8MFP_RMII0_RXD1       0x0A4    0x00    0x9
+#define SYS_GPE_MFPH_PE8MFP_UART12_RXD       0x0A4    0x00    0x3
+#define SYS_GPE_MFPH_PE8MFP_UART13_nCTS      0x0A4    0x00    0x2
+#define SYS_GPE_MFPH_PE8MFP_VCAP1_SCLK       0x0A4    0x00    0x7
+#define SYS_GPE_MFPH_PE9MFP_GPIO             0x0A4    0x04    0x0
+#define SYS_GPE_MFPH_PE9MFP_RGMII0_RXD2      0x0A4    0x04    0x8
+#define SYS_GPE_MFPH_PE9MFP_RMII0_RXERR      0x0A4    0x04    0x9
+#define SYS_GPE_MFPH_PE9MFP_UART12_TXD       0x0A4    0x04    0x3
+#define SYS_GPE_MFPH_PE9MFP_UART13_nRTS      0x0A4    0x04    0x2
+#define SYS_GPE_MFPH_PE9MFP_VCAP1_PIXCLK     0x0A4    0x04    0x7
+#define SYS_GPE_MFPH_PE10MFP_GPIO            0x0A4    0x08    0x0
+#define SYS_GPE_MFPH_PE10MFP_RGMII0_RXD3     0x0A4    0x08    0x8
+#define SYS_GPE_MFPH_PE10MFP_SPI1_SS0        0x0A4    0x08    0x5
+#define SYS_GPE_MFPH_PE10MFP_UART14_RXD      0x0A4    0x08    0x3
+#define SYS_GPE_MFPH_PE10MFP_UART15_nCTS     0x0A4    0x08    0x2
+#define SYS_GPE_MFPH_PE10MFP_VCAP1_HSYNC     0x0A4    0x08    0x7
+#define SYS_GPE_MFPH_PE11MFP_GPIO            0x0A4    0x0C    0x0
+#define SYS_GPE_MFPH_PE11MFP_RGMII0_TXCLK    0x0A4    0x0C    0x8
+#define SYS_GPE_MFPH_PE11MFP_SPI1_CLK        0x0A4    0x0C    0x5
+#define SYS_GPE_MFPH_PE11MFP_UART14_TXD      0x0A4    0x0C    0x3
+#define SYS_GPE_MFPH_PE11MFP_UART15_nRTS     0x0A4    0x0C    0x2
+#define SYS_GPE_MFPH_PE11MFP_VCAP1_VSYNC     0x0A4    0x0C    0x7
+#define SYS_GPE_MFPH_PE12MFP_GPIO            0x0A4    0x10    0x0
+#define SYS_GPE_MFPH_PE12MFP_RGMII0_TXD2     0x0A4    0x10    0x8
+#define SYS_GPE_MFPH_PE12MFP_SPI1_MOSI       0x0A4    0x10    0x5
+#define SYS_GPE_MFPH_PE12MFP_UART15_RXD      0x0A4    0x10    0x2
+#define SYS_GPE_MFPH_PE12MFP_VCAP1_DATA8     0x0A4    0x10    0x7
+#define SYS_GPE_MFPH_PE13MFP_GPIO            0x0A4    0x14    0x0
+#define SYS_GPE_MFPH_PE13MFP_RGMII0_TXD3     0x0A4    0x14    0x8
+#define SYS_GPE_MFPH_PE13MFP_SPI1_MISO       0x0A4    0x14    0x5
+#define SYS_GPE_MFPH_PE13MFP_UART15_TXD      0x0A4    0x14    0x2
+#define SYS_GPE_MFPH_PE13MFP_VCAP1_DATA9     0x0A4    0x14    0x7
+#define SYS_GPE_MFPH_PE14MFP_GPIO            0x0A4    0x18    0x0
+#define SYS_GPE_MFPH_PE14MFP_UART0_TXD       0x0A4    0x18    0x1
+#define SYS_GPE_MFPH_PE15MFP_GPIO            0x0A4    0x1C    0x0
+#define SYS_GPE_MFPH_PE15MFP_UART0_RXD       0x0A4    0x1C    0x1
+/********************* Bit definition of GPF_MFPL register **********************/
+#define SYS_GPF_MFPL_PF0MFP_GPIO             0x0A8    0x00    0x0
+#define SYS_GPF_MFPL_PF0MFP_KPI_COL0         0x0A8    0x00    0xE
+#define SYS_GPF_MFPL_PF0MFP_RGMII0_RXD3      0x0A8    0x00    0x6
+#define SYS_GPF_MFPL_PF0MFP_RGMII1_MDC       0x0A8    0x00    0x8
+#define SYS_GPF_MFPL_PF0MFP_RMII1_MDC        0x0A8    0x00    0x9
+#define SYS_GPF_MFPL_PF0MFP_UART1_RXD        0x0A8    0x00    0x3
+#define SYS_GPF_MFPL_PF0MFP_UART2_nCTS       0x0A8    0x00    0x2
+#define SYS_GPF_MFPL_PF1MFP_GPIO             0x0A8    0x04    0x0
+#define SYS_GPF_MFPL_PF1MFP_KPI_COL1         0x0A8    0x04    0xE
+#define SYS_GPF_MFPL_PF1MFP_RGMII0_TXCLK     0x0A8    0x04    0x6
+#define SYS_GPF_MFPL_PF1MFP_RGMII1_MDIO      0x0A8    0x04    0x8
+#define SYS_GPF_MFPL_PF1MFP_RMII1_MDIO       0x0A8    0x04    0x9
+#define SYS_GPF_MFPL_PF1MFP_UART1_TXD        0x0A8    0x04    0x3
+#define SYS_GPF_MFPL_PF1MFP_UART2_nRTS       0x0A8    0x04    0x2
+#define SYS_GPF_MFPL_PF2MFP_GPIO             0x0A8    0x08    0x0
+#define SYS_GPF_MFPL_PF2MFP_KPI_COL2         0x0A8    0x08    0xE
+#define SYS_GPF_MFPL_PF2MFP_RGMII0_TXD2      0x0A8    0x08    0x6
+#define SYS_GPF_MFPL_PF2MFP_RGMII1_TXCTL     0x0A8    0x08    0x8
+#define SYS_GPF_MFPL_PF2MFP_RMII1_TXEN       0x0A8    0x08    0x9
+#define SYS_GPF_MFPL_PF2MFP_UART2_RXD        0x0A8    0x08    0x2
+#define SYS_GPF_MFPL_PF3MFP_GPIO             0x0A8    0x0C    0x0
+#define SYS_GPF_MFPL_PF3MFP_KPI_COL3         0x0A8    0x0C    0xE
+#define SYS_GPF_MFPL_PF3MFP_RGMII0_TXD3      0x0A8    0x0C    0x6
+#define SYS_GPF_MFPL_PF3MFP_RGMII1_TXD0      0x0A8    0x0C    0x8
+#define SYS_GPF_MFPL_PF3MFP_RMII1_TXD0       0x0A8    0x0C    0x9
+#define SYS_GPF_MFPL_PF3MFP_UART2_TXD        0x0A8    0x0C    0x2
+#define SYS_GPF_MFPL_PF4MFP_CAN2_RXD         0x0A8    0x10    0xD
+#define SYS_GPF_MFPL_PF4MFP_GPIO             0x0A8    0x10    0x0
+#define SYS_GPF_MFPL_PF4MFP_I2S0_LRCK        0x0A8    0x10    0x4
+#define SYS_GPF_MFPL_PF4MFP_KPI_ROW0         0x0A8    0x10    0xE
+#define SYS_GPF_MFPL_PF4MFP_RGMII1_TXD1      0x0A8    0x10    0x8
+#define SYS_GPF_MFPL_PF4MFP_RMII1_TXD1       0x0A8    0x10    0x9
+#define SYS_GPF_MFPL_PF4MFP_SPI1_SS0         0x0A8    0x10    0x5
+#define SYS_GPF_MFPL_PF4MFP_UART10_RXD       0x0A8    0x10    0x3
+#define SYS_GPF_MFPL_PF4MFP_UART11_nCTS      0x0A8    0x10    0x2
+#define SYS_GPF_MFPL_PF4MFP_USBHL0_DM        0x0A8    0x10    0xC
+#define SYS_GPF_MFPL_PF5MFP_CAN2_TXD         0x0A8    0x14    0xD
+#define SYS_GPF_MFPL_PF5MFP_GPIO             0x0A8    0x14    0x0
+#define SYS_GPF_MFPL_PF5MFP_I2S0_BCLK        0x0A8    0x14    0x4
+#define SYS_GPF_MFPL_PF5MFP_KPI_ROW1         0x0A8    0x14    0xE
+#define SYS_GPF_MFPL_PF5MFP_RGMII1_RXCLK     0x0A8    0x14    0x8
+#define SYS_GPF_MFPL_PF5MFP_RMII1_REFCLK     0x0A8    0x14    0x9
+#define SYS_GPF_MFPL_PF5MFP_SPI1_CLK         0x0A8    0x14    0x5
+#define SYS_GPF_MFPL_PF5MFP_UART10_TXD       0x0A8    0x14    0x3
+#define SYS_GPF_MFPL_PF5MFP_UART11_nRTS      0x0A8    0x14    0x2
+#define SYS_GPF_MFPL_PF5MFP_USBHL0_DP        0x0A8    0x14    0xC
+#define SYS_GPF_MFPL_PF6MFP_GPIO             0x0A8    0x18    0x0
+#define SYS_GPF_MFPL_PF6MFP_I2C4_SDA         0x0A8    0x18    0xA
+#define SYS_GPF_MFPL_PF6MFP_I2S0_DI          0x0A8    0x18    0x4
+#define SYS_GPF_MFPL_PF6MFP_KPI_ROW2         0x0A8    0x18    0xE
+#define SYS_GPF_MFPL_PF6MFP_RGMII1_RXCTL     0x0A8    0x18    0x8
+#define SYS_GPF_MFPL_PF6MFP_RMII1_CRSDV      0x0A8    0x18    0x9
+#define SYS_GPF_MFPL_PF6MFP_SC0_CLK          0x0A8    0x18    0xD
+#define SYS_GPF_MFPL_PF6MFP_SPI1_MOSI        0x0A8    0x18    0x5
+#define SYS_GPF_MFPL_PF6MFP_UART11_RXD       0x0A8    0x18    0x2
+#define SYS_GPF_MFPL_PF7MFP_GPIO             0x0A8    0x1C    0x0
+#define SYS_GPF_MFPL_PF7MFP_I2C4_SCL         0x0A8    0x1C    0xA
+#define SYS_GPF_MFPL_PF7MFP_I2S0_DO          0x0A8    0x1C    0x4
+#define SYS_GPF_MFPL_PF7MFP_KPI_ROW3         0x0A8    0x1C    0xE
+#define SYS_GPF_MFPL_PF7MFP_RGMII1_RXD0      0x0A8    0x1C    0x8
+#define SYS_GPF_MFPL_PF7MFP_RMII1_RXD0       0x0A8    0x1C    0x9
+#define SYS_GPF_MFPL_PF7MFP_SC0_DAT          0x0A8    0x1C    0xD
+#define SYS_GPF_MFPL_PF7MFP_SPI1_MISO        0x0A8    0x1C    0x5
+#define SYS_GPF_MFPL_PF7MFP_UART11_TXD       0x0A8    0x1C    0x2
+/********************* Bit definition of GPF_MFPH register **********************/
+#define SYS_GPF_MFPH_PF8MFP_GPIO             0x0AC    0x00    0x0
+#define SYS_GPF_MFPH_PF8MFP_I2C5_SDA         0x0AC    0x00    0x4
+#define SYS_GPF_MFPH_PF8MFP_KPI_COL4         0x0AC    0x00    0xE
+#define SYS_GPF_MFPH_PF8MFP_RGMII1_RXD1      0x0AC    0x00    0x8
+#define SYS_GPF_MFPH_PF8MFP_RMII1_RXD1       0x0AC    0x00    0x9
+#define SYS_GPF_MFPH_PF8MFP_SC0_RST          0x0AC    0x00    0xD
+#define SYS_GPF_MFPH_PF8MFP_SPI0_SS0         0x0AC    0x00    0x5
+#define SYS_GPF_MFPH_PF8MFP_UART13_RXD       0x0AC    0x00    0x2
+#define SYS_GPF_MFPH_PF9MFP_GPIO             0x0AC    0x04    0x0
+#define SYS_GPF_MFPH_PF9MFP_I2C5_SCL         0x0AC    0x04    0x4
+#define SYS_GPF_MFPH_PF9MFP_KPI_COL5         0x0AC    0x04    0xE
+#define SYS_GPF_MFPH_PF9MFP_RGMII1_RXD2      0x0AC    0x04    0x8
+#define SYS_GPF_MFPH_PF9MFP_RMII1_RXERR      0x0AC    0x04    0x9
+#define SYS_GPF_MFPH_PF9MFP_SC0_PWR          0x0AC    0x04    0xD
+#define SYS_GPF_MFPH_PF9MFP_SPI0_SS1         0x0AC    0x04    0x5
+#define SYS_GPF_MFPH_PF9MFP_UART13_TXD       0x0AC    0x04    0x2
+#define SYS_GPF_MFPH_PF10MFP_GPIO            0x0AC    0x08    0x0
+#define SYS_GPF_MFPH_PF10MFP_I2S0_LRCK       0x0AC    0x08    0x5
+#define SYS_GPF_MFPH_PF10MFP_KPI_COL6        0x0AC    0x08    0xE
+#define SYS_GPF_MFPH_PF10MFP_RGMII1_RXD3     0x0AC    0x08    0x8
+#define SYS_GPF_MFPH_PF10MFP_SC0_CLK         0x0AC    0x08    0x9
+#define SYS_GPF_MFPH_PF10MFP_SPI1_SS0        0x0AC    0x08    0x6
+#define SYS_GPF_MFPH_PF10MFP_UART13_nCTS     0x0AC    0x08    0x2
+#define SYS_GPF_MFPH_PF11MFP_GPIO            0x0AC    0x0C    0x0
+#define SYS_GPF_MFPH_PF11MFP_I2S0_BCLK       0x0AC    0x0C    0x5
+#define SYS_GPF_MFPH_PF11MFP_KPI_COL7        0x0AC    0x0C    0xE
+#define SYS_GPF_MFPH_PF11MFP_RGMII1_TXCLK    0x0AC    0x0C    0x8
+#define SYS_GPF_MFPH_PF11MFP_SC0_DAT         0x0AC    0x0C    0x9
+#define SYS_GPF_MFPH_PF11MFP_SPI1_CLK        0x0AC    0x0C    0x6
+#define SYS_GPF_MFPH_PF11MFP_UART13_nRTS     0x0AC    0x0C    0x2
+#define SYS_GPF_MFPH_PF12MFP_GPIO            0x0AC    0x10    0x0
+#define SYS_GPF_MFPH_PF12MFP_I2S0_DI         0x0AC    0x10    0x5
+#define SYS_GPF_MFPH_PF12MFP_KPI_ROW4        0x0AC    0x10    0xE
+#define SYS_GPF_MFPH_PF12MFP_RGMII1_TXD2     0x0AC    0x10    0x8
+#define SYS_GPF_MFPH_PF12MFP_SC0_RST         0x0AC    0x10    0x9
+#define SYS_GPF_MFPH_PF12MFP_SPI1_MOSI       0x0AC    0x10    0x6
+#define SYS_GPF_MFPH_PF13MFP_GPIO            0x0AC    0x14    0x0
+#define SYS_GPF_MFPH_PF13MFP_I2S0_DO         0x0AC    0x14    0x5
+#define SYS_GPF_MFPH_PF13MFP_KPI_ROW5        0x0AC    0x14    0xE
+#define SYS_GPF_MFPH_PF13MFP_RGMII1_TXD3     0x0AC    0x14    0x8
+#define SYS_GPF_MFPH_PF13MFP_SC0_PWR         0x0AC    0x14    0x9
+#define SYS_GPF_MFPH_PF13MFP_SPI1_MISO       0x0AC    0x14    0x6
+#define SYS_GPF_MFPH_PF14MFP_EADC0_ST        0x0AC    0x18    0x2
+#define SYS_GPF_MFPH_PF14MFP_EPWM2_BRAKE0    0x0AC    0x18    0x1
+#define SYS_GPF_MFPH_PF14MFP_GPIO            0x0AC    0x18    0x0
+#define SYS_GPF_MFPH_PF14MFP_I2S0_MCLK       0x0AC    0x18    0xF
+#define SYS_GPF_MFPH_PF14MFP_INT0            0x0AC    0x18    0xC
+#define SYS_GPF_MFPH_PF14MFP_QEI2_INDEX      0x0AC    0x18    0xE
+#define SYS_GPF_MFPH_PF14MFP_RGMII0_PPS      0x0AC    0x18    0x8
+#define SYS_GPF_MFPH_PF14MFP_RGMII1_PPS      0x0AC    0x18    0x3
+#define SYS_GPF_MFPH_PF14MFP_RMII0_PPS       0x0AC    0x18    0x9
+#define SYS_GPF_MFPH_PF14MFP_RMII1_PPS       0x0AC    0x18    0x4
+#define SYS_GPF_MFPH_PF14MFP_SPI0_I2SMCLK    0x0AC    0x18    0x5
+#define SYS_GPF_MFPH_PF14MFP_SPI1_I2SMCLK    0x0AC    0x18    0x6
+#define SYS_GPF_MFPH_PF14MFP_SPI1_SS1        0x0AC    0x18    0xD
+#define SYS_GPF_MFPH_PF14MFP_TM0             0x0AC    0x18    0xB
+#define SYS_GPF_MFPH_PF14MFP_VCAP1_SFIELD    0x0AC    0x18    0x7
+#define SYS_GPF_MFPH_PF15MFP_GPIO            0x0AC    0x1C    0x0
+#define SYS_GPF_MFPH_PF15MFP_HSUSB0_VBUSVLD  0x0AC    0x1C    0x1
+/********************* Bit definition of GPG_MFPL register **********************/
+#define SYS_GPG_MFPL_PG0MFP_CAN3_TXD         0x0B0    0x00    0x3
+#define SYS_GPG_MFPL_PG0MFP_CLKO             0x0B0    0x00    0xC
+#define SYS_GPG_MFPL_PG0MFP_EADC0_ST         0x0B0    0x00    0x6
+#define SYS_GPG_MFPL_PG0MFP_EBI_AD15         0x0B0    0x00    0x7
+#define SYS_GPG_MFPL_PG0MFP_EBI_ADR15        0x0B0    0x00    0xF
+#define SYS_GPG_MFPL_PG0MFP_EPWM0_CH0        0x0B0    0x00    0x1
+#define SYS_GPG_MFPL_PG0MFP_GPIO             0x0B0    0x00    0x0
+#define SYS_GPG_MFPL_PG0MFP_I2S1_MCLK        0x0B0    0x00    0x9
+#define SYS_GPG_MFPL_PG0MFP_INT0             0x0B0    0x00    0xD
+#define SYS_GPG_MFPL_PG0MFP_QEI0_INDEX       0x0B0    0x00    0xA
+#define SYS_GPG_MFPL_PG0MFP_SPI0_SS0         0x0B0    0x00    0x5
+#define SYS_GPG_MFPL_PG0MFP_TM1              0x0B0    0x00    0xB
+#define SYS_GPG_MFPL_PG0MFP_UART7_TXD        0x0B0    0x00    0x2
+#define SYS_GPG_MFPL_PG1MFP_CAN2_TXD         0x0B0    0x04    0x5
+#define SYS_GPG_MFPL_PG1MFP_EBI_nCS0         0x0B0    0x04    0x7
+#define SYS_GPG_MFPL_PG1MFP_EPWM0_CH3        0x0B0    0x04    0x1
+#define SYS_GPG_MFPL_PG1MFP_GPIO             0x0B0    0x04    0x0
+#define SYS_GPG_MFPL_PG1MFP_I2C4_SCL         0x0B0    0x04    0x4
+#define SYS_GPG_MFPL_PG1MFP_QEI0_B           0x0B0    0x04    0x9
+#define SYS_GPG_MFPL_PG1MFP_RGMII1_PPS       0x0B0    0x04    0xE
+#define SYS_GPG_MFPL_PG1MFP_RMII1_PPS        0x0B0    0x04    0xF
+#define SYS_GPG_MFPL_PG1MFP_TM1_EXT          0x0B0    0x04    0xB
+#define SYS_GPG_MFPL_PG1MFP_UART6_TXD        0x0B0    0x04    0x3
+#define SYS_GPG_MFPL_PG1MFP_UART9_nRTS       0x0B0    0x04    0x2
+#define SYS_GPG_MFPL_PG1MFP_USBHL0_DP        0x0B0    0x04    0x6
+#define SYS_GPG_MFPL_PG2MFP_CAN0_RXD         0x0B0    0x08    0x3
+#define SYS_GPG_MFPL_PG2MFP_EBI_ADR16        0x0B0    0x08    0x7
+#define SYS_GPG_MFPL_PG2MFP_EBI_nCS2         0x0B0    0x08    0x8
+#define SYS_GPG_MFPL_PG2MFP_EPWM0_CH4        0x0B0    0x08    0x1
+#define SYS_GPG_MFPL_PG2MFP_GPIO             0x0B0    0x08    0x0
+#define SYS_GPG_MFPL_PG2MFP_INT1             0x0B0    0x08    0xD
+#define SYS_GPG_MFPL_PG2MFP_QEI0_A           0x0B0    0x08    0xA
+#define SYS_GPG_MFPL_PG2MFP_SPI0_SS1         0x0B0    0x08    0x5
+#define SYS_GPG_MFPL_PG2MFP_TM3              0x0B0    0x08    0xB
+#define SYS_GPG_MFPL_PG2MFP_TSI_SWD_DAT      0x0B0    0x08    0x6
+#define SYS_GPG_MFPL_PG2MFP_UART9_RXD        0x0B0    0x08    0x2
+#define SYS_GPG_MFPL_PG3MFP_CAN0_TXD         0x0B0    0x0C    0x3
+#define SYS_GPG_MFPL_PG3MFP_EBI_ADR17        0x0B0    0x0C    0x7
+#define SYS_GPG_MFPL_PG3MFP_EBI_MCLK         0x0B0    0x0C    0x9
+#define SYS_GPG_MFPL_PG3MFP_EBI_nCS1         0x0B0    0x0C    0x8
+#define SYS_GPG_MFPL_PG3MFP_EPWM0_CH5        0x0B0    0x0C    0x1
+#define SYS_GPG_MFPL_PG3MFP_GPIO             0x0B0    0x0C    0x0
+#define SYS_GPG_MFPL_PG3MFP_I2S1_MCLK        0x0B0    0x0C    0xC
+#define SYS_GPG_MFPL_PG3MFP_QEI0_B           0x0B0    0x0C    0xA
+#define SYS_GPG_MFPL_PG3MFP_SPI0_I2SMCLK     0x0B0    0x0C    0x5
+#define SYS_GPG_MFPL_PG3MFP_TM3_EXT          0x0B0    0x0C    0xB
+#define SYS_GPG_MFPL_PG3MFP_TSI_SWD_CLK      0x0B0    0x0C    0x6
+#define SYS_GPG_MFPL_PG3MFP_UART9_TXD        0x0B0    0x0C    0x2
+#define SYS_GPG_MFPL_PG4MFP_EBI_ADR18        0x0B0    0x10    0x7
+#define SYS_GPG_MFPL_PG4MFP_EBI_nCS0         0x0B0    0x10    0x8
+#define SYS_GPG_MFPL_PG4MFP_ECAP1_IC2        0x0B0    0x10    0xE
+#define SYS_GPG_MFPL_PG4MFP_EPWM1_CH0        0x0B0    0x10    0x1
+#define SYS_GPG_MFPL_PG4MFP_GPIO             0x0B0    0x10    0x0
+#define SYS_GPG_MFPL_PG4MFP_I2S1_DO          0x0B0    0x10    0x9
+#define SYS_GPG_MFPL_PG4MFP_INT2             0x0B0    0x10    0xD
+#define SYS_GPG_MFPL_PG4MFP_QEI1_INDEX       0x0B0    0x10    0x6
+#define SYS_GPG_MFPL_PG4MFP_SC1_CLK          0x0B0    0x10    0xA
+#define SYS_GPG_MFPL_PG4MFP_SPI3_SS0         0x0B0    0x10    0x5
+#define SYS_GPG_MFPL_PG4MFP_TM4              0x0B0    0x10    0xB
+#define SYS_GPG_MFPL_PG4MFP_TSI_UART_RXD     0x0B0    0x10    0xC
+#define SYS_GPG_MFPL_PG4MFP_UART5_nCTS       0x0B0    0x10    0x2
+#define SYS_GPG_MFPL_PG4MFP_UART6_RXD        0x0B0    0x10    0x3
+#define SYS_GPG_MFPL_PG5MFP_EBI_ADR19        0x0B0    0x14    0x7
+#define SYS_GPG_MFPL_PG5MFP_EBI_ALE          0x0B0    0x14    0x8
+#define SYS_GPG_MFPL_PG5MFP_ECAP0_IC0        0x0B0    0x14    0x6
+#define SYS_GPG_MFPL_PG5MFP_EPWM1_CH1        0x0B0    0x14    0x1
+#define SYS_GPG_MFPL_PG5MFP_GPIO             0x0B0    0x14    0x0
+#define SYS_GPG_MFPL_PG5MFP_I2S1_DI          0x0B0    0x14    0x9
+#define SYS_GPG_MFPL_PG5MFP_SC1_DAT          0x0B0    0x14    0xA
+#define SYS_GPG_MFPL_PG5MFP_SPI3_CLK         0x0B0    0x14    0x5
+#define SYS_GPG_MFPL_PG5MFP_TM4_EXT          0x0B0    0x14    0xB
+#define SYS_GPG_MFPL_PG5MFP_TSI_UART_TXD     0x0B0    0x14    0xC
+#define SYS_GPG_MFPL_PG5MFP_UART5_nRTS       0x0B0    0x14    0x2
+#define SYS_GPG_MFPL_PG5MFP_UART6_TXD        0x0B0    0x14    0x3
+#define SYS_GPG_MFPL_PG6MFP_CAN1_RXD         0x0B0    0x18    0x3
+#define SYS_GPG_MFPL_PG6MFP_EBI_nRD          0x0B0    0x18    0x7
+#define SYS_GPG_MFPL_PG6MFP_ECAP0_IC1        0x0B0    0x18    0x6
+#define SYS_GPG_MFPL_PG6MFP_EPWM1_CH2        0x0B0    0x18    0x1
+#define SYS_GPG_MFPL_PG6MFP_GPIO             0x0B0    0x18    0x0
+#define SYS_GPG_MFPL_PG6MFP_I2S1_BCLK        0x0B0    0x18    0x9
+#define SYS_GPG_MFPL_PG6MFP_INT3             0x0B0    0x18    0xD
+#define SYS_GPG_MFPL_PG6MFP_SC1_RST          0x0B0    0x18    0xA
+#define SYS_GPG_MFPL_PG6MFP_SPI3_MOSI        0x0B0    0x18    0x5
+#define SYS_GPG_MFPL_PG6MFP_TM7              0x0B0    0x18    0xB
+#define SYS_GPG_MFPL_PG6MFP_UART5_RXD        0x0B0    0x18    0x2
+#define SYS_GPG_MFPL_PG7MFP_CAN1_TXD         0x0B0    0x1C    0x3
+#define SYS_GPG_MFPL_PG7MFP_EBI_nWR          0x0B0    0x1C    0x7
+#define SYS_GPG_MFPL_PG7MFP_ECAP0_IC2        0x0B0    0x1C    0x6
+#define SYS_GPG_MFPL_PG7MFP_EPWM1_CH3        0x0B0    0x1C    0x1
+#define SYS_GPG_MFPL_PG7MFP_GPIO             0x0B0    0x1C    0x0
+#define SYS_GPG_MFPL_PG7MFP_I2S1_LRCK        0x0B0    0x1C    0x9
+#define SYS_GPG_MFPL_PG7MFP_SC1_PWR          0x0B0    0x1C    0xA
+#define SYS_GPG_MFPL_PG7MFP_SPI3_MISO        0x0B0    0x1C    0x5
+#define SYS_GPG_MFPL_PG7MFP_TM7_EXT          0x0B0    0x1C    0xB
+#define SYS_GPG_MFPL_PG7MFP_UART5_TXD        0x0B0    0x1C    0x2
+/********************* Bit definition of GPG_MFPH register **********************/
+#define SYS_GPG_MFPH_PG8MFP_CAN3_RXD         0x0B4    0x00    0x3
+#define SYS_GPG_MFPH_PG8MFP_EBI_AD7          0x0B4    0x00    0xC
+#define SYS_GPG_MFPH_PG8MFP_EBI_nCS0         0x0B4    0x00    0xD
+#define SYS_GPG_MFPH_PG8MFP_EPWM1_CH4        0x0B4    0x00    0x1
+#define SYS_GPG_MFPH_PG8MFP_GPIO             0x0B4    0x00    0x0
+#define SYS_GPG_MFPH_PG8MFP_I2C3_SDA         0x0B4    0x00    0x7
+#define SYS_GPG_MFPH_PG8MFP_LCM_VSYNC        0x0B4    0x00    0x6
+#define SYS_GPG_MFPH_PG8MFP_SPI2_SS0         0x0B4    0x00    0x5
+#define SYS_GPG_MFPH_PG8MFP_UART12_RXD       0x0B4    0x00    0x2
+#define SYS_GPG_MFPH_PG8MFP_USBHL4_DM        0x0B4    0x00    0x4
+#define SYS_GPG_MFPH_PG9MFP_CAN3_TXD         0x0B4    0x04    0x3
+#define SYS_GPG_MFPH_PG9MFP_EBI_AD8          0x0B4    0x04    0xC
+#define SYS_GPG_MFPH_PG9MFP_EBI_nCS1         0x0B4    0x04    0xD
+#define SYS_GPG_MFPH_PG9MFP_EPWM1_CH5        0x0B4    0x04    0x1
+#define SYS_GPG_MFPH_PG9MFP_GPIO             0x0B4    0x04    0x0
+#define SYS_GPG_MFPH_PG9MFP_I2C3_SCL         0x0B4    0x04    0x7
+#define SYS_GPG_MFPH_PG9MFP_LCM_HSYNC        0x0B4    0x04    0x6
+#define SYS_GPG_MFPH_PG9MFP_SPI2_CLK         0x0B4    0x04    0x5
+#define SYS_GPG_MFPH_PG9MFP_UART12_TXD       0x0B4    0x04    0x2
+#define SYS_GPG_MFPH_PG9MFP_USBHL4_DP        0x0B4    0x04    0x4
+#define SYS_GPG_MFPH_PG10MFP_EBI_AD9         0x0B4    0x08    0xC
+#define SYS_GPG_MFPH_PG10MFP_EBI_nWRH        0x0B4    0x08    0xD
+#define SYS_GPG_MFPH_PG10MFP_GPIO            0x0B4    0x08    0x0
+#define SYS_GPG_MFPH_PG10MFP_LCM_CLK         0x0B4    0x08    0x6
+#define SYS_GPG_MFPH_PG10MFP_SPI2_MOSI       0x0B4    0x08    0x5
+#define SYS_GPG_MFPH_PG10MFP_UART12_nRTS     0x0B4    0x08    0x2
+#define SYS_GPG_MFPH_PG10MFP_UART13_TXD      0x0B4    0x08    0x3
+#define SYS_GPG_MFPH_PG11MFP_EBI_AD0         0x0B4    0x0C    0xA
+#define SYS_GPG_MFPH_PG11MFP_EBI_nCS1        0x0B4    0x0C    0x8
+#define SYS_GPG_MFPH_PG11MFP_EBI_nWRH        0x0B4    0x0C    0x7
+#define SYS_GPG_MFPH_PG11MFP_GPIO            0x0B4    0x0C    0x0
+#define SYS_GPG_MFPH_PG11MFP_I2S0_MCLK       0x0B4    0x0C    0x5
+#define SYS_GPG_MFPH_PG11MFP_JTAG_TDO        0x0B4    0x0C    0x3
+#define SYS_GPG_MFPH_PG12MFP_EBI_AD1         0x0B4    0x10    0xA
+#define SYS_GPG_MFPH_PG12MFP_EBI_nWRL        0x0B4    0x10    0x7
+#define SYS_GPG_MFPH_PG12MFP_GPIO            0x0B4    0x10    0x0
+#define SYS_GPG_MFPH_PG12MFP_I2S0_LRCK       0x0B4    0x10    0x5
+#define SYS_GPG_MFPH_PG12MFP_JTAG_TCK        0x0B4    0x10    0x3
+#define SYS_GPG_MFPH_PG12MFP_SW_CLK          0x0B4    0x10    0x3
+#define SYS_GPG_MFPH_PG13MFP_EBI_AD2         0x0B4    0x14    0xA
+#define SYS_GPG_MFPH_PG13MFP_EBI_MCLK        0x0B4    0x14    0x7
+#define SYS_GPG_MFPH_PG13MFP_GPIO            0x0B4    0x14    0x0
+#define SYS_GPG_MFPH_PG13MFP_I2S0_BCLK       0x0B4    0x14    0x5
+#define SYS_GPG_MFPH_PG13MFP_JTAG_TMS        0x0B4    0x14    0x3
+#define SYS_GPG_MFPH_PG13MFP_SW_DIO          0x0B4    0x14    0x3
+#define SYS_GPG_MFPH_PG14MFP_EBI_AD3         0x0B4    0x18    0xA
+#define SYS_GPG_MFPH_PG14MFP_EBI_ALE         0x0B4    0x18    0x7
+#define SYS_GPG_MFPH_PG14MFP_GPIO            0x0B4    0x18    0x0
+#define SYS_GPG_MFPH_PG14MFP_I2S0_DI         0x0B4    0x18    0x5
+#define SYS_GPG_MFPH_PG14MFP_JTAG_TDI        0x0B4    0x18    0x3
+#define SYS_GPG_MFPH_PG15MFP_EBI_AD4         0x0B4    0x1C    0xA
+#define SYS_GPG_MFPH_PG15MFP_EBI_nCS0        0x0B4    0x1C    0x7
+#define SYS_GPG_MFPH_PG15MFP_GPIO            0x0B4    0x1C    0x0
+#define SYS_GPG_MFPH_PG15MFP_I2S0_DO         0x0B4    0x1C    0x5
+#define SYS_GPG_MFPH_PG15MFP_JTAG_nTRST      0x0B4    0x1C    0x3
+/********************* Bit definition of GPH_MFPL register **********************/
+#define SYS_GPH_MFPL_PH0MFP_GPIO             0x0B8    0x00    0x0
+#define SYS_GPH_MFPL_PH0MFP_LCM_DATA8        0x0B8    0x00    0x6
+#define SYS_GPH_MFPL_PH0MFP_UART7_RXD        0x0B8    0x00    0x3
+#define SYS_GPH_MFPL_PH0MFP_UART8_nCTS       0x0B8    0x00    0x2
+#define SYS_GPH_MFPL_PH1MFP_GPIO             0x0B8    0x04    0x0
+#define SYS_GPH_MFPL_PH1MFP_LCM_DATA9        0x0B8    0x04    0x6
+#define SYS_GPH_MFPL_PH1MFP_UART7_TXD        0x0B8    0x04    0x3
+#define SYS_GPH_MFPL_PH1MFP_UART8_nRTS       0x0B8    0x04    0x2
+#define SYS_GPH_MFPL_PH2MFP_GPIO             0x0B8    0x08    0x0
+#define SYS_GPH_MFPL_PH2MFP_LCM_DATA10       0x0B8    0x08    0x6
+#define SYS_GPH_MFPL_PH2MFP_UART8_RXD        0x0B8    0x08    0x2
+#define SYS_GPH_MFPL_PH3MFP_GPIO             0x0B8    0x0C    0x0
+#define SYS_GPH_MFPL_PH3MFP_LCM_DATA11       0x0B8    0x0C    0x6
+#define SYS_GPH_MFPL_PH3MFP_UART8_TXD        0x0B8    0x0C    0x2
+#define SYS_GPH_MFPL_PH4MFP_GPIO             0x0B8    0x10    0x0
+#define SYS_GPH_MFPL_PH4MFP_LCM_DATA12       0x0B8    0x10    0x6
+#define SYS_GPH_MFPL_PH4MFP_UART10_nCTS      0x0B8    0x10    0x2
+#define SYS_GPH_MFPL_PH4MFP_UART9_RXD        0x0B8    0x10    0x3
+#define SYS_GPH_MFPL_PH5MFP_GPIO             0x0B8    0x14    0x0
+#define SYS_GPH_MFPL_PH5MFP_LCM_DATA13       0x0B8    0x14    0x6
+#define SYS_GPH_MFPL_PH5MFP_UART10_nRTS      0x0B8    0x14    0x2
+#define SYS_GPH_MFPL_PH5MFP_UART9_TXD        0x0B8    0x14    0x3
+#define SYS_GPH_MFPL_PH6MFP_GPIO             0x0B8    0x18    0x0
+#define SYS_GPH_MFPL_PH6MFP_LCM_DATA14       0x0B8    0x18    0x6
+#define SYS_GPH_MFPL_PH6MFP_UART10_RXD       0x0B8    0x18    0x2
+#define SYS_GPH_MFPL_PH7MFP_GPIO             0x0B8    0x1C    0x0
+#define SYS_GPH_MFPL_PH7MFP_LCM_DATA15       0x0B8    0x1C    0x6
+#define SYS_GPH_MFPL_PH7MFP_UART10_TXD       0x0B8    0x1C    0x2
+/********************* Bit definition of GPH_MFPH register **********************/
+#define SYS_GPH_MFPH_PH8MFP_GPIO             0x0BC    0x00    0x0
+#define SYS_GPH_MFPH_PH8MFP_TAMPER0          0x0BC    0x00    0x6
+#define SYS_GPH_MFPH_PH9MFP_CLK_32KOUT       0x0BC    0x04    0x4
+#define SYS_GPH_MFPH_PH9MFP_GPIO             0x0BC    0x04    0x0
+#define SYS_GPH_MFPH_PH9MFP_TAMPER1          0x0BC    0x04    0x6
+#define SYS_GPH_MFPH_PH12MFP_GPIO            0x0BC    0x10    0x0
+#define SYS_GPH_MFPH_PH12MFP_LCM_DATA20      0x0BC    0x10    0x6
+#define SYS_GPH_MFPH_PH12MFP_UART13_RXD      0x0BC    0x10    0x3
+#define SYS_GPH_MFPH_PH12MFP_UART14_nCTS     0x0BC    0x10    0x2
+#define SYS_GPH_MFPH_PH13MFP_GPIO            0x0BC    0x14    0x0
+#define SYS_GPH_MFPH_PH13MFP_LCM_DATA21      0x0BC    0x14    0x6
+#define SYS_GPH_MFPH_PH13MFP_UART13_TXD      0x0BC    0x14    0x3
+#define SYS_GPH_MFPH_PH13MFP_UART14_nRTS     0x0BC    0x14    0x2
+#define SYS_GPH_MFPH_PH14MFP_GPIO            0x0BC    0x18    0x0
+#define SYS_GPH_MFPH_PH14MFP_LCM_DATA22      0x0BC    0x18    0x6
+#define SYS_GPH_MFPH_PH14MFP_UART14_RXD      0x0BC    0x18    0x2
+#define SYS_GPH_MFPH_PH15MFP_GPIO            0x0BC    0x1C    0x0
+#define SYS_GPH_MFPH_PH15MFP_LCM_DATA23      0x0BC    0x1C    0x6
+#define SYS_GPH_MFPH_PH15MFP_UART14_TXD      0x0BC    0x1C    0x2
+/********************* Bit definition of GPI_MFPL register **********************/
+#define SYS_GPI_MFPL_PI0MFP_EBI_ADR0         0x0C0    0x00    0x8
+#define SYS_GPI_MFPL_PI0MFP_ECAP1_IC0        0x0C0    0x00    0xC
+#define SYS_GPI_MFPL_PI0MFP_EPWM0_CH0        0x0C0    0x00    0x1
+#define SYS_GPI_MFPL_PI0MFP_GPIO             0x0C0    0x00    0x0
+#define SYS_GPI_MFPL_PI0MFP_I2C2_SDA         0x0C0    0x00    0x4
+#define SYS_GPI_MFPL_PI0MFP_SC0_nCD          0x0C0    0x00    0x7
+#define SYS_GPI_MFPL_PI0MFP_SPI3_SS0         0x0C0    0x00    0x5
+#define SYS_GPI_MFPL_PI0MFP_TM0              0x0C0    0x00    0xB
+#define SYS_GPI_MFPL_PI0MFP_UART11_RXD       0x0C0    0x00    0x3
+#define SYS_GPI_MFPL_PI0MFP_UART12_nCTS      0x0C0    0x00    0x2
+#define SYS_GPI_MFPL_PI1MFP_EBI_ADR1         0x0C0    0x04    0x8
+#define SYS_GPI_MFPL_PI1MFP_ECAP1_IC1        0x0C0    0x04    0xC
+#define SYS_GPI_MFPL_PI1MFP_EPWM0_CH1        0x0C0    0x04    0x1
+#define SYS_GPI_MFPL_PI1MFP_GPIO             0x0C0    0x04    0x0
+#define SYS_GPI_MFPL_PI1MFP_I2C2_SCL         0x0C0    0x04    0x4
+#define SYS_GPI_MFPL_PI1MFP_SC0_CLK          0x0C0    0x04    0x7
+#define SYS_GPI_MFPL_PI1MFP_SPI3_CLK         0x0C0    0x04    0x5
+#define SYS_GPI_MFPL_PI1MFP_TM0_EXT          0x0C0    0x04    0xB
+#define SYS_GPI_MFPL_PI1MFP_UART11_TXD       0x0C0    0x04    0x3
+#define SYS_GPI_MFPL_PI1MFP_UART12_nRTS      0x0C0    0x04    0x2
+#define SYS_GPI_MFPL_PI2MFP_CAN0_RXD         0x0C0    0x08    0x3
+#define SYS_GPI_MFPL_PI2MFP_EBI_ADR2         0x0C0    0x08    0x8
+#define SYS_GPI_MFPL_PI2MFP_ECAP1_IC2        0x0C0    0x08    0xC
+#define SYS_GPI_MFPL_PI2MFP_EPWM0_CH2        0x0C0    0x08    0x1
+#define SYS_GPI_MFPL_PI2MFP_GPIO             0x0C0    0x08    0x0
+#define SYS_GPI_MFPL_PI2MFP_SC0_DAT          0x0C0    0x08    0x7
+#define SYS_GPI_MFPL_PI2MFP_SPI3_MOSI        0x0C0    0x08    0x5
+#define SYS_GPI_MFPL_PI2MFP_TM1              0x0C0    0x08    0xB
+#define SYS_GPI_MFPL_PI2MFP_UART12_RXD       0x0C0    0x08    0x2
+#define SYS_GPI_MFPL_PI2MFP_USBHL2_DM        0x0C0    0x08    0x4
+#define SYS_GPI_MFPL_PI3MFP_CAN0_TXD         0x0C0    0x0C    0x3
+#define SYS_GPI_MFPL_PI3MFP_EBI_ADR3         0x0C0    0x0C    0x8
+#define SYS_GPI_MFPL_PI3MFP_EPWM0_CH3        0x0C0    0x0C    0x1
+#define SYS_GPI_MFPL_PI3MFP_GPIO             0x0C0    0x0C    0x0
+#define SYS_GPI_MFPL_PI3MFP_SC0_RST          0x0C0    0x0C    0x7
+#define SYS_GPI_MFPL_PI3MFP_SPI3_MISO        0x0C0    0x0C    0x5
+#define SYS_GPI_MFPL_PI3MFP_TM1_EXT          0x0C0    0x0C    0xB
+#define SYS_GPI_MFPL_PI3MFP_UART12_TXD       0x0C0    0x0C    0x2
+#define SYS_GPI_MFPL_PI3MFP_USBHL2_DP        0x0C0    0x0C    0x4
+#define SYS_GPI_MFPL_PI4MFP_EBI_ADR4         0x0C0    0x10    0x8
+#define SYS_GPI_MFPL_PI4MFP_EPWM0_CH4        0x0C0    0x10    0x1
+#define SYS_GPI_MFPL_PI4MFP_GPIO             0x0C0    0x10    0x0
+#define SYS_GPI_MFPL_PI4MFP_I2C3_SDA         0x0C0    0x10    0x4
+#define SYS_GPI_MFPL_PI4MFP_I2S1_LRCK        0x0C0    0x10    0x6
+#define SYS_GPI_MFPL_PI4MFP_INT0             0x0C0    0x10    0xD
+#define SYS_GPI_MFPL_PI4MFP_SPI2_SS1         0x0C0    0x10    0x5
+#define SYS_GPI_MFPL_PI4MFP_UART13_RXD       0x0C0    0x10    0x3
+#define SYS_GPI_MFPL_PI4MFP_UART14_nCTS      0x0C0    0x10    0x2
+#define SYS_GPI_MFPL_PI5MFP_EBI_ADR5         0x0C0    0x14    0x8
+#define SYS_GPI_MFPL_PI5MFP_EPWM0_CH5        0x0C0    0x14    0x1
+#define SYS_GPI_MFPL_PI5MFP_GPIO             0x0C0    0x14    0x0
+#define SYS_GPI_MFPL_PI5MFP_I2C3_SCL         0x0C0    0x14    0x4
+#define SYS_GPI_MFPL_PI5MFP_I2S1_BCLK        0x0C0    0x14    0x6
+#define SYS_GPI_MFPL_PI5MFP_INT1             0x0C0    0x14    0xD
+#define SYS_GPI_MFPL_PI5MFP_UART13_TXD       0x0C0    0x14    0x3
+#define SYS_GPI_MFPL_PI5MFP_UART14_nRTS      0x0C0    0x14    0x2
+#define SYS_GPI_MFPL_PI6MFP_CAN1_RXD         0x0C0    0x18    0x3
+#define SYS_GPI_MFPL_PI6MFP_EBI_ADR6         0x0C0    0x18    0x8
+#define SYS_GPI_MFPL_PI6MFP_EPWM0_BRAKE0     0x0C0    0x18    0x1
+#define SYS_GPI_MFPL_PI6MFP_GPIO             0x0C0    0x18    0x0
+#define SYS_GPI_MFPL_PI6MFP_I2S1_DI          0x0C0    0x18    0x6
+#define SYS_GPI_MFPL_PI6MFP_INT2             0x0C0    0x18    0xD
+#define SYS_GPI_MFPL_PI6MFP_QEI1_INDEX       0x0C0    0x18    0xC
+#define SYS_GPI_MFPL_PI6MFP_UART14_RXD       0x0C0    0x18    0x2
+#define SYS_GPI_MFPL_PI6MFP_USBHL3_DM        0x0C0    0x18    0x4
+#define SYS_GPI_MFPL_PI7MFP_CAN1_TXD         0x0C0    0x1C    0x3
+#define SYS_GPI_MFPL_PI7MFP_EBI_ADR7         0x0C0    0x1C    0x8
+#define SYS_GPI_MFPL_PI7MFP_ECAP0_IC0        0x0C0    0x1C    0xC
+#define SYS_GPI_MFPL_PI7MFP_EPWM0_BRAKE1     0x0C0    0x1C    0x1
+#define SYS_GPI_MFPL_PI7MFP_GPIO             0x0C0    0x1C    0x0
+#define SYS_GPI_MFPL_PI7MFP_I2S1_DO          0x0C0    0x1C    0x6
+#define SYS_GPI_MFPL_PI7MFP_INT3             0x0C0    0x1C    0xD
+#define SYS_GPI_MFPL_PI7MFP_UART14_TXD       0x0C0    0x1C    0x2
+#define SYS_GPI_MFPL_PI7MFP_USBHL3_DP        0x0C0    0x1C    0x4
+/********************* Bit definition of GPI_MFPH register **********************/
+#define SYS_GPI_MFPH_PI8MFP_EBI_AD11         0x0C4    0x00    0xC
+#define SYS_GPI_MFPH_PI8MFP_GPIO             0x0C4    0x00    0x0
+#define SYS_GPI_MFPH_PI8MFP_LCM_DATA0        0x0C4    0x00    0x6
+#define SYS_GPI_MFPH_PI8MFP_UART3_RXD        0x0C4    0x00    0x3
+#define SYS_GPI_MFPH_PI8MFP_UART4_nCTS       0x0C4    0x00    0x2
+#define SYS_GPI_MFPH_PI9MFP_EBI_AD12         0x0C4    0x04    0xC
+#define SYS_GPI_MFPH_PI9MFP_GPIO             0x0C4    0x04    0x0
+#define SYS_GPI_MFPH_PI9MFP_LCM_DATA1        0x0C4    0x04    0x6
+#define SYS_GPI_MFPH_PI9MFP_UART3_TXD        0x0C4    0x04    0x3
+#define SYS_GPI_MFPH_PI9MFP_UART4_nRTS       0x0C4    0x04    0x2
+#define SYS_GPI_MFPH_PI10MFP_EBI_AD13        0x0C4    0x08    0xC
+#define SYS_GPI_MFPH_PI10MFP_GPIO            0x0C4    0x08    0x0
+#define SYS_GPI_MFPH_PI10MFP_LCM_DATA2       0x0C4    0x08    0x6
+#define SYS_GPI_MFPH_PI10MFP_UART4_RXD       0x0C4    0x08    0x2
+#define SYS_GPI_MFPH_PI11MFP_EBI_AD14        0x0C4    0x0C    0xC
+#define SYS_GPI_MFPH_PI11MFP_GPIO            0x0C4    0x0C    0x0
+#define SYS_GPI_MFPH_PI11MFP_LCM_DATA3       0x0C4    0x0C    0x6
+#define SYS_GPI_MFPH_PI11MFP_UART4_TXD       0x0C4    0x0C    0x2
+#define SYS_GPI_MFPH_PI12MFP_GPIO            0x0C4    0x10    0x0
+#define SYS_GPI_MFPH_PI12MFP_LCM_DATA4       0x0C4    0x10    0x6
+#define SYS_GPI_MFPH_PI12MFP_UART5_RXD       0x0C4    0x10    0x3
+#define SYS_GPI_MFPH_PI12MFP_UART6_nCTS      0x0C4    0x10    0x2
+#define SYS_GPI_MFPH_PI13MFP_GPIO            0x0C4    0x14    0x0
+#define SYS_GPI_MFPH_PI13MFP_LCM_DATA5       0x0C4    0x14    0x6
+#define SYS_GPI_MFPH_PI13MFP_UART5_TXD       0x0C4    0x14    0x3
+#define SYS_GPI_MFPH_PI13MFP_UART6_nRTS      0x0C4    0x14    0x2
+#define SYS_GPI_MFPH_PI14MFP_GPIO            0x0C4    0x18    0x0
+#define SYS_GPI_MFPH_PI14MFP_LCM_DATA6       0x0C4    0x18    0x6
+#define SYS_GPI_MFPH_PI14MFP_UART6_RXD       0x0C4    0x18    0x2
+#define SYS_GPI_MFPH_PI15MFP_GPIO            0x0C4    0x1C    0x0
+#define SYS_GPI_MFPH_PI15MFP_LCM_DATA7       0x0C4    0x1C    0x6
+#define SYS_GPI_MFPH_PI15MFP_UART6_TXD       0x0C4    0x1C    0x2
+/********************* Bit definition of GPJ_MFPL register **********************/
+#define SYS_GPJ_MFPL_PJ0MFP_EBI_AD11         0x0C8    0x00    0x9
+#define SYS_GPJ_MFPL_PJ0MFP_EBI_AD7          0x0C8    0x00    0xC
+#define SYS_GPJ_MFPL_PJ0MFP_EBI_ADR16        0x0C8    0x00    0xA
+#define SYS_GPJ_MFPL_PJ0MFP_EBI_nCS0         0x0C8    0x00    0xB
+#define SYS_GPJ_MFPL_PJ0MFP_eMMC1_DAT4       0x0C8    0x00    0x6
+#define SYS_GPJ_MFPL_PJ0MFP_EPWM1_BRAKE0     0x0C8    0x00    0x1
+#define SYS_GPJ_MFPL_PJ0MFP_GPIO             0x0C8    0x00    0x0
+#define SYS_GPJ_MFPL_PJ0MFP_I2C2_SDA         0x0C8    0x00    0x4
+#define SYS_GPJ_MFPL_PJ0MFP_I2S0_LRCK        0x0C8    0x00    0x7
+#define SYS_GPJ_MFPL_PJ0MFP_SC0_CLK          0x0C8    0x00    0x8
+#define SYS_GPJ_MFPL_PJ0MFP_SPI2_SS0         0x0C8    0x00    0x5
+#define SYS_GPJ_MFPL_PJ0MFP_UART7_RXD        0x0C8    0x00    0x3
+#define SYS_GPJ_MFPL_PJ0MFP_UART8_nCTS       0x0C8    0x00    0x2
+#define SYS_GPJ_MFPL_PJ1MFP_EBI_AD12         0x0C8    0x04    0x9
+#define SYS_GPJ_MFPL_PJ1MFP_EBI_AD8          0x0C8    0x04    0xC
+#define SYS_GPJ_MFPL_PJ1MFP_EBI_ADR17        0x0C8    0x04    0xA
+#define SYS_GPJ_MFPL_PJ1MFP_EBI_nCS1         0x0C8    0x04    0xB
+#define SYS_GPJ_MFPL_PJ1MFP_eMMC1_DAT5       0x0C8    0x04    0x6
+#define SYS_GPJ_MFPL_PJ1MFP_EPWM1_BRAKE1     0x0C8    0x04    0x1
+#define SYS_GPJ_MFPL_PJ1MFP_GPIO             0x0C8    0x04    0x0
+#define SYS_GPJ_MFPL_PJ1MFP_I2C2_SCL         0x0C8    0x04    0x4
+#define SYS_GPJ_MFPL_PJ1MFP_I2S0_BCLK        0x0C8    0x04    0x7
+#define SYS_GPJ_MFPL_PJ1MFP_SC0_DAT          0x0C8    0x04    0x8
+#define SYS_GPJ_MFPL_PJ1MFP_SPI2_CLK         0x0C8    0x04    0x5
+#define SYS_GPJ_MFPL_PJ1MFP_UART7_TXD        0x0C8    0x04    0x3
+#define SYS_GPJ_MFPL_PJ1MFP_UART8_nRTS       0x0C8    0x04    0x2
+#define SYS_GPJ_MFPL_PJ2MFP_CAN1_RXD         0x0C8    0x08    0x3
+#define SYS_GPJ_MFPL_PJ2MFP_EBI_AD13         0x0C8    0x08    0x9
+#define SYS_GPJ_MFPL_PJ2MFP_EBI_AD9          0x0C8    0x08    0xC
+#define SYS_GPJ_MFPL_PJ2MFP_EBI_ADR18        0x0C8    0x08    0xA
+#define SYS_GPJ_MFPL_PJ2MFP_EBI_nWRH         0x0C8    0x08    0xB
+#define SYS_GPJ_MFPL_PJ2MFP_eMMC1_DAT6       0x0C8    0x08    0x6
+#define SYS_GPJ_MFPL_PJ2MFP_EPWM1_CH4        0x0C8    0x08    0x1
+#define SYS_GPJ_MFPL_PJ2MFP_GPIO             0x0C8    0x08    0x0
+#define SYS_GPJ_MFPL_PJ2MFP_I2S0_DI          0x0C8    0x08    0x7
+#define SYS_GPJ_MFPL_PJ2MFP_SC0_RST          0x0C8    0x08    0x8
+#define SYS_GPJ_MFPL_PJ2MFP_SPI2_MOSI        0x0C8    0x08    0x5
+#define SYS_GPJ_MFPL_PJ2MFP_UART8_RXD        0x0C8    0x08    0x2
+#define SYS_GPJ_MFPL_PJ2MFP_USBHL5_DM        0x0C8    0x08    0x4
+#define SYS_GPJ_MFPL_PJ3MFP_CAN1_TXD         0x0C8    0x0C    0x3
+#define SYS_GPJ_MFPL_PJ3MFP_EBI_AD10         0x0C8    0x0C    0xC
+#define SYS_GPJ_MFPL_PJ3MFP_EBI_AD14         0x0C8    0x0C    0x9
+#define SYS_GPJ_MFPL_PJ3MFP_EBI_ADR19        0x0C8    0x0C    0xA
+#define SYS_GPJ_MFPL_PJ3MFP_EBI_nWRL         0x0C8    0x0C    0xB
+#define SYS_GPJ_MFPL_PJ3MFP_eMMC1_DAT7       0x0C8    0x0C    0x6
+#define SYS_GPJ_MFPL_PJ3MFP_EPWM1_CH5        0x0C8    0x0C    0x1
+#define SYS_GPJ_MFPL_PJ3MFP_GPIO             0x0C8    0x0C    0x0
+#define SYS_GPJ_MFPL_PJ3MFP_I2S0_DO          0x0C8    0x0C    0x7
+#define SYS_GPJ_MFPL_PJ3MFP_SC0_PWR          0x0C8    0x0C    0x8
+#define SYS_GPJ_MFPL_PJ3MFP_SPI2_MISO        0x0C8    0x0C    0x5
+#define SYS_GPJ_MFPL_PJ3MFP_UART8_TXD        0x0C8    0x0C    0x2
+#define SYS_GPJ_MFPL_PJ3MFP_USBHL5_DP        0x0C8    0x0C    0x4
+#define SYS_GPJ_MFPL_PJ4MFP_GPIO             0x0C8    0x10    0x0
+#define SYS_GPJ_MFPL_PJ4MFP_I2C3_SDA         0x0C8    0x10    0x4
+#define SYS_GPJ_MFPL_PJ4MFP_SD1_WP           0x0C8    0x10    0x6
+#define SYS_GPJ_MFPL_PJ5MFP_GPIO             0x0C8    0x14    0x0
+#define SYS_GPJ_MFPL_PJ5MFP_I2C3_SCL         0x0C8    0x14    0x4
+#define SYS_GPJ_MFPL_PJ5MFP_SD1_nCD          0x0C8    0x14    0x6
+#define SYS_GPJ_MFPL_PJ6MFP_CAN3_RXD         0x0C8    0x18    0x3
+#define SYS_GPJ_MFPL_PJ6MFP_eMMC1_CMD        0x0C8    0x18    0x6
+#define SYS_GPJ_MFPL_PJ6MFP_GPIO             0x0C8    0x18    0x0
+#define SYS_GPJ_MFPL_PJ6MFP_SD1_CMD          0x0C8    0x18    0x6
+#define SYS_GPJ_MFPL_PJ6MFP_USBHL0_DM        0x0C8    0x18    0x4
+#define SYS_GPJ_MFPL_PJ7MFP_CAN3_TXD         0x0C8    0x1C    0x3
+#define SYS_GPJ_MFPL_PJ7MFP_eMMC1_CLK        0x0C8    0x1C    0x6
+#define SYS_GPJ_MFPL_PJ7MFP_GPIO             0x0C8    0x1C    0x0
+#define SYS_GPJ_MFPL_PJ7MFP_SD1_CLK          0x0C8    0x1C    0x6
+#define SYS_GPJ_MFPL_PJ7MFP_USBHL0_DP        0x0C8    0x1C    0x4
+/********************* Bit definition of GPJ_MFPH register **********************/
+#define SYS_GPJ_MFPH_PJ8MFP_eMMC1_DAT0       0x0CC    0x00    0x6
+#define SYS_GPJ_MFPH_PJ8MFP_GPIO             0x0CC    0x00    0x0
+#define SYS_GPJ_MFPH_PJ8MFP_I2C4_SDA         0x0CC    0x00    0x4
+#define SYS_GPJ_MFPH_PJ8MFP_SD1_DAT0         0x0CC    0x00    0x6
+#define SYS_GPJ_MFPH_PJ9MFP_eMMC1_DAT1       0x0CC    0x04    0x6
+#define SYS_GPJ_MFPH_PJ9MFP_GPIO             0x0CC    0x04    0x0
+#define SYS_GPJ_MFPH_PJ9MFP_I2C4_SCL         0x0CC    0x04    0x4
+#define SYS_GPJ_MFPH_PJ9MFP_SD1_DAT1         0x0CC    0x04    0x6
+#define SYS_GPJ_MFPH_PJ10MFP_CAN0_RXD        0x0CC    0x08    0x3
+#define SYS_GPJ_MFPH_PJ10MFP_eMMC1_DAT2      0x0CC    0x08    0x6
+#define SYS_GPJ_MFPH_PJ10MFP_GPIO            0x0CC    0x08    0x0
+#define SYS_GPJ_MFPH_PJ10MFP_SD1_DAT2        0x0CC    0x08    0x6
+#define SYS_GPJ_MFPH_PJ10MFP_USBHL1_DM       0x0CC    0x08    0x4
+#define SYS_GPJ_MFPH_PJ11MFP_CAN0_TXD        0x0CC    0x0C    0x3
+#define SYS_GPJ_MFPH_PJ11MFP_eMMC1_DAT3      0x0CC    0x0C    0x6
+#define SYS_GPJ_MFPH_PJ11MFP_GPIO            0x0CC    0x0C    0x0
+#define SYS_GPJ_MFPH_PJ11MFP_SD1_DAT3        0x0CC    0x0C    0x6
+#define SYS_GPJ_MFPH_PJ11MFP_USBHL1_DP       0x0CC    0x0C    0x4
+#define SYS_GPJ_MFPH_PJ12MFP_EBI_ADR12       0x0CC    0x10    0x8
+#define SYS_GPJ_MFPH_PJ12MFP_EPWM1_CH2       0x0CC    0x10    0x1
+#define SYS_GPJ_MFPH_PJ12MFP_GPIO            0x0CC    0x10    0x0
+#define SYS_GPJ_MFPH_PJ12MFP_I2C5_SDA        0x0CC    0x10    0x4
+#define SYS_GPJ_MFPH_PJ12MFP_QEI0_INDEX      0x0CC    0x10    0xC
+#define SYS_GPJ_MFPH_PJ12MFP_SC1_CLK         0x0CC    0x10    0x7
+#define SYS_GPJ_MFPH_PJ12MFP_SPI3_SS0        0x0CC    0x10    0x5
+#define SYS_GPJ_MFPH_PJ12MFP_TM2             0x0CC    0x10    0xB
+#define SYS_GPJ_MFPH_PJ12MFP_UART1_RXD       0x0CC    0x10    0x3
+#define SYS_GPJ_MFPH_PJ12MFP_UART2_nCTS      0x0CC    0x10    0x2
+#define SYS_GPJ_MFPH_PJ13MFP_EBI_ADR13       0x0CC    0x14    0x8
+#define SYS_GPJ_MFPH_PJ13MFP_EPWM1_CH3       0x0CC    0x14    0x1
+#define SYS_GPJ_MFPH_PJ13MFP_GPIO            0x0CC    0x14    0x0
+#define SYS_GPJ_MFPH_PJ13MFP_I2C5_SCL        0x0CC    0x14    0x4
+#define SYS_GPJ_MFPH_PJ13MFP_SC1_DAT         0x0CC    0x14    0x7
+#define SYS_GPJ_MFPH_PJ13MFP_SPI3_MOSI       0x0CC    0x14    0x5
+#define SYS_GPJ_MFPH_PJ13MFP_TM2_EXT         0x0CC    0x14    0xB
+#define SYS_GPJ_MFPH_PJ13MFP_UART1_TXD       0x0CC    0x14    0x3
+#define SYS_GPJ_MFPH_PJ13MFP_UART2_nRTS      0x0CC    0x14    0x2
+#define SYS_GPJ_MFPH_PJ14MFP_CAN3_RXD        0x0CC    0x18    0x3
+#define SYS_GPJ_MFPH_PJ14MFP_EBI_ADR14       0x0CC    0x18    0x8
+#define SYS_GPJ_MFPH_PJ14MFP_EPWM1_CH4       0x0CC    0x18    0x1
+#define SYS_GPJ_MFPH_PJ14MFP_GPIO            0x0CC    0x18    0x0
+#define SYS_GPJ_MFPH_PJ14MFP_SC1_RST         0x0CC    0x18    0x7
+#define SYS_GPJ_MFPH_PJ14MFP_SPI3_MISO       0x0CC    0x18    0x5
+#define SYS_GPJ_MFPH_PJ14MFP_TM3             0x0CC    0x18    0xB
+#define SYS_GPJ_MFPH_PJ14MFP_UART2_RXD       0x0CC    0x18    0x2
+#define SYS_GPJ_MFPH_PJ14MFP_USBHL5_DM       0x0CC    0x18    0x4
+#define SYS_GPJ_MFPH_PJ15MFP_CAN3_TXD        0x0CC    0x1C    0x3
+#define SYS_GPJ_MFPH_PJ15MFP_EADC0_ST        0x0CC    0x1C    0x6
+#define SYS_GPJ_MFPH_PJ15MFP_EBI_ADR15       0x0CC    0x1C    0x8
+#define SYS_GPJ_MFPH_PJ15MFP_EPWM1_CH5       0x0CC    0x1C    0x1
+#define SYS_GPJ_MFPH_PJ15MFP_GPIO            0x0CC    0x1C    0x0
+#define SYS_GPJ_MFPH_PJ15MFP_INT1            0x0CC    0x1C    0xD
+#define SYS_GPJ_MFPH_PJ15MFP_SC1_PWR         0x0CC    0x1C    0x7
+#define SYS_GPJ_MFPH_PJ15MFP_SPI3_CLK        0x0CC    0x1C    0x5
+#define SYS_GPJ_MFPH_PJ15MFP_TM3_EXT         0x0CC    0x1C    0xB
+#define SYS_GPJ_MFPH_PJ15MFP_UART2_TXD       0x0CC    0x1C    0x2
+#define SYS_GPJ_MFPH_PJ15MFP_USBHL5_DP       0x0CC    0x1C    0x4
+/********************* Bit definition of GPK_MFPL register **********************/
+#define SYS_GPK_MFPL_PK0MFP_EBI_ADR8         0x0D0    0x00    0x8
+#define SYS_GPK_MFPL_PK0MFP_ECAP0_IC1        0x0D0    0x00    0xC
+#define SYS_GPK_MFPL_PK0MFP_EPWM0_SYNC_IN    0x0D0    0x00    0x1
+#define SYS_GPK_MFPL_PK0MFP_GPIO             0x0D0    0x00    0x0
+#define SYS_GPK_MFPL_PK0MFP_I2C4_SDA         0x0D0    0x00    0x4
+#define SYS_GPK_MFPL_PK0MFP_I2S1_MCLK        0x0D0    0x00    0x6
+#define SYS_GPK_MFPL_PK0MFP_TM7              0x0D0    0x00    0xB
+#define SYS_GPK_MFPL_PK0MFP_UART15_RXD       0x0D0    0x00    0x3
+#define SYS_GPK_MFPL_PK0MFP_UART16_nCTS      0x0D0    0x00    0x2
+#define SYS_GPK_MFPL_PK1MFP_EADC0_ST         0x0D0    0x04    0x6
+#define SYS_GPK_MFPL_PK1MFP_EBI_ADR9         0x0D0    0x04    0x8
+#define SYS_GPK_MFPL_PK1MFP_ECAP0_IC2        0x0D0    0x04    0xC
+#define SYS_GPK_MFPL_PK1MFP_EPWM0_SYNC_OUT   0x0D0    0x04    0x1
+#define SYS_GPK_MFPL_PK1MFP_GPIO             0x0D0    0x04    0x0
+#define SYS_GPK_MFPL_PK1MFP_I2C4_SCL         0x0D0    0x04    0x4
+#define SYS_GPK_MFPL_PK1MFP_TM7_EXT          0x0D0    0x04    0xB
+#define SYS_GPK_MFPL_PK1MFP_UART15_TXD       0x0D0    0x04    0x3
+#define SYS_GPK_MFPL_PK1MFP_UART16_nRTS      0x0D0    0x04    0x2
+#define SYS_GPK_MFPL_PK2MFP_CAN2_RXD         0x0D0    0x08    0x3
+#define SYS_GPK_MFPL_PK2MFP_EBI_ADR10        0x0D0    0x08    0x8
+#define SYS_GPK_MFPL_PK2MFP_EPWM1_CH0        0x0D0    0x08    0x1
+#define SYS_GPK_MFPL_PK2MFP_GPIO             0x0D0    0x08    0x0
+#define SYS_GPK_MFPL_PK2MFP_QEI0_A           0x0D0    0x08    0xC
+#define SYS_GPK_MFPL_PK2MFP_SC0_PWR          0x0D0    0x08    0x7
+#define SYS_GPK_MFPL_PK2MFP_SPI3_I2SMCLK     0x0D0    0x08    0x5
+#define SYS_GPK_MFPL_PK2MFP_UART16_RXD       0x0D0    0x08    0x2
+#define SYS_GPK_MFPL_PK2MFP_USBHL4_DM        0x0D0    0x08    0x4
+#define SYS_GPK_MFPL_PK3MFP_CAN2_TXD         0x0D0    0x0C    0x3
+#define SYS_GPK_MFPL_PK3MFP_EBI_ADR11        0x0D0    0x0C    0x8
+#define SYS_GPK_MFPL_PK3MFP_EPWM1_CH1        0x0D0    0x0C    0x1
+#define SYS_GPK_MFPL_PK3MFP_GPIO             0x0D0    0x0C    0x0
+#define SYS_GPK_MFPL_PK3MFP_QEI0_B           0x0D0    0x0C    0xC
+#define SYS_GPK_MFPL_PK3MFP_SC1_nCD          0x0D0    0x0C    0x7
+#define SYS_GPK_MFPL_PK3MFP_SPI3_SS1         0x0D0    0x0C    0x5
+#define SYS_GPK_MFPL_PK3MFP_UART16_TXD       0x0D0    0x0C    0x2
+#define SYS_GPK_MFPL_PK3MFP_USBHL4_DP        0x0D0    0x0C    0x4
+#define SYS_GPK_MFPL_PK4MFP_EBI_AD10         0x0D0    0x10    0xC
+#define SYS_GPK_MFPL_PK4MFP_EBI_nWRL         0x0D0    0x10    0xD
+#define SYS_GPK_MFPL_PK4MFP_GPIO             0x0D0    0x10    0x0
+#define SYS_GPK_MFPL_PK4MFP_LCM_DEN          0x0D0    0x10    0x6
+#define SYS_GPK_MFPL_PK4MFP_SPI2_MISO        0x0D0    0x10    0x5
+#define SYS_GPK_MFPL_PK4MFP_UART12_nCTS      0x0D0    0x10    0x2
+#define SYS_GPK_MFPL_PK4MFP_UART13_RXD       0x0D0    0x10    0x3
+#define SYS_GPK_MFPL_PK5MFP_EADC0_ST         0x0D0    0x14    0x9
+#define SYS_GPK_MFPL_PK5MFP_EPWM1_CH1        0x0D0    0x14    0x1
+#define SYS_GPK_MFPL_PK5MFP_GPIO             0x0D0    0x14    0x0
+#define SYS_GPK_MFPL_PK5MFP_I2C4_SCL         0x0D0    0x14    0x4
+#define SYS_GPK_MFPL_PK5MFP_I2S1_DI          0x0D0    0x14    0x7
+#define SYS_GPK_MFPL_PK5MFP_INT1             0x0D0    0x14    0xD
+#define SYS_GPK_MFPL_PK5MFP_SC0_DAT          0x0D0    0x14    0x8
+#define SYS_GPK_MFPL_PK5MFP_SPI2_CLK         0x0D0    0x14    0x5
+#define SYS_GPK_MFPL_PK5MFP_TM8_EXT          0x0D0    0x14    0xB
+#define SYS_GPK_MFPL_PK5MFP_UART12_nRTS      0x0D0    0x14    0x2
+#define SYS_GPK_MFPL_PK5MFP_UART13_TXD       0x0D0    0x14    0x3
+#define SYS_GPK_MFPL_PK6MFP_CAN0_RXD         0x0D0    0x18    0x3
+#define SYS_GPK_MFPL_PK6MFP_EPWM1_CH2        0x0D0    0x18    0x1
+#define SYS_GPK_MFPL_PK6MFP_GPIO             0x0D0    0x18    0x0
+#define SYS_GPK_MFPL_PK6MFP_I2S1_BCLK        0x0D0    0x18    0x7
+#define SYS_GPK_MFPL_PK6MFP_INT2             0x0D0    0x18    0xD
+#define SYS_GPK_MFPL_PK6MFP_SC0_RST          0x0D0    0x18    0x8
+#define SYS_GPK_MFPL_PK6MFP_SPI2_MOSI        0x0D0    0x18    0x5
+#define SYS_GPK_MFPL_PK6MFP_TM6              0x0D0    0x18    0xB
+#define SYS_GPK_MFPL_PK6MFP_UART12_RXD       0x0D0    0x18    0x2
+#define SYS_GPK_MFPL_PK6MFP_USBHL4_DM        0x0D0    0x18    0x4
+#define SYS_GPK_MFPL_PK7MFP_CAN0_TXD         0x0D0    0x1C    0x3
+#define SYS_GPK_MFPL_PK7MFP_CLKO             0x0D0    0x1C    0x9
+#define SYS_GPK_MFPL_PK7MFP_EPWM1_CH3        0x0D0    0x1C    0x1
+#define SYS_GPK_MFPL_PK7MFP_GPIO             0x0D0    0x1C    0x0
+#define SYS_GPK_MFPL_PK7MFP_I2S1_LRCK        0x0D0    0x1C    0x7
+#define SYS_GPK_MFPL_PK7MFP_INT3             0x0D0    0x1C    0xD
+#define SYS_GPK_MFPL_PK7MFP_SC0_PWR          0x0D0    0x1C    0x8
+#define SYS_GPK_MFPL_PK7MFP_SPI2_MISO        0x0D0    0x1C    0x5
+#define SYS_GPK_MFPL_PK7MFP_TM6_EXT          0x0D0    0x1C    0xB
+#define SYS_GPK_MFPL_PK7MFP_UART12_TXD       0x0D0    0x1C    0x2
+#define SYS_GPK_MFPL_PK7MFP_USBHL4_DP        0x0D0    0x1C    0x4
+/********************* Bit definition of GPK_MFPH register **********************/
+#define SYS_GPK_MFPH_PK8MFP_EADC0_ST         0x0D4    0x00    0x7
+#define SYS_GPK_MFPH_PK8MFP_EBI_AD15         0x0D4    0x00    0x8
+#define SYS_GPK_MFPH_PK8MFP_EBI_ADR15        0x0D4    0x00    0xA
+#define SYS_GPK_MFPH_PK8MFP_EBI_MCLK         0x0D4    0x00    0x9
+#define SYS_GPK_MFPH_PK8MFP_EPWM1_CH0        0x0D4    0x00    0x1
+#define SYS_GPK_MFPH_PK8MFP_GPIO             0x0D4    0x00    0x0
+#define SYS_GPK_MFPH_PK8MFP_I2C3_SDA         0x0D4    0x00    0x4
+#define SYS_GPK_MFPH_PK8MFP_QEI1_INDEX       0x0D4    0x00    0xC
+#define SYS_GPK_MFPH_PK8MFP_SPI3_CLK         0x0D4    0x00    0x5
+#define SYS_GPK_MFPH_PK8MFP_TM8              0x0D4    0x00    0xB
+#define SYS_GPK_MFPH_PK9MFP_EBI_AD0          0x0D4    0x04    0x8
+#define SYS_GPK_MFPH_PK9MFP_EBI_ADR0         0x0D4    0x04    0xA
+#define SYS_GPK_MFPH_PK9MFP_GPIO             0x0D4    0x04    0x0
+#define SYS_GPK_MFPH_PK9MFP_I2C3_SCL         0x0D4    0x04    0x4
+#define SYS_GPK_MFPH_PK9MFP_VCAP0_SCLK       0x0D4    0x04    0x6
+#define SYS_GPK_MFPH_PK10MFP_CAN1_RXD        0x0D4    0x08    0x3
+#define SYS_GPK_MFPH_PK10MFP_EBI_AD1         0x0D4    0x08    0x8
+#define SYS_GPK_MFPH_PK10MFP_EBI_ADR1        0x0D4    0x08    0xA
+#define SYS_GPK_MFPH_PK10MFP_GPIO            0x0D4    0x08    0x0
+#define SYS_GPK_MFPH_PK10MFP_USBHL3_DM       0x0D4    0x08    0x4
+#define SYS_GPK_MFPH_PK10MFP_VCAP0_PIXCLK    0x0D4    0x08    0x6
+#define SYS_GPK_MFPH_PK11MFP_CAN1_TXD        0x0D4    0x0C    0x3
+#define SYS_GPK_MFPH_PK11MFP_EBI_AD2         0x0D4    0x0C    0x8
+#define SYS_GPK_MFPH_PK11MFP_EBI_ADR2        0x0D4    0x0C    0xA
+#define SYS_GPK_MFPH_PK11MFP_GPIO            0x0D4    0x0C    0x0
+#define SYS_GPK_MFPH_PK11MFP_USBHL3_DP       0x0D4    0x0C    0x4
+#define SYS_GPK_MFPH_PK11MFP_VCAP0_HSYNC     0x0D4    0x0C    0x6
+#define SYS_GPK_MFPH_PK12MFP_EPWM2_CH0       0x0D4    0x10    0x1
+#define SYS_GPK_MFPH_PK12MFP_GPIO            0x0D4    0x10    0x0
+#define SYS_GPK_MFPH_PK12MFP_I2C4_SDA        0x0D4    0x10    0x4
+#define SYS_GPK_MFPH_PK12MFP_I2S0_LRCK       0x0D4    0x10    0x5
+#define SYS_GPK_MFPH_PK12MFP_INT2            0x0D4    0x10    0xD
+#define SYS_GPK_MFPH_PK12MFP_SC0_CLK         0x0D4    0x10    0x8
+#define SYS_GPK_MFPH_PK12MFP_SPI1_SS0        0x0D4    0x10    0x6
+#define SYS_GPK_MFPH_PK12MFP_TM10            0x0D4    0x10    0xB
+#define SYS_GPK_MFPH_PK12MFP_UART1_nCTS      0x0D4    0x10    0x2
+#define SYS_GPK_MFPH_PK12MFP_UART13_RXD      0x0D4    0x10    0x3
+#define SYS_GPK_MFPH_PK13MFP_EPWM2_CH1       0x0D4    0x14    0x1
+#define SYS_GPK_MFPH_PK13MFP_GPIO            0x0D4    0x14    0x0
+#define SYS_GPK_MFPH_PK13MFP_I2C4_SCL        0x0D4    0x14    0x4
+#define SYS_GPK_MFPH_PK13MFP_I2S0_BCLK       0x0D4    0x14    0x5
+#define SYS_GPK_MFPH_PK13MFP_SC0_DAT         0x0D4    0x14    0x8
+#define SYS_GPK_MFPH_PK13MFP_SPI1_CLK        0x0D4    0x14    0x6
+#define SYS_GPK_MFPH_PK13MFP_TM10_EXT        0x0D4    0x14    0xB
+#define SYS_GPK_MFPH_PK13MFP_UART1_nRTS      0x0D4    0x14    0x2
+#define SYS_GPK_MFPH_PK13MFP_UART13_TXD      0x0D4    0x14    0x3
+#define SYS_GPK_MFPH_PK14MFP_CAN3_RXD        0x0D4    0x18    0x3
+#define SYS_GPK_MFPH_PK14MFP_EPWM2_CH2       0x0D4    0x18    0x1
+#define SYS_GPK_MFPH_PK14MFP_GPIO            0x0D4    0x18    0x0
+#define SYS_GPK_MFPH_PK14MFP_I2C5_SDA        0x0D4    0x18    0xA
+#define SYS_GPK_MFPH_PK14MFP_I2S0_DI         0x0D4    0x18    0x5
+#define SYS_GPK_MFPH_PK14MFP_INT3            0x0D4    0x18    0xD
+#define SYS_GPK_MFPH_PK14MFP_SC0_RST         0x0D4    0x18    0x8
+#define SYS_GPK_MFPH_PK14MFP_SPI1_MOSI       0x0D4    0x18    0x6
+#define SYS_GPK_MFPH_PK14MFP_TM11            0x0D4    0x18    0xB
+#define SYS_GPK_MFPH_PK14MFP_UART1_RXD       0x0D4    0x18    0x2
+#define SYS_GPK_MFPH_PK14MFP_USBHL4_DM       0x0D4    0x18    0x4
+#define SYS_GPK_MFPH_PK15MFP_CAN3_TXD        0x0D4    0x1C    0x3
+#define SYS_GPK_MFPH_PK15MFP_EPWM2_CH3       0x0D4    0x1C    0x1
+#define SYS_GPK_MFPH_PK15MFP_GPIO            0x0D4    0x1C    0x0
+#define SYS_GPK_MFPH_PK15MFP_I2C5_SCL        0x0D4    0x1C    0xA
+#define SYS_GPK_MFPH_PK15MFP_I2S0_DO         0x0D4    0x1C    0x5
+#define SYS_GPK_MFPH_PK15MFP_SC0_PWR         0x0D4    0x1C    0x8
+#define SYS_GPK_MFPH_PK15MFP_SPI1_MISO       0x0D4    0x1C    0x6
+#define SYS_GPK_MFPH_PK15MFP_TM11_EXT        0x0D4    0x1C    0xB
+#define SYS_GPK_MFPH_PK15MFP_UART1_TXD       0x0D4    0x1C    0x2
+#define SYS_GPK_MFPH_PK15MFP_USBHL4_DP       0x0D4    0x1C    0x4
+/********************* Bit definition of GPL_MFPL register **********************/
+#define SYS_GPL_MFPL_PL0MFP_EBI_AD11         0x0D8    0x00    0x8
+#define SYS_GPL_MFPL_PL0MFP_EPWM1_CH0        0x0D8    0x00    0x1
+#define SYS_GPL_MFPL_PL0MFP_GPIO             0x0D8    0x00    0x0
+#define SYS_GPL_MFPL_PL0MFP_I2C3_SDA         0x0D8    0x00    0x4
+#define SYS_GPL_MFPL_PL0MFP_I2S0_LRCK        0x0D8    0x00    0x7
+#define SYS_GPL_MFPL_PL0MFP_QEI1_A           0x0D8    0x00    0xC
+#define SYS_GPL_MFPL_PL0MFP_QSPI1_MOSI1      0x0D8    0x00    0x6
+#define SYS_GPL_MFPL_PL0MFP_SC1_CLK          0x0D8    0x00    0x9
+#define SYS_GPL_MFPL_PL0MFP_SPI2_MOSI        0x0D8    0x00    0x5
+#define SYS_GPL_MFPL_PL0MFP_TM5              0x0D8    0x00    0xB
+#define SYS_GPL_MFPL_PL0MFP_UART10_RXD       0x0D8    0x00    0x3
+#define SYS_GPL_MFPL_PL0MFP_UART11_nCTS      0x0D8    0x00    0x2
+#define SYS_GPL_MFPL_PL1MFP_EBI_AD12         0x0D8    0x04    0x8
+#define SYS_GPL_MFPL_PL1MFP_EPWM1_CH1        0x0D8    0x04    0x1
+#define SYS_GPL_MFPL_PL1MFP_GPIO             0x0D8    0x04    0x0
+#define SYS_GPL_MFPL_PL1MFP_I2C3_SCL         0x0D8    0x04    0x4
+#define SYS_GPL_MFPL_PL1MFP_I2S0_BCLK        0x0D8    0x04    0x7
+#define SYS_GPL_MFPL_PL1MFP_QEI1_B           0x0D8    0x04    0xC
+#define SYS_GPL_MFPL_PL1MFP_QSPI1_MISO1      0x0D8    0x04    0x6
+#define SYS_GPL_MFPL_PL1MFP_SC1_DAT          0x0D8    0x04    0x9
+#define SYS_GPL_MFPL_PL1MFP_SPI2_MISO        0x0D8    0x04    0x5
+#define SYS_GPL_MFPL_PL1MFP_TM5_EXT          0x0D8    0x04    0xB
+#define SYS_GPL_MFPL_PL1MFP_UART10_TXD       0x0D8    0x04    0x3
+#define SYS_GPL_MFPL_PL1MFP_UART11_nRTS      0x0D8    0x04    0x2
+#define SYS_GPL_MFPL_PL2MFP_CAN3_RXD         0x0D8    0x08    0x3
+#define SYS_GPL_MFPL_PL2MFP_EBI_AD13         0x0D8    0x08    0x8
+#define SYS_GPL_MFPL_PL2MFP_EPWM1_CH2        0x0D8    0x08    0x1
+#define SYS_GPL_MFPL_PL2MFP_GPIO             0x0D8    0x08    0x0
+#define SYS_GPL_MFPL_PL2MFP_I2S0_DI          0x0D8    0x08    0x7
+#define SYS_GPL_MFPL_PL2MFP_QEI1_INDEX       0x0D8    0x08    0xC
+#define SYS_GPL_MFPL_PL2MFP_QSPI1_SS1        0x0D8    0x08    0x6
+#define SYS_GPL_MFPL_PL2MFP_SC1_RST          0x0D8    0x08    0x9
+#define SYS_GPL_MFPL_PL2MFP_SPI2_SS0         0x0D8    0x08    0x5
+#define SYS_GPL_MFPL_PL2MFP_TM7              0x0D8    0x08    0xB
+#define SYS_GPL_MFPL_PL2MFP_UART11_RXD       0x0D8    0x08    0x2
+#define SYS_GPL_MFPL_PL2MFP_USBHL4_DM        0x0D8    0x08    0x4
+#define SYS_GPL_MFPL_PL3MFP_CAN3_TXD         0x0D8    0x0C    0x3
+#define SYS_GPL_MFPL_PL3MFP_EBI_AD14         0x0D8    0x0C    0x8
+#define SYS_GPL_MFPL_PL3MFP_ECAP0_IC0        0x0D8    0x0C    0xC
+#define SYS_GPL_MFPL_PL3MFP_EPWM1_CH3        0x0D8    0x0C    0x1
+#define SYS_GPL_MFPL_PL3MFP_GPIO             0x0D8    0x0C    0x0
+#define SYS_GPL_MFPL_PL3MFP_I2S0_DO          0x0D8    0x0C    0x7
+#define SYS_GPL_MFPL_PL3MFP_QSPI1_CLK        0x0D8    0x0C    0x6
+#define SYS_GPL_MFPL_PL3MFP_SC1_PWR          0x0D8    0x0C    0x9
+#define SYS_GPL_MFPL_PL3MFP_SPI2_CLK         0x0D8    0x0C    0x5
+#define SYS_GPL_MFPL_PL3MFP_TM7_EXT          0x0D8    0x0C    0xB
+#define SYS_GPL_MFPL_PL3MFP_UART11_TXD       0x0D8    0x0C    0x2
+#define SYS_GPL_MFPL_PL3MFP_USBHL4_DP        0x0D8    0x0C    0x4
+#define SYS_GPL_MFPL_PL4MFP_EBI_nRD          0x0D8    0x10    0x8
+#define SYS_GPL_MFPL_PL4MFP_ECAP0_IC1        0x0D8    0x10    0xC
+#define SYS_GPL_MFPL_PL4MFP_EPWM1_CH4        0x0D8    0x10    0x1
+#define SYS_GPL_MFPL_PL4MFP_GPIO             0x0D8    0x10    0x0
+#define SYS_GPL_MFPL_PL4MFP_I2C4_SDA         0x0D8    0x10    0x4
+#define SYS_GPL_MFPL_PL4MFP_I2S0_MCLK        0x0D8    0x10    0x7
+#define SYS_GPL_MFPL_PL4MFP_QSPI1_MOSI0      0x0D8    0x10    0x6
+#define SYS_GPL_MFPL_PL4MFP_SC1_nCD          0x0D8    0x10    0x9
+#define SYS_GPL_MFPL_PL4MFP_SPI3_MOSI        0x0D8    0x10    0x5
+#define SYS_GPL_MFPL_PL4MFP_TM9              0x0D8    0x10    0xB
+#define SYS_GPL_MFPL_PL4MFP_UART1_RXD        0x0D8    0x10    0x3
+#define SYS_GPL_MFPL_PL4MFP_UART2_nCTS       0x0D8    0x10    0x2
+#define SYS_GPL_MFPL_PL5MFP_EBI_nWR          0x0D8    0x14    0x8
+#define SYS_GPL_MFPL_PL5MFP_ECAP0_IC2        0x0D8    0x14    0xC
+#define SYS_GPL_MFPL_PL5MFP_EPWM1_CH5        0x0D8    0x14    0x1
+#define SYS_GPL_MFPL_PL5MFP_GPIO             0x0D8    0x14    0x0
+#define SYS_GPL_MFPL_PL5MFP_I2C4_SCL         0x0D8    0x14    0x4
+#define SYS_GPL_MFPL_PL5MFP_I2S1_MCLK        0x0D8    0x14    0x7
+#define SYS_GPL_MFPL_PL5MFP_QSPI1_MISO0      0x0D8    0x14    0x6
+#define SYS_GPL_MFPL_PL5MFP_SC0_nCD          0x0D8    0x14    0x9
+#define SYS_GPL_MFPL_PL5MFP_SPI3_MISO        0x0D8    0x14    0x5
+#define SYS_GPL_MFPL_PL5MFP_TM9_EXT          0x0D8    0x14    0xB
+#define SYS_GPL_MFPL_PL5MFP_UART1_TXD        0x0D8    0x14    0x3
+#define SYS_GPL_MFPL_PL5MFP_UART2_nRTS       0x0D8    0x14    0x2
+#define SYS_GPL_MFPL_PL6MFP_CAN0_RXD         0x0D8    0x18    0x3
+#define SYS_GPL_MFPL_PL6MFP_EBI_AD5          0x0D8    0x18    0x8
+#define SYS_GPL_MFPL_PL6MFP_ECAP1_IC0        0x0D8    0x18    0xC
+#define SYS_GPL_MFPL_PL6MFP_EPWM0_CH0        0x0D8    0x18    0x1
+#define SYS_GPL_MFPL_PL6MFP_GPIO             0x0D8    0x18    0x0
+#define SYS_GPL_MFPL_PL6MFP_INT0             0x0D8    0x18    0xD
+#define SYS_GPL_MFPL_PL6MFP_QSPI1_MOSI1      0x0D8    0x18    0x6
+#define SYS_GPL_MFPL_PL6MFP_TM3              0x0D8    0x18    0xB
+#define SYS_GPL_MFPL_PL6MFP_TRACE_CLK        0x0D8    0x18    0x7
+#define SYS_GPL_MFPL_PL6MFP_UART2_RXD        0x0D8    0x18    0x2
+#define SYS_GPL_MFPL_PL6MFP_USBHL5_DM        0x0D8    0x18    0x4
+#define SYS_GPL_MFPL_PL7MFP_CAN0_TXD         0x0D8    0x1C    0x3
+#define SYS_GPL_MFPL_PL7MFP_EBI_AD6          0x0D8    0x1C    0x8
+#define SYS_GPL_MFPL_PL7MFP_ECAP1_IC1        0x0D8    0x1C    0xC
+#define SYS_GPL_MFPL_PL7MFP_EPWM0_CH1        0x0D8    0x1C    0x1
+#define SYS_GPL_MFPL_PL7MFP_GPIO             0x0D8    0x1C    0x0
+#define SYS_GPL_MFPL_PL7MFP_INT1             0x0D8    0x1C    0xD
+#define SYS_GPL_MFPL_PL7MFP_QSPI1_MISO1      0x0D8    0x1C    0x6
+#define SYS_GPL_MFPL_PL7MFP_TM3_EXT          0x0D8    0x1C    0xB
+#define SYS_GPL_MFPL_PL7MFP_UART2_TXD        0x0D8    0x1C    0x2
+#define SYS_GPL_MFPL_PL7MFP_USBHL5_DP        0x0D8    0x1C    0x4
+/********************* Bit definition of GPL_MFPH register **********************/
+#define SYS_GPL_MFPH_PL8MFP_EBI_AD7          0x0DC    0x00    0x8
+#define SYS_GPL_MFPH_PL8MFP_ECAP1_IC2        0x0DC    0x00    0xC
+#define SYS_GPL_MFPH_PL8MFP_EPWM0_CH2        0x0DC    0x00    0x1
+#define SYS_GPL_MFPH_PL8MFP_EPWM0_CH4        0x0DC    0x00    0x6
+#define SYS_GPL_MFPH_PL8MFP_GPIO             0x0DC    0x00    0x0
+#define SYS_GPL_MFPH_PL8MFP_I2C5_SDA         0x0DC    0x00    0x4
+#define SYS_GPL_MFPH_PL8MFP_I2S1_LRCK        0x0DC    0x00    0x7
+#define SYS_GPL_MFPH_PL8MFP_INT2             0x0DC    0x00    0xD
+#define SYS_GPL_MFPH_PL8MFP_SC0_CLK          0x0DC    0x00    0x9
+#define SYS_GPL_MFPH_PL8MFP_SPI3_SS0         0x0DC    0x00    0x5
+#define SYS_GPL_MFPH_PL8MFP_TM4              0x0DC    0x00    0xB
+#define SYS_GPL_MFPH_PL8MFP_UART13_RXD       0x0DC    0x00    0x3
+#define SYS_GPL_MFPH_PL8MFP_UART14_nCTS      0x0DC    0x00    0x2
+#define SYS_GPL_MFPH_PL9MFP_EBI_AD8          0x0DC    0x04    0x8
+#define SYS_GPL_MFPH_PL9MFP_EPWM0_CH3        0x0DC    0x04    0x1
+#define SYS_GPL_MFPH_PL9MFP_EPWM1_CH4        0x0DC    0x04    0x6
+#define SYS_GPL_MFPH_PL9MFP_GPIO             0x0DC    0x04    0x0
+#define SYS_GPL_MFPH_PL9MFP_I2C5_SCL         0x0DC    0x04    0x4
+#define SYS_GPL_MFPH_PL9MFP_I2S1_BCLK        0x0DC    0x04    0x7
+#define SYS_GPL_MFPH_PL9MFP_INT3             0x0DC    0x04    0xD
+#define SYS_GPL_MFPH_PL9MFP_QEI0_A           0x0DC    0x04    0xC
+#define SYS_GPL_MFPH_PL9MFP_SC0_DAT          0x0DC    0x04    0x9
+#define SYS_GPL_MFPH_PL9MFP_SPI3_CLK         0x0DC    0x04    0x5
+#define SYS_GPL_MFPH_PL9MFP_TM4_EXT          0x0DC    0x04    0xB
+#define SYS_GPL_MFPH_PL9MFP_UART13_TXD       0x0DC    0x04    0x3
+#define SYS_GPL_MFPH_PL9MFP_UART14_nRTS      0x0DC    0x04    0x2
+#define SYS_GPL_MFPH_PL10MFP_CAN3_RXD        0x0DC    0x08    0x3
+#define SYS_GPL_MFPH_PL10MFP_EBI_AD9         0x0DC    0x08    0x8
+#define SYS_GPL_MFPH_PL10MFP_EBI_nWRH        0x0DC    0x08    0xB
+#define SYS_GPL_MFPH_PL10MFP_EPWM0_CH4       0x0DC    0x08    0x1
+#define SYS_GPL_MFPH_PL10MFP_EPWM0_CH5       0x0DC    0x08    0x6
+#define SYS_GPL_MFPH_PL10MFP_GPIO            0x0DC    0x08    0x0
+#define SYS_GPL_MFPH_PL10MFP_I2S1_DI         0x0DC    0x08    0x7
+#define SYS_GPL_MFPH_PL10MFP_QEI0_B          0x0DC    0x08    0xC
+#define SYS_GPL_MFPH_PL10MFP_SC0_RST         0x0DC    0x08    0x9
+#define SYS_GPL_MFPH_PL10MFP_SPI3_MOSI       0x0DC    0x08    0x5
+#define SYS_GPL_MFPH_PL10MFP_UART14_RXD      0x0DC    0x08    0x2
+#define SYS_GPL_MFPH_PL10MFP_USBHL2_DM       0x0DC    0x08    0x4
+#define SYS_GPL_MFPH_PL11MFP_CAN3_TXD        0x0DC    0x0C    0x3
+#define SYS_GPL_MFPH_PL11MFP_EBI_AD10        0x0DC    0x0C    0x8
+#define SYS_GPL_MFPH_PL11MFP_EBI_nWRL        0x0DC    0x0C    0xB
+#define SYS_GPL_MFPH_PL11MFP_EPWM0_CH5       0x0DC    0x0C    0x1
+#define SYS_GPL_MFPH_PL11MFP_EPWM1_CH5       0x0DC    0x0C    0x6
+#define SYS_GPL_MFPH_PL11MFP_GPIO            0x0DC    0x0C    0x0
+#define SYS_GPL_MFPH_PL11MFP_I2S1_DO         0x0DC    0x0C    0x7
+#define SYS_GPL_MFPH_PL11MFP_QEI0_INDEX      0x0DC    0x0C    0xC
+#define SYS_GPL_MFPH_PL11MFP_SC0_PWR         0x0DC    0x0C    0x9
+#define SYS_GPL_MFPH_PL11MFP_SPI3_MISO       0x0DC    0x0C    0x5
+#define SYS_GPL_MFPH_PL11MFP_UART14_TXD      0x0DC    0x0C    0x2
+#define SYS_GPL_MFPH_PL11MFP_USBHL2_DP       0x0DC    0x0C    0x4
+#define SYS_GPL_MFPH_PL12MFP_EBI_AD0         0x0DC    0x10    0x8
+#define SYS_GPL_MFPH_PL12MFP_EBI_AD11        0x0DC    0x10    0xD
+#define SYS_GPL_MFPH_PL12MFP_ECAP1_IC0       0x0DC    0x10    0x3
+#define SYS_GPL_MFPH_PL12MFP_EPWM0_CH2       0x0DC    0x10    0xC
+#define SYS_GPL_MFPH_PL12MFP_EPWM0_SYNC_IN   0x0DC    0x10    0x1
+#define SYS_GPL_MFPH_PL12MFP_GPIO            0x0DC    0x10    0x0
+#define SYS_GPL_MFPH_PL12MFP_HSUSBH_PWREN    0x0DC    0x10    0x9
+#define SYS_GPL_MFPH_PL12MFP_I2C2_SDA        0x0DC    0x10    0xA
+#define SYS_GPL_MFPH_PL12MFP_I2S1_LRCK       0x0DC    0x10    0x6
+#define SYS_GPL_MFPH_PL12MFP_RGMII0_PPS      0x0DC    0x10    0xE
+#define SYS_GPL_MFPH_PL12MFP_RMII0_PPS       0x0DC    0x10    0xF
+#define SYS_GPL_MFPH_PL12MFP_SC1_CLK         0x0DC    0x10    0x7
+#define SYS_GPL_MFPH_PL12MFP_SPI0_SS0        0x0DC    0x10    0x5
+#define SYS_GPL_MFPH_PL12MFP_TM0             0x0DC    0x10    0xB
+#define SYS_GPL_MFPH_PL12MFP_UART14_RXD      0x0DC    0x10    0x4
+#define SYS_GPL_MFPH_PL12MFP_UART7_nCTS      0x0DC    0x10    0x2
+#define SYS_GPL_MFPH_PL13MFP_EBI_AD1         0x0DC    0x14    0x8
+#define SYS_GPL_MFPH_PL13MFP_EBI_AD12        0x0DC    0x14    0xD
+#define SYS_GPL_MFPH_PL13MFP_ECAP1_IC1       0x0DC    0x14    0x3
+#define SYS_GPL_MFPH_PL13MFP_EPWM0_CH3       0x0DC    0x14    0xC
+#define SYS_GPL_MFPH_PL13MFP_EPWM0_SYNC_OUT  0x0DC    0x14    0x1
+#define SYS_GPL_MFPH_PL13MFP_GPIO            0x0DC    0x14    0x0
+#define SYS_GPL_MFPH_PL13MFP_HSUSBH_OVC      0x0DC    0x14    0x9
+#define SYS_GPL_MFPH_PL13MFP_I2C2_SCL        0x0DC    0x14    0xA
+#define SYS_GPL_MFPH_PL13MFP_I2S1_BCLK       0x0DC    0x14    0x6
+#define SYS_GPL_MFPH_PL13MFP_RGMII1_PPS      0x0DC    0x14    0xE
+#define SYS_GPL_MFPH_PL13MFP_RMII1_PPS       0x0DC    0x14    0xF
+#define SYS_GPL_MFPH_PL13MFP_SC1_DAT         0x0DC    0x14    0x7
+#define SYS_GPL_MFPH_PL13MFP_SPI0_CLK        0x0DC    0x14    0x5
+#define SYS_GPL_MFPH_PL13MFP_TM0_EXT         0x0DC    0x14    0xB
+#define SYS_GPL_MFPH_PL13MFP_UART14_TXD      0x0DC    0x14    0x4
+#define SYS_GPL_MFPH_PL13MFP_UART7_nRTS      0x0DC    0x14    0x2
+#define SYS_GPL_MFPH_PL14MFP_CAN1_RXD        0x0DC    0x18    0x4
+#define SYS_GPL_MFPH_PL14MFP_EBI_AD13        0x0DC    0x18    0xD
+#define SYS_GPL_MFPH_PL14MFP_EBI_AD2         0x0DC    0x18    0x8
+#define SYS_GPL_MFPH_PL14MFP_EPWM0_CH2       0x0DC    0x18    0x1
+#define SYS_GPL_MFPH_PL14MFP_GPIO            0x0DC    0x18    0x0
+#define SYS_GPL_MFPH_PL14MFP_I2S1_DI         0x0DC    0x18    0x6
+#define SYS_GPL_MFPH_PL14MFP_INT0            0x0DC    0x18    0xC
+#define SYS_GPL_MFPH_PL14MFP_SC1_RST         0x0DC    0x18    0x7
+#define SYS_GPL_MFPH_PL14MFP_SPI0_MOSI       0x0DC    0x18    0x5
+#define SYS_GPL_MFPH_PL14MFP_TM2             0x0DC    0x18    0xB
+#define SYS_GPL_MFPH_PL14MFP_UART7_RXD       0x0DC    0x18    0x2
+#define SYS_GPL_MFPH_PL15MFP_CAN1_TXD        0x0DC    0x1C    0x4
+#define SYS_GPL_MFPH_PL15MFP_EBI_AD14        0x0DC    0x1C    0xD
+#define SYS_GPL_MFPH_PL15MFP_EBI_AD3         0x0DC    0x1C    0x8
+#define SYS_GPL_MFPH_PL15MFP_EPWM0_CH1       0x0DC    0x1C    0x1
+#define SYS_GPL_MFPH_PL15MFP_GPIO            0x0DC    0x1C    0x0
+#define SYS_GPL_MFPH_PL15MFP_I2S1_DO         0x0DC    0x1C    0x6
+#define SYS_GPL_MFPH_PL15MFP_INT2            0x0DC    0x1C    0xC
+#define SYS_GPL_MFPH_PL15MFP_SC1_PWR         0x0DC    0x1C    0x7
+#define SYS_GPL_MFPH_PL15MFP_SPI0_MISO       0x0DC    0x1C    0x5
+#define SYS_GPL_MFPH_PL15MFP_TM2_EXT         0x0DC    0x1C    0xB
+#define SYS_GPL_MFPH_PL15MFP_TRACE_CLK       0x0DC    0x1C    0x3
+#define SYS_GPL_MFPH_PL15MFP_UART7_TXD       0x0DC    0x1C    0x2
+/********************* Bit definition of GPM_MFPL register **********************/
+#define SYS_GPM_MFPL_PM0MFP_EBI_AD3          0x0E0    0x00    0x8
+#define SYS_GPM_MFPL_PM0MFP_EBI_ADR3         0x0E0    0x00    0xA
+#define SYS_GPM_MFPL_PM0MFP_GPIO             0x0E0    0x00    0x0
+#define SYS_GPM_MFPL_PM0MFP_I2C4_SDA         0x0E0    0x00    0x4
+#define SYS_GPM_MFPL_PM0MFP_VCAP0_VSYNC      0x0E0    0x00    0x6
+#define SYS_GPM_MFPL_PM1MFP_EBI_AD4          0x0E0    0x04    0x8
+#define SYS_GPM_MFPL_PM1MFP_EBI_ADR4         0x0E0    0x04    0xA
+#define SYS_GPM_MFPL_PM1MFP_GPIO             0x0E0    0x04    0x0
+#define SYS_GPM_MFPL_PM1MFP_I2C4_SCL         0x0E0    0x04    0x4
+#define SYS_GPM_MFPL_PM1MFP_SPI3_I2SMCLK     0x0E0    0x04    0x5
+#define SYS_GPM_MFPL_PM1MFP_VCAP0_SFIELD     0x0E0    0x04    0x6
+#define SYS_GPM_MFPL_PM2MFP_CAN3_RXD         0x0E0    0x08    0x3
+#define SYS_GPM_MFPL_PM2MFP_EBI_AD5          0x0E0    0x08    0x8
+#define SYS_GPM_MFPL_PM2MFP_EBI_ADR5         0x0E0    0x08    0xA
+#define SYS_GPM_MFPL_PM2MFP_GPIO             0x0E0    0x08    0x0
+#define SYS_GPM_MFPL_PM2MFP_USBHL0_DM        0x0E0    0x08    0x4
+#define SYS_GPM_MFPL_PM2MFP_VCAP0_DATA0      0x0E0    0x08    0x6
+#define SYS_GPM_MFPL_PM3MFP_CAN3_TXD         0x0E0    0x0C    0x3
+#define SYS_GPM_MFPL_PM3MFP_EBI_AD6          0x0E0    0x0C    0x8
+#define SYS_GPM_MFPL_PM3MFP_EBI_ADR6         0x0E0    0x0C    0xA
+#define SYS_GPM_MFPL_PM3MFP_GPIO             0x0E0    0x0C    0x0
+#define SYS_GPM_MFPL_PM3MFP_USBHL0_DP        0x0E0    0x0C    0x4
+#define SYS_GPM_MFPL_PM3MFP_VCAP0_DATA1      0x0E0    0x0C    0x6
+#define SYS_GPM_MFPL_PM4MFP_EBI_AD7          0x0E0    0x10    0x8
+#define SYS_GPM_MFPL_PM4MFP_EBI_ADR7         0x0E0    0x10    0xA
+#define SYS_GPM_MFPL_PM4MFP_GPIO             0x0E0    0x10    0x0
+#define SYS_GPM_MFPL_PM4MFP_I2C5_SDA         0x0E0    0x10    0x4
+#define SYS_GPM_MFPL_PM4MFP_VCAP0_DATA2      0x0E0    0x10    0x6
+#define SYS_GPM_MFPL_PM5MFP_EBI_AD8          0x0E0    0x14    0x8
+#define SYS_GPM_MFPL_PM5MFP_EBI_ADR8         0x0E0    0x14    0xA
+#define SYS_GPM_MFPL_PM5MFP_GPIO             0x0E0    0x14    0x0
+#define SYS_GPM_MFPL_PM5MFP_I2C5_SCL         0x0E0    0x14    0x4
+#define SYS_GPM_MFPL_PM5MFP_VCAP0_DATA3      0x0E0    0x14    0x6
+#define SYS_GPM_MFPL_PM6MFP_CAN0_RXD         0x0E0    0x18    0x3
+#define SYS_GPM_MFPL_PM6MFP_EBI_AD9          0x0E0    0x18    0x8
+#define SYS_GPM_MFPL_PM6MFP_EBI_ADR9         0x0E0    0x18    0xA
+#define SYS_GPM_MFPL_PM6MFP_GPIO             0x0E0    0x18    0x0
+#define SYS_GPM_MFPL_PM6MFP_USBHL1_DM        0x0E0    0x18    0x4
+#define SYS_GPM_MFPL_PM6MFP_VCAP0_DATA4      0x0E0    0x18    0x6
+#define SYS_GPM_MFPL_PM7MFP_CAN0_TXD         0x0E0    0x1C    0x3
+#define SYS_GPM_MFPL_PM7MFP_EBI_AD10         0x0E0    0x1C    0x8
+#define SYS_GPM_MFPL_PM7MFP_EBI_ADR10        0x0E0    0x1C    0xA
+#define SYS_GPM_MFPL_PM7MFP_GPIO             0x0E0    0x1C    0x0
+#define SYS_GPM_MFPL_PM7MFP_USBHL1_DP        0x0E0    0x1C    0x4
+#define SYS_GPM_MFPL_PM7MFP_VCAP0_DATA5      0x0E0    0x1C    0x6
+/********************* Bit definition of GPM_MFPH register **********************/
+#define SYS_GPM_MFPH_PM8MFP_EBI_AD11         0x0E4    0x00    0x8
+#define SYS_GPM_MFPH_PM8MFP_EBI_ADR11        0x0E4    0x00    0xA
+#define SYS_GPM_MFPH_PM8MFP_GPIO             0x0E4    0x00    0x0
+#define SYS_GPM_MFPH_PM8MFP_I2C0_SDA         0x0E4    0x00    0x4
+#define SYS_GPM_MFPH_PM8MFP_VCAP0_DATA6      0x0E4    0x00    0x6
+#define SYS_GPM_MFPH_PM9MFP_EBI_AD12         0x0E4    0x04    0x8
+#define SYS_GPM_MFPH_PM9MFP_EBI_ADR12        0x0E4    0x04    0xA
+#define SYS_GPM_MFPH_PM9MFP_GPIO             0x0E4    0x04    0x0
+#define SYS_GPM_MFPH_PM9MFP_I2C0_SCL         0x0E4    0x04    0x4
+#define SYS_GPM_MFPH_PM9MFP_VCAP0_DATA7      0x0E4    0x04    0x6
+#define SYS_GPM_MFPH_PM10MFP_CAN2_RXD        0x0E4    0x08    0x3
+#define SYS_GPM_MFPH_PM10MFP_EBI_AD13        0x0E4    0x08    0x8
+#define SYS_GPM_MFPH_PM10MFP_EBI_ADR13       0x0E4    0x08    0xA
+#define SYS_GPM_MFPH_PM10MFP_EPWM1_CH2       0x0E4    0x08    0x1
+#define SYS_GPM_MFPH_PM10MFP_GPIO            0x0E4    0x08    0x0
+#define SYS_GPM_MFPH_PM10MFP_SPI2_I2SMCLK    0x0E4    0x08    0x7
+#define SYS_GPM_MFPH_PM10MFP_SPI3_SS0        0x0E4    0x08    0x5
+#define SYS_GPM_MFPH_PM10MFP_USBHL4_DM       0x0E4    0x08    0x4
+#define SYS_GPM_MFPH_PM10MFP_VCAP0_DATA8     0x0E4    0x08    0x6
+#define SYS_GPM_MFPH_PM11MFP_CAN2_TXD        0x0E4    0x0C    0x3
+#define SYS_GPM_MFPH_PM11MFP_EBI_AD14        0x0E4    0x0C    0x8
+#define SYS_GPM_MFPH_PM11MFP_EBI_ADR14       0x0E4    0x0C    0xA
+#define SYS_GPM_MFPH_PM11MFP_EPWM1_CH3       0x0E4    0x0C    0x1
+#define SYS_GPM_MFPH_PM11MFP_GPIO            0x0E4    0x0C    0x0
+#define SYS_GPM_MFPH_PM11MFP_SPI2_SS1        0x0E4    0x0C    0x7
+#define SYS_GPM_MFPH_PM11MFP_SPI3_SS1        0x0E4    0x0C    0x5
+#define SYS_GPM_MFPH_PM11MFP_USBHL4_DP       0x0E4    0x0C    0x4
+#define SYS_GPM_MFPH_PM11MFP_VCAP0_DATA9     0x0E4    0x0C    0x6
+#define SYS_GPM_MFPH_PM12MFP_EBI_AD8         0x0E4    0x10    0x8
+#define SYS_GPM_MFPH_PM12MFP_EPWM1_CH4       0x0E4    0x10    0x1
+#define SYS_GPM_MFPH_PM12MFP_GPIO            0x0E4    0x10    0x0
+#define SYS_GPM_MFPH_PM12MFP_I2C2_SDA        0x0E4    0x10    0x5
+#define SYS_GPM_MFPH_PM12MFP_I2S1_MCLK       0x0E4    0x10    0x9
+#define SYS_GPM_MFPH_PM12MFP_SC1_nCD         0x0E4    0x10    0x7
+#define SYS_GPM_MFPH_PM12MFP_TM8             0x0E4    0x10    0xB
+#define SYS_GPM_MFPH_PM12MFP_TRACE_DATA0     0x0E4    0x10    0x3
+#define SYS_GPM_MFPH_PM12MFP_UART10_nCTS     0x0E4    0x10    0x2
+#define SYS_GPM_MFPH_PM12MFP_UART11_RXD      0x0E4    0x10    0x4
+#define SYS_GPM_MFPH_PM13MFP_EBI_AD9         0x0E4    0x14    0x8
+#define SYS_GPM_MFPH_PM13MFP_ECAP1_IC0       0x0E4    0x14    0x9
+#define SYS_GPM_MFPH_PM13MFP_EPWM1_CH5       0x0E4    0x14    0x1
+#define SYS_GPM_MFPH_PM13MFP_GPIO            0x0E4    0x14    0x0
+#define SYS_GPM_MFPH_PM13MFP_I2C2_SCL        0x0E4    0x14    0x5
+#define SYS_GPM_MFPH_PM13MFP_TM8_EXT         0x0E4    0x14    0xB
+#define SYS_GPM_MFPH_PM13MFP_TRACE_DATA1     0x0E4    0x14    0x3
+#define SYS_GPM_MFPH_PM13MFP_UART10_nRTS     0x0E4    0x14    0x2
+#define SYS_GPM_MFPH_PM13MFP_UART11_TXD      0x0E4    0x14    0x4
+#define SYS_GPM_MFPH_PM14MFP_CAN2_RXD        0x0E4    0x18    0x4
+#define SYS_GPM_MFPH_PM14MFP_EBI_AD10        0x0E4    0x18    0x8
+#define SYS_GPM_MFPH_PM14MFP_ECAP1_IC1       0x0E4    0x18    0x9
+#define SYS_GPM_MFPH_PM14MFP_EPWM1_BRAKE0    0x0E4    0x18    0x1
+#define SYS_GPM_MFPH_PM14MFP_GPIO            0x0E4    0x18    0x0
+#define SYS_GPM_MFPH_PM14MFP_I2C3_SDA        0x0E4    0x18    0x6
+#define SYS_GPM_MFPH_PM14MFP_INT1            0x0E4    0x18    0xD
+#define SYS_GPM_MFPH_PM14MFP_TM10            0x0E4    0x18    0xB
+#define SYS_GPM_MFPH_PM14MFP_TRACE_DATA2     0x0E4    0x18    0x3
+#define SYS_GPM_MFPH_PM14MFP_UART10_RXD      0x0E4    0x18    0x2
+#define SYS_GPM_MFPH_PM14MFP_USBHL3_DM       0x0E4    0x18    0x5
+#define SYS_GPM_MFPH_PM15MFP_CAN2_TXD        0x0E4    0x1C    0x4
+#define SYS_GPM_MFPH_PM15MFP_EBI_AD11        0x0E4    0x1C    0x8
+#define SYS_GPM_MFPH_PM15MFP_ECAP1_IC2       0x0E4    0x1C    0x9
+#define SYS_GPM_MFPH_PM15MFP_EPWM1_BRAKE1    0x0E4    0x1C    0x1
+#define SYS_GPM_MFPH_PM15MFP_GPIO            0x0E4    0x1C    0x0
+#define SYS_GPM_MFPH_PM15MFP_I2C3_SCL        0x0E4    0x1C    0x6
+#define SYS_GPM_MFPH_PM15MFP_INT2            0x0E4    0x1C    0xD
+#define SYS_GPM_MFPH_PM15MFP_TM10_EXT        0x0E4    0x1C    0xB
+#define SYS_GPM_MFPH_PM15MFP_TRACE_DATA3     0x0E4    0x1C    0x3
+#define SYS_GPM_MFPH_PM15MFP_UART10_TXD      0x0E4    0x1C    0x2
+#define SYS_GPM_MFPH_PM15MFP_USBHL3_DP       0x0E4    0x1C    0x5
+/********************* Bit definition of GPN_MFPL register **********************/
+#define SYS_GPN_MFPL_PN0MFP_GPIO             0x0E8    0x00    0x0
+#define SYS_GPN_MFPL_PN0MFP_I2C2_SDA         0x0E8    0x00    0x4
+#define SYS_GPN_MFPL_PN0MFP_VCAP1_DATA0      0x0E8    0x00    0x6
+#define SYS_GPN_MFPL_PN1MFP_GPIO             0x0E8    0x04    0x0
+#define SYS_GPN_MFPL_PN1MFP_I2C2_SCL         0x0E8    0x04    0x4
+#define SYS_GPN_MFPL_PN1MFP_VCAP1_DATA1      0x0E8    0x04    0x6
+#define SYS_GPN_MFPL_PN2MFP_CAN0_RXD         0x0E8    0x08    0x3
+#define SYS_GPN_MFPL_PN2MFP_GPIO             0x0E8    0x08    0x0
+#define SYS_GPN_MFPL_PN2MFP_USBHL0_DM        0x0E8    0x08    0x4
+#define SYS_GPN_MFPL_PN2MFP_VCAP1_DATA2      0x0E8    0x08    0x6
+#define SYS_GPN_MFPL_PN3MFP_CAN0_TXD         0x0E8    0x0C    0x3
+#define SYS_GPN_MFPL_PN3MFP_GPIO             0x0E8    0x0C    0x0
+#define SYS_GPN_MFPL_PN3MFP_USBHL0_DP        0x0E8    0x0C    0x4
+#define SYS_GPN_MFPL_PN3MFP_VCAP1_DATA3      0x0E8    0x0C    0x6
+#define SYS_GPN_MFPL_PN4MFP_GPIO             0x0E8    0x10    0x0
+#define SYS_GPN_MFPL_PN4MFP_I2C1_SDA         0x0E8    0x10    0x4
+#define SYS_GPN_MFPL_PN4MFP_VCAP1_DATA4      0x0E8    0x10    0x6
+#define SYS_GPN_MFPL_PN5MFP_GPIO             0x0E8    0x14    0x0
+#define SYS_GPN_MFPL_PN5MFP_I2C1_SCL         0x0E8    0x14    0x4
+#define SYS_GPN_MFPL_PN5MFP_VCAP1_DATA5      0x0E8    0x14    0x6
+#define SYS_GPN_MFPL_PN6MFP_CAN1_RXD         0x0E8    0x18    0x3
+#define SYS_GPN_MFPL_PN6MFP_GPIO             0x0E8    0x18    0x0
+#define SYS_GPN_MFPL_PN6MFP_USBHL1_DM        0x0E8    0x18    0x4
+#define SYS_GPN_MFPL_PN6MFP_VCAP1_DATA6      0x0E8    0x18    0x6
+#define SYS_GPN_MFPL_PN7MFP_CAN1_TXD         0x0E8    0x1C    0x3
+#define SYS_GPN_MFPL_PN7MFP_GPIO             0x0E8    0x1C    0x0
+#define SYS_GPN_MFPL_PN7MFP_USBHL1_DP        0x0E8    0x1C    0x4
+#define SYS_GPN_MFPL_PN7MFP_VCAP1_DATA7      0x0E8    0x1C    0x6
+/********************* Bit definition of GPN_MFPH register **********************/
+#define SYS_GPN_MFPH_PN8MFP_EPWM2_CH4        0x0EC    0x00    0x1
+#define SYS_GPN_MFPH_PN8MFP_GPIO             0x0EC    0x00    0x0
+#define SYS_GPN_MFPH_PN8MFP_I2C0_SDA         0x0EC    0x00    0x4
+#define SYS_GPN_MFPH_PN8MFP_SPI2_I2SMCLK     0x0EC    0x00    0x5
+#define SYS_GPN_MFPH_PN8MFP_VCAP1_DATA8      0x0EC    0x00    0x6
+#define SYS_GPN_MFPH_PN9MFP_EPWM2_CH5        0x0EC    0x04    0x1
+#define SYS_GPN_MFPH_PN9MFP_GPIO             0x0EC    0x04    0x0
+#define SYS_GPN_MFPH_PN9MFP_I2C0_SCL         0x0EC    0x04    0x4
+#define SYS_GPN_MFPH_PN9MFP_SPI1_I2SMCLK     0x0EC    0x04    0x5
+#define SYS_GPN_MFPH_PN9MFP_VCAP1_DATA9      0x0EC    0x04    0x6
+#define SYS_GPN_MFPH_PN10MFP_CAN2_RXD        0x0EC    0x08    0x3
+#define SYS_GPN_MFPH_PN10MFP_GPIO            0x0EC    0x08    0x0
+#define SYS_GPN_MFPH_PN10MFP_USBHL2_DM       0x0EC    0x08    0x4
+#define SYS_GPN_MFPH_PN10MFP_VCAP1_SCLK      0x0EC    0x08    0x6
+#define SYS_GPN_MFPH_PN11MFP_CAN2_TXD        0x0EC    0x0C    0x3
+#define SYS_GPN_MFPH_PN11MFP_GPIO            0x0EC    0x0C    0x0
+#define SYS_GPN_MFPH_PN11MFP_USBHL2_DP       0x0EC    0x0C    0x4
+#define SYS_GPN_MFPH_PN11MFP_VCAP1_PIXCLK    0x0EC    0x0C    0x6
+#define SYS_GPN_MFPH_PN12MFP_GPIO            0x0EC    0x10    0x0
+#define SYS_GPN_MFPH_PN12MFP_I2C5_SDA        0x0EC    0x10    0x4
+#define SYS_GPN_MFPH_PN12MFP_UART12_RXD      0x0EC    0x10    0x3
+#define SYS_GPN_MFPH_PN12MFP_UART6_nCTS      0x0EC    0x10    0x2
+#define SYS_GPN_MFPH_PN12MFP_VCAP1_HSYNC     0x0EC    0x10    0x6
+#define SYS_GPN_MFPH_PN13MFP_GPIO            0x0EC    0x14    0x0
+#define SYS_GPN_MFPH_PN13MFP_I2C5_SCL        0x0EC    0x14    0x4
+#define SYS_GPN_MFPH_PN13MFP_UART12_TXD      0x0EC    0x14    0x3
+#define SYS_GPN_MFPH_PN13MFP_UART6_nRTS      0x0EC    0x14    0x2
+#define SYS_GPN_MFPH_PN13MFP_VCAP1_VSYNC     0x0EC    0x14    0x6
+#define SYS_GPN_MFPH_PN14MFP_CAN3_RXD        0x0EC    0x18    0x3
+#define SYS_GPN_MFPH_PN14MFP_GPIO            0x0EC    0x18    0x0
+#define SYS_GPN_MFPH_PN14MFP_SPI1_I2SMCLK    0x0EC    0x18    0x7
+#define SYS_GPN_MFPH_PN14MFP_SPI1_SS1        0x0EC    0x18    0x5
+#define SYS_GPN_MFPH_PN14MFP_UART6_RXD       0x0EC    0x18    0x2
+#define SYS_GPN_MFPH_PN14MFP_USBHL3_DM       0x0EC    0x18    0x4
+#define SYS_GPN_MFPH_PN14MFP_VCAP1_SFIELD    0x0EC    0x18    0x6
+#define SYS_GPN_MFPH_PN15MFP_CAN3_TXD        0x0EC    0x1C    0x3
+#define SYS_GPN_MFPH_PN15MFP_CLKO            0x0EC    0x1C    0xA
+#define SYS_GPN_MFPH_PN15MFP_EADC0_ST        0x0EC    0x1C    0x9
+#define SYS_GPN_MFPH_PN15MFP_EPWM2_CH4       0x0EC    0x1C    0x1
+#define SYS_GPN_MFPH_PN15MFP_GPIO            0x0EC    0x1C    0x0
+#define SYS_GPN_MFPH_PN15MFP_I2S0_MCLK       0x0EC    0x1C    0x5
+#define SYS_GPN_MFPH_PN15MFP_SC0_nCD         0x0EC    0x1C    0x8
+#define SYS_GPN_MFPH_PN15MFP_SPI1_I2SMCLK    0x0EC    0x1C    0x7
+#define SYS_GPN_MFPH_PN15MFP_SPI1_SS1        0x0EC    0x1C    0x6
+#define SYS_GPN_MFPH_PN15MFP_TM6             0x0EC    0x1C    0xB
+#define SYS_GPN_MFPH_PN15MFP_UART6_TXD       0x0EC    0x1C    0x2
+#define SYS_GPN_MFPH_PN15MFP_USBHL3_DP       0x0EC    0x1C    0x4
+
+#endif /* _MA35D1_PINFUNC_ */
diff --git a/include/dt-bindings/reset/nuvoton,ma35d1-reset.h b/include/dt-bindings/reset/nuvoton,ma35d1-reset.h
new file mode 100644
index 0000000..f36fd54
--- /dev/null
+++ b/include/dt-bindings/reset/nuvoton,ma35d1-reset.h
@@ -0,0 +1,107 @@
+/* SPDX-License-Identifier: GPL-2.0 */
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp.
+ *
+ */
+
+#ifndef __NUVOTON_MA35D1_RESET_H__
+#define __NUVOTON_MA35D1_RESET_H__
+
+#define MA35D1_RESET_CHIP		0
+#define MA35D1_RESET_CA35CR0		1
+#define MA35D1_RESET_CA35CR1		2
+#define MA35D1_RESET_CM4		3
+#define MA35D1_RESET_PDMA0		4
+#define MA35D1_RESET_PDMA1		5
+#define MA35D1_RESET_PDMA2		6
+#define MA35D1_RESET_PDMA3		7
+#define MA35D1_RESET_DISP		9
+#define MA35D1_RESET_VCAP0		10
+#define MA35D1_RESET_VCAP1		11
+#define MA35D1_RESET_GFX		12
+#define MA35D1_RESET_VDEC		13
+#define MA35D1_RESET_WHC0		14
+#define MA35D1_RESET_WHC1		15
+#define MA35D1_RESET_GMAC0		16
+#define MA35D1_RESET_GMAC1		17
+#define MA35D1_RESET_HWSEM		18
+#define MA35D1_RESET_EBI		19
+#define MA35D1_RESET_HSUSBH0		20
+#define MA35D1_RESET_HSUSBH1		21
+#define MA35D1_RESET_HSUSBD		22
+#define MA35D1_RESET_USBHL		23
+#define MA35D1_RESET_SDH0		24
+#define MA35D1_RESET_SDH1		25
+#define MA35D1_RESET_NAND		26
+#define MA35D1_RESET_GPIO		27
+#define MA35D1_RESET_MCTLP		28
+#define MA35D1_RESET_MCTLC		29
+#define MA35D1_RESET_DDRPUB		30
+#define MA35D1_RESET_TMR0		34
+#define MA35D1_RESET_TMR1		35
+#define MA35D1_RESET_TMR2		36
+#define MA35D1_RESET_TMR3		37
+#define MA35D1_RESET_I2C0		40
+#define MA35D1_RESET_I2C1		41
+#define MA35D1_RESET_I2C2		42
+#define MA35D1_RESET_I2C3		43
+#define MA35D1_RESET_QSPI0		44
+#define MA35D1_RESET_SPI0		45
+#define MA35D1_RESET_SPI1		46
+#define MA35D1_RESET_SPI2		47
+#define MA35D1_RESET_UART0		48
+#define MA35D1_RESET_UART1		49
+#define MA35D1_RESET_UART2		50
+#define MA35D1_RESET_UAER3		51
+#define MA35D1_RESET_UART4		52
+#define MA35D1_RESET_UART5		53
+#define MA35D1_RESET_UART6		54
+#define MA35D1_RESET_UART7		55
+#define MA35D1_RESET_CANFD0		56
+#define MA35D1_RESET_CANFD1		57
+#define MA35D1_RESET_EADC0		60
+#define MA35D1_RESET_I2S0		61
+#define MA35D1_RESET_SC0		64
+#define MA35D1_RESET_SC1		65
+#define MA35D1_RESET_QSPI1		68
+#define MA35D1_RESET_SPI3		70
+#define MA35D1_RESET_EPWM0		80
+#define MA35D1_RESET_EPWM1		81
+#define MA35D1_RESET_QEI0		86
+#define MA35D1_RESET_QEI1		87
+#define MA35D1_RESET_ECAP0		90
+#define MA35D1_RESET_ECAP1		91
+#define MA35D1_RESET_CANFD2		92
+#define MA35D1_RESET_ADC0		95
+#define MA35D1_RESET_TMR4		96
+#define MA35D1_RESET_TMR5		97
+#define MA35D1_RESET_TMR6		98
+#define MA35D1_RESET_TMR7		99
+#define MA35D1_RESET_TMR8		100
+#define MA35D1_RESET_TMR9		101
+#define MA35D1_RESET_TMR10		102
+#define MA35D1_RESET_TMR11		103
+#define MA35D1_RESET_UART8		104
+#define MA35D1_RESET_UART9		105
+#define MA35D1_RESET_UART10		106
+#define MA35D1_RESET_UART11		107
+#define MA35D1_RESET_UART12		108
+#define MA35D1_RESET_UART13		109
+#define MA35D1_RESET_UART14		110
+#define MA35D1_RESET_UART15		111
+#define MA35D1_RESET_UART16		112
+#define MA35D1_RESET_I2S1		113
+#define MA35D1_RESET_I2C4		114
+#define MA35D1_RESET_I2C5		115
+#define MA35D1_RESET_EPWM2		116
+#define MA35D1_RESET_ECAP2		117
+#define MA35D1_RESET_QEI2		118
+#define MA35D1_RESET_CANFD3		119
+#define MA35D1_RESET_KPI		120
+#define MA35D1_RESET_GIC		124
+#define MA35D1_RESET_SSMCC		126
+#define MA35D1_RESET_SSPCC		127
+
+#define MA35D1_RESET_COUNT		128
+
+#endif	//__NUVOTON_MA35D1_RESET_H__
diff --git a/plat/nuvoton/ma35d1/aarch64/ma35d1_helpers.S b/plat/nuvoton/ma35d1/aarch64/ma35d1_helpers.S
new file mode 100644
index 0000000..8a331d3
--- /dev/null
+++ b/plat/nuvoton/ma35d1/aarch64/ma35d1_helpers.S
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <arch.h>
+#include <asm_macros.S>
+#include <drivers/arm/gicv2.h>
+#include <drivers/arm/fvp/fvp_pwrc.h>
+#include <platform_def.h>
+
+	.globl	plat_my_core_pos
+
+	.globl	plat_secondary_cold_boot_setup
+	.globl	plat_get_my_entrypoint
+	.globl	plat_is_my_cpu_primary
+
+	.globl	plat_reset_handler
+
+	.globl	plat_crash_console_init
+	.globl	plat_crash_console_putc
+	.globl	plat_crash_console_flush
+	.globl	platform_mem_init
+
+	/* ----------------------------------------------
+	 * unsigned int plat_my_core_pos(void)
+	 * This Function uses the plat_calc_core_pos()
+	 * to get the index of the calling CPU.
+	 * ----------------------------------------------
+	 */
+func plat_my_core_pos
+	mrs	x0, mpidr_el1
+	and	x1, x0, #MPIDR_CPU_MASK
+	and 	x0, x0, #MPIDR_CLUSTER_MASK
+	add	x0, x1, x0, LSR #6
+	ret
+endfunc plat_my_core_pos
+
+	/* -----------------------------------------------------
+	 * void plat_secondary_cold_boot_setup (void);
+	 *
+	 * This function performs any platform specific actions
+	 * needed for a secondary cpu after a cold reset e.g
+	 * mark the cpu's presence, mechanism to place it in a
+	 * holding pen etc.
+	 * TODO: Should we read the PSYS register to make sure
+	 * that the request has gone through.
+	 * -----------------------------------------------------
+	 */
+func plat_secondary_cold_boot_setup
+#ifndef EL3_PAYLOAD_BASE
+	/* ---------------------------------------------
+	 * Power down this cpu.
+	 * TODO: Do we need to worry about powering the
+	 * cluster down as well here. That will need
+	 * locks which we won't have unless an elf-
+	 * loader zeroes out the zi section.
+	 * ---------------------------------------------
+	 */
+	mrs	x0, mpidr_el1
+	mov_imm	x1, PWRC_BASE
+	str	w0, [x1, #PPOFFR_OFF]
+
+	/* ---------------------------------------------
+	 * There is no sane reason to come out of this
+	 * wfi so panic if we do. This cpu will be pow-
+	 * ered on and reset by the cpu_on pm api
+	 * ---------------------------------------------
+	 */
+	dsb	sy
+	wfi
+	no_ret	plat_panic_handler
+#else
+	mov_imm	x0, PLAT_ARM_TRUSTED_MAILBOX_BASE
+
+	/* Wait until the entrypoint gets populated */
+poll_mailbox:
+	ldr	x1, [x0]
+	cbz	x1, 1f
+	br	x1
+1:
+	wfe
+	b	poll_mailbox
+#endif /* EL3_PAYLOAD_BASE */
+endfunc plat_secondary_cold_boot_setup
+
+	/* ---------------------------------------------------------------------
+	 * uintptr_t plat_get_my_entrypoint (void);
+	 *
+	 * Main job of this routine is to distinguish between a cold and warm
+	 * boot. On MA35D1, this information can be queried from the power
+	 * controller. The Power Control SYS Status Register (PSYSR) indicates
+	 * the wake-up reason for the CPU.
+	 *
+	 * For a cold boot, return 0.
+	 * For a warm boot, read the mailbox and return the address it contains.
+	 *
+	 * TODO: PSYSR is a common register and should be
+	 * 	accessed using locks. Since it is not possible
+	 * 	to use locks immediately after a cold reset
+	 * 	we are relying on the fact that after a cold
+	 * 	reset all cpus will read the same WK field
+	 * ---------------------------------------------------------------------
+	 */
+func plat_get_my_entrypoint
+	/* ---------------------------------------------------------------------
+	 * When bit PSYSR.WK indicates either "Wake by PPONR" or "Wake by GIC
+	 * WakeRequest signal" then it is a warm boot.
+	 * ---------------------------------------------------------------------
+	 */
+#if 0
+	mrs	x2, mpidr_el1
+	mov_imm	x1, PWRC_BASE
+	str	w2, [x1, #PSYSR_OFF]
+	ldr	w2, [x1, #PSYSR_OFF]
+	ubfx	w2, w2, #PSYSR_WK_SHIFT, #PSYSR_WK_WIDTH
+	cmp	w2, #WKUP_PPONR
+	beq	warm_reset
+	cmp	w2, #WKUP_GICREQ
+	beq	warm_reset
+#endif
+	/* Cold reset */
+	mov	x0, #0
+	ret
+
+warm_reset:
+	/* ---------------------------------------------------------------------
+	 * A mailbox is maintained in the trusted SRAM. It is flushed out of the
+	 * caches after every update using normal memory so it is safe to read
+	 * it here with SO attributes.
+	 * ---------------------------------------------------------------------
+	 */
+	mov_imm	x0, PLAT_ARM_TRUSTED_MAILBOX_BASE
+	ldr	x0, [x0]
+	cbz	x0, _panic_handler
+	ret
+
+	/* ---------------------------------------------------------------------
+	 * The power controller indicates this is a warm reset but the mailbox
+	 * is empty. This should never happen!
+	 * ---------------------------------------------------------------------
+	 */
+_panic_handler:
+	no_ret	plat_panic_handler
+endfunc plat_get_my_entrypoint
+
+	/* -----------------------------------------------------
+	 * unsigned int plat_is_my_cpu_primary (void);
+	 *
+	 * Find out whether the current cpu is the primary
+	 * cpu.
+	 * -----------------------------------------------------
+	 */
+func plat_is_my_cpu_primary
+	mrs	x0, mpidr_el1
+	and	x0, x0, #(MPIDR_CLUSTER_MASK | MPIDR_CPU_MASK)
+	cmp	x0, #MA35D1_PRIMARY_CPU
+	cset	x0, eq
+	ret
+endfunc plat_is_my_cpu_primary
+
+
+func plat_reset_handler
+	ret
+endfunc plat_reset_handler
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_init(void)
+	 * Function to initialize the crash console
+	 * without a C Runtime to print crash report.
+	 * Clobber list : x0 - x4
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_init
+	mov_imm	x0, PLAT_ARM_CRASH_UART_BASE
+	mov_imm	x1, PLAT_ARM_CRASH_UART_CLK_IN_HZ
+	mov_imm	x2, ARM_CONSOLE_BAUDRATE
+	b	console_ma35d1_core_init
+endfunc plat_crash_console_init
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_putc(int c)
+	 * Function to print a character on the crash
+	 * console without a C Runtime.
+	 * Clobber list : x1, x2
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_putc
+	mov_imm	x1, PLAT_ARM_CRASH_UART_BASE
+	b	console_ma35d1_core_putc
+endfunc plat_crash_console_putc
+
+	/* ---------------------------------------------
+	 * int plat_crash_console_flush()
+	 * Function to force a write of all buffered
+	 * data that hasn't been output.
+	 * Out : return -1 on error else return 0.
+	 * Clobber list : r0
+	 * ---------------------------------------------
+	 */
+func plat_crash_console_flush
+	mov_imm	x0, PLAT_ARM_CRASH_UART_BASE
+	b	console_ma35d1_core_flush
+endfunc plat_crash_console_flush
+
+	/* ---------------------------------------------------------------------
+	 * We don't need to carry out any memory initialization on ARM
+	 * platforms. The Secure RAM is accessible straight away.
+	 * ---------------------------------------------------------------------
+	 */
+func platform_mem_init
+	ret
+endfunc platform_mem_init
+
+
diff --git a/plat/nuvoton/ma35d1/drivers/ma35d1_crypto.c b/plat/nuvoton/ma35d1/drivers/ma35d1_crypto.c
new file mode 100644
index 0000000..c69dc3a
--- /dev/null
+++ b/plat/nuvoton/ma35d1/drivers/ma35d1_crypto.c
@@ -0,0 +1,899 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+#include <stddef.h>
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <string.h>
+
+#include <common/debug.h>
+
+#include <drivers/auth/crypto_mod.h>
+#include <plat/common/platform.h>
+#include <plat/common/common_def.h>
+#include <platform_def.h>
+
+#include "../ma35d1_def.h"
+#include "../include/ma35d1_crypto.h"
+#include "../include/tsi_cmd.h"
+
+#define ENABLE_DEBUG
+
+#define LIB_NAME 		"MA35D1 Crypto"
+static int HAVE_TSI;
+
+typedef struct e_curve_t {
+	E_ECC_CURVE curve_id;
+	int32_t Echar;
+	char Ea[144];
+	char Eb[144];
+	char Px[144];
+	char Py[144];
+	int32_t Epl;
+	char Pp[176];
+	int32_t Eol;
+	char Eorder[176];
+	int32_t key_len;
+	int32_t irreducible_k1;
+	int32_t irreducible_k2;
+	int32_t irreducible_k3;
+	int32_t GF;
+} ECC_CURVE;
+
+static ECC_CURVE P256 = {
+	/* NIST: Curve P-256 : y^2=x^3-ax+b (mod p) */
+	CURVE_P_256,
+	64,			/* Echar */
+	"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFC",
+	"5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b",
+	"6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296",
+	"4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5",
+	78,			/* Epl */
+	"FFFFFFFF00000001000000000000000000000000FFFFFFFFFFFFFFFFFFFFFFFF",
+	78,			/* Eol */
+	"FFFFFFFF00000000FFFFFFFFFFFFFFFFBCE6FAADA7179E84F3B9CAC2FC632551",
+	256,			/* key_len */
+	10,
+	5,
+	2,
+	CURVE_GF_P
+};
+
+static ECC_CURVE *pCurve;
+
+static char temp_hex_str[160];
+
+__aligned(32) char param_block[4096];
+
+void dump_ecc_reg(char *str, uint32_t reg_addr, uint32_t count)
+{
+	int i;
+	uint32_t *regs = (uint32_t *) ((uint64_t) reg_addr);
+
+	printf("%s => ", str);
+	for (i = 0; i < count; i++) {
+		printf("0x%08x ", regs[i]);
+	}
+	printf("\n");
+}
+
+static char ch2hex(char ch)
+{
+	if (ch <= '9') {
+		ch = ch - '0';
+	} else if ((ch <= 'z') && (ch >= 'a')) {
+		ch = ch - 'a' + 10U;
+	} else {
+		ch = ch - 'A' + 10U;
+	}
+	return ch;
+}
+
+static int __strlen(char *str)
+{
+	char *p = str;
+	int len = 0;
+
+	while (*p != 0) {
+		p++;
+		len++;
+		if (len > 1024)	/* max. 4096 bits */
+			break;
+	}
+	return len;
+}
+
+static void Hex2Reg(char input[], uint32_t reg_addr)
+{
+	char hex;
+	int si, ri;
+	uint32_t i, val32;
+
+	volatile uint32_t *reg = (volatile uint32_t *)((uint64_t) reg_addr);
+
+	si = (int)__strlen(input) - 1;
+	ri = 0;
+
+	// printf("<%d>\n", si);
+
+	while (si >= 0) {
+		val32 = 0UL;
+		for (i = 0UL; (i < 8UL) && (si >= 0); i++) {
+			hex = ch2hex(input[si]);
+			val32 |= (uint32_t) hex << (i * 4UL);
+			si--;
+		}
+		reg[ri++] = val32;
+	}
+}
+
+static const char hex_char_tbl[] = "0123456789abcdef";
+
+/*
+ * @brief  Extract specified nibble from an unsigned word in character format.
+ *         For example:
+ *                Suppose val32 is 0x786543210, get_Nth_nibble_char(val32, 3)
+ *                will return a '3'.
+ * @param[in]  val32   The input unsigned word
+ * @param[in]  idx     The Nth nibble to be extracted.
+ * @return  The nibble in character format.
+ */
+static char get_Nth_nibble_char(uint32_t val32, uint32_t idx)
+{
+	return hex_char_tbl[(val32 >> (idx * 4U)) & 0xfU];
+}
+
+static void Reg2Hex(int32_t count, uint32_t reg[], char output[])
+{
+	int32_t idx, ri;
+	uint32_t i;
+
+	output[count] = 0;
+	idx = count - 1;
+
+	for (ri = 0; idx >= 0; ri++) {
+		for (i = 0UL; (i < 8UL) && (idx >= 0); i++) {
+			output[idx] = get_Nth_nibble_char(reg[ri], i);
+			idx--;
+		}
+	}
+}
+
+static void hex_to_string(unsigned char *hex, int count, char *str)
+{
+	for (; count > 0; hex++, count--) {
+		*str++ = hex_char_tbl[(*hex >> 4) & 0xf];
+		*str++ = hex_char_tbl[*hex & 0xf];
+	}
+	*str = 0;
+}
+
+static int ecc_strcmp(char *s1, char *s2)
+{
+	char c1, c2;
+
+	while (*s1 == '0')
+		s1++;
+	while (*s2 == '0')
+		s2++;
+
+	for (; *s1 || *s2; s1++, s2++) {
+		if ((*s1 >= 'A') && (*s1 <= 'Z'))
+			c1 = *s1 + 32;
+		else
+			c1 = *s1;
+
+		if ((*s2 >= 'A') && (*s2 <= 'Z'))
+			c2 = *s2 + 32;
+		else
+			c2 = *s2;
+
+		if (c1 != c2)
+			return 1;
+	}
+	return 0;
+}
+
+static void ecc_init_curve(ECC_CURVE *curve)
+{
+	int i;
+
+	pCurve = curve;
+
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_A(i), 0);
+		outp32(ECC_B(i), 0);
+		outp32(ECC_X1(i), 0);
+		outp32(ECC_Y1(i), 0);
+		outp32(ECC_X2(i), 0);
+		outp32(ECC_Y2(i), 0);
+		outp32(ECC_N(i), 0);
+	}
+
+	Hex2Reg(pCurve->Ea, ECC_A(0));
+	Hex2Reg(pCurve->Eb, ECC_B(0));
+	Hex2Reg(pCurve->Px, ECC_X1(0));
+	Hex2Reg(pCurve->Py, ECC_Y1(0));
+
+	//dump_ecc_reg("CRPT_ECC_CURVE_A", ECC_A(0), 10);
+	//dump_ecc_reg("CRPT_ECC_CURVE_B", ECC_B(0), 10);
+	//dump_ecc_reg("CRPT_ECC_POINT_X1", ECC_X1(0), 10);
+	//dump_ecc_reg("CRPT_ECC_POINT_Y1", ECC_Y1(0), 10);
+
+	if (pCurve->GF == (int)CURVE_GF_2M) {
+		outp32(ECC_N(0), 0x1);
+		i = pCurve->key_len / 32;
+		outp32(ECC_N(i),
+		       inp32(ECC_N(i)) | (1 << (pCurve->key_len % 32)));
+		i = (pCurve->irreducible_k1) / 32;
+		outp32(ECC_N(i),
+		       inp32(ECC_N(i)) | (1 << (pCurve->irreducible_k1 % 32)));
+		i = pCurve->irreducible_k2 / 32;
+		outp32(ECC_N(i),
+		       inp32(ECC_N(i)) | (1 << (pCurve->irreducible_k2 % 32)));
+		i = pCurve->irreducible_k3 / 32;
+		outp32(ECC_N(i),
+		       inp32(ECC_N(i)) | (1 << (pCurve->irreducible_k3 % 32)));
+	} else {
+		Hex2Reg(pCurve->Pp, ECC_N(0));
+	}
+	//dump_ecc_reg("CRPT_ECC_CURVE_N", ECC_N(0), 10);
+}
+
+static void run_ecc_codec(uint32_t mode, int enable_scap)
+{
+	uint32_t ctrl;
+
+	if ((mode & ECC_CTL_ECCOP_MASK) == ECCOP_MODULE) {
+		ctrl = ECC_CTL_FSEL;
+	} else {
+		if (pCurve->GF == (int)CURVE_GF_2M) {
+			/* point */
+			ctrl = 0;
+		} else {
+			/* CURVE_GF_P */
+			ctrl = ECC_CTL_FSEL;
+		}
+	}
+
+	if (enable_scap) {
+		/* enable side-channel attack protection */
+		ctrl |= ECC_CTL_SCAP;
+	}
+
+	ctrl |= ((uint32_t) pCurve->key_len << ECC_CTL_CURVEM_OFFSET) | mode;
+	outp32(ECC_CTL, (ctrl | ECC_CTL_START));
+
+	while (inp32(ECC_STS) & ECC_CTL_START)
+		;
+	while (inp32(ECC_STS) & ECC_STS_BUSY)
+		;
+}
+
+/*
+ * @brief  ECDSA digital signature verification.
+ * @param[in]  ecc_curve   The pre-defined ECC curve.
+ * @param[in]  message     The hash value of source context.
+ * @param[in]  public_k1   The public key 1.
+ * @param[in]  public_k2   The public key 2.
+ * @param[in]  R           R of the (R,S) pair digital signature
+ * @param[in]  S           S of the (R,S) pair digital signature
+ * @return  0    Success.
+ * @return  -1   "ecc_curve" value is invalid.
+ * @return  -2   Verification failed.
+ */
+int ecc_p256_verify(char *message, char *public_k1, char *public_k2,
+		    char *R, char *S)
+{
+	uint32_t temp_result1[18], temp_result2[18];
+	uint32_t temp_x[18], temp_y[18];
+	int i, ret = 0;
+
+	/*
+	 *   1. Verify that r and s are integers in the interval [1, n-1].
+	 *      If not, the signature is invalid
+	 *   2. Compute e = HASH (m), where HASH is the hashing algorithm in
+	 *      signature generation
+	 */
+
+	/*
+	 *   3. Compute w = s^-1 (mod n)
+	 *      (1) Write the curve order to N registers
+	 *      (2) Write 0x1 to Y1 registers
+	 *      (3) Write s to X1 registers
+	 *      (4) Set ECCOP(CRPT_ECC_CTL[10:9]) to 01
+	 *      (5) Set MOPOP(CRPT_ECC_CTL[12:11]) to 00
+	 *      (6) Set FSEL(CRPT_ECC_CTL[8]) according to used curve of prime
+	 *          field or binary field
+	 *      (7) Set START(CRPT_ECC_CTL[0]) to 1
+	 *      (8) Wait for BUSY(CRPT_ECC_STS[0]) be cleared
+	 *      (9) Read X1 registers to get w
+	 */
+	ecc_init_curve(&P256);
+
+	/*  3-(1) Write the curve order to N registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_N(i), 0);
+	}
+	Hex2Reg(pCurve->Eorder, ECC_N(0));
+
+	/*  3-(2) Write 0x1 to Y1 registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_Y1(i), 0);
+	}
+	outp32(ECC_Y1(0), 0x1);
+
+	/*  3-(3) Write s to X1 registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_X1(i), 0);
+	}
+	Hex2Reg(S, ECC_X1(0));
+
+	run_ecc_codec(ECCOP_MODULE | MODOP_DIV, 0);
+
+	/*  3-(9) Read X1 registers to get w */
+	for (i = 0; i < 18; i++) {
+		temp_result2[i] = inp32(ECC_X1(i));
+	}
+
+#ifdef ENABLE_DEBUG
+	printf("e = %s\n", message);
+	Reg2Hex(pCurve->Echar, temp_result2, temp_hex_str);
+	printf("w = %s\n", temp_hex_str);
+	printf("o = %s (order)\n", pCurve->Eorder);
+#endif
+
+	/*
+	 *   4. Compute u1 = e  w (mod n) and u2 = r  w (mod n)
+	 *      (1) Write the curve order and curve length to N ,M registers
+	 *      (2) Write e, w to X1, Y1 registers
+	 *      (3) Set ECCOP(CRPT_ECC_CTL[10:9]) to 01
+	 *      (4) Set MOPOP(CRPT_ECC_CTL[12:11]) to 01
+	 *      (5) Set START(CRPT_ECC_CTL[0]) to 1
+	 *      (6) Wait for BUSY(CRPT_ECC_STS[0]) be cleared
+	 *      (7) Read X1 registers to get u1
+	 *      (8) Write the curve order and curve length to N ,M registers
+	 *      (9) Write r, w to X1, Y1 registers
+	 *      (10) Set ECCOP(CRPT_ECC_CTL[10:9]) to 01
+	 *      (11) Set MOPOP(CRPT_ECC_CTL[12:11]) to 01
+	 *      (12) Set START(CRPT_ECC_CTL[0]) to 1
+	 *      (13) Wait for BUSY(CRPT_ECC_STS[0]) be cleared
+	 *      (14) Read X1 registers to get u2
+	 */
+
+	/*  4-(1) Write the curve order and curve length to N ,M registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_N(i), 0);
+	}
+	Hex2Reg(pCurve->Eorder, ECC_N(0));
+
+	/* 4-(2) Write e, w to X1, Y1 registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_X1(i), 0);
+	}
+	Hex2Reg(message, ECC_X1(0));
+
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_Y1(i), temp_result2[i]);
+	}
+
+	run_ecc_codec(ECCOP_MODULE | MODOP_MUL, 0);
+
+	/*  4-(7) Read X1 registers to get u1 */
+	for (i = 0; i < 18; i++) {
+		temp_result1[i] = inp32(ECC_X1(i));
+	}
+
+#ifdef ENABLE_DEBUG
+	Reg2Hex(pCurve->Echar, temp_result1, temp_hex_str);
+	printf("u1 = %s\n", temp_hex_str);
+#endif
+
+	/*  4-(8) Write the curve order and curve length to N ,M registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_N(i), 0);
+	}
+	Hex2Reg(pCurve->Eorder, ECC_N(0));
+
+	/* 4-(9) Write r, w to X1, Y1 registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_X1(i), 0);
+	}
+	Hex2Reg(R, ECC_X1(0));
+
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_Y1(i), temp_result2[i]);
+	}
+
+	run_ecc_codec(ECCOP_MODULE | MODOP_MUL, 0);
+
+	/*  4-(14) Read X1 registers to get u2 */
+	for (i = 0; i < 18; i++) {
+		temp_result2[i] = inp32(ECC_X1(i));
+	}
+
+#ifdef ENABLE_DEBUG
+	Reg2Hex(pCurve->Echar, temp_result2, temp_hex_str);
+	printf("u2 = %s\n", temp_hex_str);
+#endif
+
+	/*
+	 *   5. Compute X (x1, y1) = u1 * G + u2 * Q
+	 *      (1) Write the curve parameter A, B, N, and curve length M to
+	 *          corresponding registers
+	 *      (2) Write the point G(x, y) to X1, Y1 registers
+	 *      (3) Write u1 to K registers
+	 *      (4) Set ECCOP(CRPT_ECC_CTL[10:9]) to 00
+	 *      (5) Set START(CRPT_ECC_CTL[0]) to 1
+	 *      (6) Wait for BUSY(CRPT_ECC_STS[0]) be cleared
+	 *      (7) Read X1, Y1 registers to get u1*G
+	 *      (8) Write the curve parameter A, B, N, and curve length M to
+	 *          corresponding registers
+	 *      (9) Write the public key Q(x,y) to X1, Y1 registers
+	 *      (10) Write u2 to K registers
+	 *      (11) Set ECCOP(CRPT_ECC_CTL[10:9]) to 00
+	 *      (12) Set START(CRPT_ECC_CTL[0]) to 1
+	 *      (13) Wait for BUSY(CRPT_ECC_STS[0]) be cleared
+	 *      (14) Write the curve parameter A, B, N, and curve length M to
+	 *           corresponding registers
+	 *      (15) Write the result data u1*G to X2, Y2 registers
+	 *      (16) Set ECCOP(CRPT_ECC_CTL[10:9]) to 10
+	 *      (17) Set START(CRPT_ECC_CTL[0]) to 1
+	 *      (18) Wait for BUSY(CRPT_ECC_STS[0]) be cleared
+	 *      (19) Read X1, Y1 registers to get X(x1, y1)
+	 *      (20) Write the curve order and curve length to N ,M registers
+	 *      (21) Write x1 to X1 registers
+	 *      (22) Write 0x0 to Y1 registers
+	 *      (23) Set ECCOP(CRPT_ECC_CTL[10:9]) to 01
+	 *      (24) Set MOPOP(CRPT_ECC_CTL[12:11]) to 10
+	 *      (25) Set START(CRPT_ECC_CTL[0]) to 1
+	 *      (26) Wait for BUSY(CRPT_ECC_STS[0]) be cleared
+	 *      (27) Read X1 registers to get x1 (mod n)
+	 *
+	 *   6. The signature is valid if x1 = r, otherwise it is invalid
+	 */
+
+	/*
+	 *  (1) Write the curve parameter A, B, N, and curve length M to
+	 *      corresponding registers.
+	 *  (2) Write the point G(x, y) to X1, Y1 registers
+	 */
+	ecc_init_curve(&P256);
+
+	/* (3) Write u1 to K registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_K(i), temp_result1[i]);
+	}
+
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_X2(i), 0);
+	}
+	Hex2Reg(pCurve->Eorder, ECC_X2(0));
+
+	run_ecc_codec(ECCOP_POINT_MUL, 0);
+
+	/* (7) Read X1, Y1 registers to get u1*G */
+	for (i = 0; i < 18; i++) {
+		temp_x[i] = inp32(ECC_X1(i));
+		temp_y[i] = inp32(ECC_Y1(i));
+	}
+
+#ifdef ENABLE_DEBUG
+	Reg2Hex(pCurve->Echar, temp_x, temp_hex_str);
+	printf("5-(7) u1*G, x = %s\n", temp_hex_str);
+	Reg2Hex(pCurve->Echar, temp_y, temp_hex_str);
+	printf("5-(7) u1*G, y = %s\n", temp_hex_str);
+#endif
+
+	/* (8) Write the curve parameter A, B, N, and curve length M to
+	 *     corresponding registers.
+	 */
+	ecc_init_curve(&P256);
+
+	/* (9) Write the public key Q(x,y) to X1, Y1 registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_X1(i), 0);
+		outp32(ECC_Y1(i), 0);
+	}
+
+	Hex2Reg(public_k1, ECC_X1(0));
+	Hex2Reg(public_k2, ECC_Y1(0));
+
+	/* (10) Write u2 to K registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_K(i), temp_result2[i]);
+	}
+
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_X2(i), 0);
+	}
+	Hex2Reg(pCurve->Eorder, ECC_X2(0));
+
+	run_ecc_codec(ECCOP_POINT_MUL, 0);
+
+	for (i = 0; i < 18; i++) {
+		temp_result1[i] = inp32(ECC_X1(i));
+		temp_result2[i] = inp32(ECC_Y1(i));
+	}
+
+#ifdef ENABLE_DEBUG
+	Reg2Hex(pCurve->Echar, temp_result1, temp_hex_str);
+	printf("5-(13) u2*Q, x = %s\n", temp_hex_str);
+	Reg2Hex(pCurve->Echar, temp_result2, temp_hex_str);
+	printf("5-(13) u2*Q, y = %s\n", temp_hex_str);
+#endif
+
+	/* (14) Write the curve parameter A, B, N, and curve length M to
+	 * corresponding registers.
+	 */
+	ecc_init_curve(&P256);
+
+	/* Write the result data u2*Q to X1, Y1 registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_X1(i), temp_result1[i]);
+		outp32(ECC_Y1(i), temp_result2[i]);
+	}
+
+	/* (15) Write the result data u1*G to X2, Y2 registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_X2(i), temp_x[i]);
+		outp32(ECC_Y2(i), temp_y[i]);
+	}
+
+	run_ecc_codec(ECCOP_POINT_ADD, 0);
+
+	/* (19) Read X1, Y1 registers to get X(x1, y1) */
+	for (i = 0; i < 18; i++) {
+		temp_x[i] = inp32(ECC_X1(i));
+		temp_y[i] = inp32(ECC_Y1(i));
+	}
+
+#ifdef ENABLE_DEBUG
+	Reg2Hex(pCurve->Echar, temp_x, temp_hex_str);
+	printf("5-(19) x' = %s\n", temp_hex_str);
+	Reg2Hex(pCurve->Echar, temp_y, temp_hex_str);
+	printf("5-(19) y' = %s\n", temp_hex_str);
+#endif
+
+	/*  (20) Write the curve order and curve length to N ,M registers */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_N(i), 0);
+	}
+	Hex2Reg(pCurve->Eorder, ECC_N(0));
+
+	/*
+	 *  (21) Write x1 to X1 registers
+	 *  (22) Write 0x0 to Y1 registers
+	 */
+	for (i = 0; i < 18; i++) {
+		outp32(ECC_X1(i), temp_x[i]);
+		outp32(ECC_Y1(i), 0);
+	}
+
+#ifdef ENABLE_DEBUG
+	Reg2Hex(pCurve->Echar, (uint32_t *) (ECC_X1(0)), temp_hex_str);
+	printf("5-(21) x' = %s\n", temp_hex_str);
+	Reg2Hex(pCurve->Echar, (uint32_t *) (ECC_Y1(0)), temp_hex_str);
+	printf("5-(22) y' = %s\n", temp_hex_str);
+#endif
+
+	run_ecc_codec(ECCOP_MODULE | MODOP_ADD, 0);
+
+	/*  (27) Read X1 registers to get x1 (mod n) */
+	Reg2Hex(pCurve->Echar, (uint32_t *) (ECC_X1(0)), temp_hex_str);
+	printf("5-(27) x1' (mod n) = %s\n", temp_hex_str);
+
+	/* 6. The signature is valid if x1 = r, otherwise it is invalid */
+
+	/* Compare with test pattern to check if r is correct or not */
+	if (ecc_strcmp(temp_hex_str, R) != 0) {
+		printf("x1' (mod n) != R Test filed!!\n");
+		printf
+		    ("Signature R [%s] is not matched with expected R [%s]!\n",
+		     temp_hex_str, R);
+		ret = -2;
+	}
+
+	return ret;
+}
+
+/*
+ * Initialize the library and export the descriptor
+ */
+static void init(void)
+{
+	uint32_t ver;
+
+	if (inp32(SYS_CHIPCFG) & (1 << 8)) {
+		HAVE_TSI = 1;
+
+		/* enable wormhole clock */
+		outp32(CLK_SYSCLK1, inp32(CLK_SYSCLK1) | 0x30);
+
+		printf("TSI sync...\n");
+		while (1) {
+			if (TSI_Sync() == 0) {
+				if (TSI_Get_Version(&ver) == 0) {
+					printf("TSI version: %x\n", ver);
+					break;
+				}
+			}
+		}
+		printf("[OK]\n");
+	} else {
+		HAVE_TSI = 0;
+		do {
+			outp32(TSI_SYS_BASE + 0x100, 0x59);
+			outp32(TSI_SYS_BASE + 0x100, 0x16);
+			outp32(TSI_SYS_BASE + 0x100, 0x88);
+		} while (inp32(TSI_SYS_BASE + 0x100) == 0UL);
+
+		/* CLK->PLLCTL = 0x808C90;  PLL source from HIRC 144 MHz */
+		outp32(TSI_CLK_BASE + 0x40, 0x808C90);
+
+		/* wait PLL stable */
+		while ((inp32(TSI_CLK_BASE + 0x50) & 0x4) == 0)
+			;
+
+		/* Select TSI HCLK from PLL */
+		outp32(TSI_CLK_BASE + 0x10,
+		       (inp32(TSI_CLK_BASE + 0x10) & ~0x7) | 0x2);
+
+		/* enable crypto engine clock */
+		outp32(TSI_CLK_BASE + 0x4,
+		       inp32(TSI_CLK_BASE + 0x4) | (1 << 12));
+	}
+}
+
+int TSI_run_sha(int inswap, int outswap, int mode_sel, int hmac,
+		int mode, int keylen, int ks, int ks_num,
+		int wcnt, int data_cnt, uint32_t src_addr, uint32_t dest_addr)
+{
+	int sid, ret;
+
+	ret = TSI_Open_Session(C_CODE_SHA, &sid);
+	if (ret != 0)
+		goto err_out;
+
+	ret =
+	    TSI_SHA_Start(sid, inswap, outswap, mode_sel, hmac, mode, keylen,
+			  ks, ks_num);
+	if (ret != 0)
+		goto err_out;
+
+	ret = TSI_SHA_Finish(sid, wcnt, data_cnt, src_addr, dest_addr);
+	if (ret != 0)
+		goto err_out;
+
+	TSI_Close_Session(C_CODE_SHA, sid);
+	return 0;
+
+err_out:
+	printf("TSI ERROR!!! 0x%x\n", ret);
+	TSI_Close_Session(C_CODE_SHA, sid);
+	return ret;
+}
+
+/*
+ * Calculate a hash
+ *
+ * output points to the computed hash
+ */
+int calc_hash(uint32_t alg, void *data_ptr,
+	      uint32_t data_len, unsigned char *output)
+{
+	uint32_t ctrl;
+	int ret;
+
+	flush_dcache_range((uintptr_t) data_ptr, data_len);
+
+	if (HAVE_TSI == 0) {
+		ctrl = HMAC_CTL_INSWAP | HMAC_CTL_OUTSWAP |
+		    SHA_OPMODE_SHA256 | HMAC_CTL_DMAEN | HMAC_CTL_DMAFIRST |
+		    HMAC_CTL_DMALAST | HMAC_CTL_START;
+
+		outp32(INTSTS, (INTSTS_HMACIF | INTSTS_HMACEIF));
+		outp32(INTEN, (INTEN_HMACIEN | INTEN_HMACEIEN));
+
+		outp32(HMAC_KEYCNT, 0);
+		outp32(HMAC_DMACNT, data_len);
+		outp32(HMAC_SADDR, (uint32_t) ((uint64_t) data_ptr));
+		outp32(HMAC_CTL, ctrl);
+		memset(output, 0, 32);
+
+		while (inp32(HMAC_STS) & (HMAC_STS_BUSY | HMAC_STS_DMABUSY))
+			;
+		while ((inp32(INTSTS) & (INTSTS_HMACIF | INTSTS_HMACEIF)) == 0)
+			;
+		outp32(INTSTS, (INTSTS_HMACIF | INTSTS_HMACEIF));
+
+		memcpy(output, (unsigned char *)HMAC_DGST(0), 32);
+	} else {
+		ret = TSI_run_sha(1,	/* inswap        */
+				  1,	/* outswap       */
+				  0,	/* mode_sel      */
+				  0,	/* hmac          */
+				  0x04,	/* mode (SHA256) */
+				  0,	/* keylen (hmac) */
+				  0,	/* ks            */
+				  0,	/* ks_num        */
+				  8,	/* wcnt          */
+				  data_len,	/* data_cnt */
+				  (uint32_t) ((uint64_t) data_ptr), /* src_addr  */
+				  (uint32_t) ((uint64_t) output)    /* dest_addr */
+		    );
+		if (ret != 0) {
+			printf("TSI SHA ERROR!!! 0x%x\n", ret);
+			return -1;
+		}
+	}
+	return 0;
+}
+
+/*
+ * Match a hash
+ *
+ * Digest info is passed in DER format following the ASN.1 structure detailed
+ * above.
+ */
+int verify_hash(void *data_ptr, uint32_t data_len,
+		void *digest_info_ptr, uint32_t digest_info_len)
+{
+	int ret;
+	unsigned char digest[64];
+
+	ret = calc_hash(0, data_ptr, data_len, digest);
+	if (ret != 0)
+		return ret;
+
+	if (memcmp(digest, digest_info_ptr, 32) == 0)
+		return CRYPTO_SUCCESS;
+	else
+		return -1;
+}
+
+/*
+ * Verify a signature.
+ *
+ * Parameters are passed using the DER encoding format following the ASN.1
+ * structures detailed above.
+ */
+static int verify_signature(void *data_ptr, uint32_t data_len,
+			    void *sig_ptr, uint32_t sig_len,
+			    void *sig_alg, uint32_t sig_alg_len,
+			    void *pk_ptr, uint32_t pk_len)
+{
+	int ret;
+	unsigned char digest[36];
+	char message[128];
+
+	memset(digest, 0, sizeof(digest));
+	ret = calc_hash(0, data_ptr, data_len, digest);
+	if (ret != 0)
+		return ret;
+
+	hex_to_string(digest, 32, message);
+
+	if (HAVE_TSI == 0) {
+
+		ret =
+		    ecc_p256_verify(message, (char *)pk_ptr,
+				    (char *)pk_ptr + 64, (char *)sig_ptr,
+				    (char *)sig_ptr + 64);
+	} else {
+		memset(param_block, 0, sizeof(param_block));
+		memcpy(param_block, message, 64);
+		memcpy(&param_block[576], pk_ptr, 64);
+		memcpy(&param_block[1152], pk_ptr + 64, 64);
+		memcpy(&param_block[1728], sig_ptr, 64);
+		memcpy(&param_block[2304], sig_ptr + 64, 64);
+
+		ret = TSI_ECC_VerifySignature(CURVE_P_256,	/* curve_id   */
+					      ECC_KEY_SEL_USER,	/* psel       */
+					      0,	/* x_knum     */
+					      0,	/* y_knum     */
+					      (uint32_t) ((uint64_t) param_block));
+		if (ret != 0) {
+			printf("TSI ECC signature verification failed!!\n");
+			return -1;
+		}
+	}
+	return ret;
+}
+
+int aes256_ofb_decrypt(uint32_t *key, void *src_data, void *output,
+		       uint32_t data_len)
+{
+	int i, sid, ret;
+	uint32_t ctrl;
+	uint32_t aes_iv[4] = { 0, 0, 0, 0 };
+
+	flush_dcache_range((uintptr_t) src_data, data_len);
+	inv_dcache_range((uintptr_t) output, data_len);
+
+	if (HAVE_TSI)
+		goto tsi_aes;
+
+	outp32(AES_CTL, 0);
+	outp32(INTEN, (INTEN_AESIEN | INTEN_AESEIEN));
+	outp32(INTSTS, (INTSTS_AESIF | INTSTS_AESEIF));
+
+	/* program AES key */
+	for (i = 0; i < 8; i++) {
+		outp32(AES_KEY(i), key[i]);
+	}
+
+	/* program AES IV */
+	for (i = 0; i < 4; i++)
+		outp32(AES_IV(i), 0);
+
+	ctrl = (AES_KEYSZ_SEL_256 | AES_MODE_OFB | AES_CTL_INSWAP |
+		AES_CTL_OUTSWAP | AES_CTL_KINSWAP | AES_CTL_KOUTSWAP |
+		AES_CTL_DMAEN);
+
+	outp32(AES_CNT, data_len);
+	outp32(AES_SADDR, (uint32_t) ((uint64_t) src_data));
+	outp32(AES_DADDR, (uint32_t) ((uint64_t) output));
+
+	/* start AES */
+	outp32(AES_CTL, ctrl | AES_CTL_START);
+
+	while ((inp32(INTSTS) & (INTSTS_AESIF | INTSTS_AESEIF)) == 0)
+		;
+	outp32(INTSTS, (INTSTS_AESIF | INTSTS_AESEIF));
+
+	return 0;
+
+tsi_aes:
+	ret = TSI_Open_Session(C_CODE_AES, &sid);
+	if (ret != 0)
+		goto err_out;
+
+	ret = TSI_AES_Set_IV(sid, (uint32_t) ((uint64_t) aes_iv));
+	if (ret != 0)
+		goto err_out;
+
+	ret =
+	    TSI_AES_Set_Key(sid, AES_KEY_SIZE_256, (uint32_t) ((uint64_t) key));
+	if (ret != 0)
+		goto err_out;
+
+	ret = TSI_AES_Set_Mode(sid,	/* sid        */
+			       0,	/* kinswap    */
+			       0,	/* koutswap   */
+			       1,	/* inswap     */
+			       1,	/* outswap    */
+			       0,	/* sm4en      */
+			       0,	/* encrypt    */
+			       0x3,	/* mode; OFB  */
+			       AES_KEY_SIZE_256,	/* keysz      */
+			       0,	/* ks         */
+			       0	/* ks_num     */
+	    );
+	if (ret != 0)
+		goto err_out;
+
+	ret = TSI_AES_Run(sid, 1, data_len, (uint32_t) ((uint64_t) src_data),
+			  (uint32_t) ((uint64_t) output));
+	if (ret != 0)
+		goto err_out;
+
+	TSI_Close_Session(C_CODE_AES, sid);
+	return 0;
+
+err_out:
+	TSI_Close_Session(C_CODE_AES, sid);
+	printf("TSI ERROR!!! 0x%x\n", ret);
+	return ret;
+}
+
+/*
+ * Register crypto library descriptor
+ */
+REGISTER_CRYPTO_LIB_MA35(LIB_NAME, init, verify_signature, verify_hash, NULL);
diff --git a/plat/nuvoton/ma35d1/drivers/tsi_cmd.c b/plat/nuvoton/ma35d1/drivers/tsi_cmd.c
new file mode 100644
index 0000000..1db7635
--- /dev/null
+++ b/plat/nuvoton/ma35d1/drivers/tsi_cmd.c
@@ -0,0 +1,719 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <stddef.h>
+#include <string.h>
+
+#include <common/debug.h>
+#include <drivers/auth/crypto_mod.h>
+#include <plat/common/platform.h>
+#include <plat/common/common_def.h>
+#include <platform_def.h>
+
+#include <common/debug.h>
+#include <drivers/auth/crypto_mod.h>
+#include <plat/common/platform.h>
+#include <plat/common/common_def.h>
+#include <platform_def.h>
+
+#include "../ma35d1_def.h"
+#include "../include/ma35d1_crypto.h"
+#include "../include/tsi_cmd.h"
+#include "../include/whc.h"
+
+
+typedef struct err_code_t {
+	int	code;
+	char	str[32];
+} ERR_CODE_T;
+
+ERR_CODE_T _err_code_tbl[] = {
+	{ ST_SUCCESS,              "ST_SUCCESS" },
+	{ ST_WAIT_TSI_SYNC,        "ST_WAIT_TSI_SYNC" },
+	{ ST_UNKNOWN_CMD,          "ST_UNKNOWN_CMD" },
+	{ ST_NO_TSI_IMAGE,         "ST_NO_TSI_IMAGE" },
+	{ ST_CMD_QUEUE_FULL,       "ST_CMD_QUEUE_FULL" },
+	{ ST_TIME_OUT,             "ST_TIME_OUT" },
+	{ ST_INVALID_PARAM,        "ST_INVALID_PARAM" },
+	{ ST_NO_AVAIL_SESSION,     "ST_NO_AVAIL_SESSION" },
+	{ ST_INVALID_SESSION_ID,   "ST_INVALID_SESSION_ID" },
+	{ ST_INVALID_OPERATION,    "ST_INVALID_OPERATION"},
+	{ ST_HW_NOT_READY,         "ST_HW_NOT_READY"},
+	{ ST_HW_ERROR,             "ST_HW_ERROR" },
+	{ ST_HW_BUSY,              "ST_HW_BUSY" },
+	{ ST_HW_TIME_OUT,          "ST_HW_TIME_OUT" },
+	{ ST_BUS_ERROR,            "ST_BUS_ERROR" },
+	{ ST_ECC_UNKNOWN_CURVE,    "ST_ECC_UNKNOWN_CURVE" },
+	{ ST_ECC_INVALID_PRIV_KEY, "ST_ECC_INVALID_PRIV_KEY" },
+	{ ST_SIG_VERIFY_ERROR,     "ST_SIG_VERIFY_ERROR" },
+	{ ST_KS_READ_PROTECT,      "ST_KS_READ_PROTECT"},
+	{ ST_KS_FULL,              "ST_KS_FULL" },
+	{ ST_WHC_TX_BUSY,          "ST_WHC_TX_BUSY" },
+	{ ST_CMD_ACK_TIME_OUT,     "ST_CMD_ACK_TIME_OUT" },
+};
+
+void tsi_print_err_code(int code)
+{
+	int i;
+
+	for (i = 0; i < sizeof(_err_code_tbl) / sizeof(ERR_CODE_T); i++) {
+		if (_err_code_tbl[i].code == code) {
+			printf("  [%s]\n", _err_code_tbl[i].str);
+			return;
+		}
+	}
+	printf("\nUnknow error code 0x%x!\n", code);
+}
+
+int tsi_init(void)
+{
+	return 0;
+}
+
+int tsi_send_command(TSI_REQ_T *req)
+{
+	int	i;
+
+	//t0 = get_ticks();
+	for (i = 0; i < 4; i++) {
+		if (WHC1->TXSTS & (1 << i))	/* Check CHxRDY */
+			break;
+	}
+
+	if (i >= 4)
+		return ST_WHC_TX_BUSY;	/* No WHC channel is ready for sending message */
+	//printf("TSI CMD: 0x%x 0x%x 0x%x 0x%x\n", req->cmd[0], req->cmd[1],
+	//					req->cmd[2], req->cmd[3]);
+
+	WHC1->TMDAT[i][0] = req->cmd[0];
+	WHC1->TMDAT[i][1] = req->cmd[1];
+	WHC1->TMDAT[i][2] = req->cmd[2];
+	WHC1->TMDAT[i][3] = req->cmd[3];
+	WHC1->TXCTL = (1 << i);	/* send message */
+	req->tx_channel = i;
+
+	//req->tx_jiffy = get_ticks();
+	return 0;
+}
+
+
+int tsi_wait_ack(TSI_REQ_T *req, int time_out)
+{
+	int	i;
+
+	//t0 = get_ticks();
+	while (1) {
+		for (i = 0; i < 4; i++) {
+			if (WHC1->RXSTS & (1 << i)) {	/* Check CHxRDY */
+				if ((WHC1->RMDAT[i][0] & TCK_CHR_MASK) ==
+					(req->cmd[0] & TCK_CHR_MASK)) {
+
+					req->ack[0] = WHC1->RMDAT[i][0];
+					req->ack[1] = WHC1->RMDAT[i][1];
+					req->ack[2] = WHC1->RMDAT[i][2];
+					req->ack[3] = WHC1->RMDAT[i][3];
+					WHC1->RXCTL = (1 << i);	/* set CHxACK */
+
+					//printf("ACK: 0x%x 0x%x 0x%x 0x%x\n",
+					// req->ack[0], req->ack[1], req->ack[2], req->ack[3]);
+					return 0;
+				}
+			}
+		}
+	}
+}
+
+int tsi_send_command_and_wait(TSI_REQ_T *req, int time_out)
+{
+	int ret;
+
+	ret = tsi_send_command(req);
+	if (ret != 0)
+		return ret;
+
+	ret = tsi_wait_ack(req, time_out);
+	if (ret != 0)
+		return ret;
+	return TA_GET_STATUS(req);
+}
+
+
+/*
+ * @brief    Force TSI go back to initial state.
+ * @return   0            success
+ * @return   otherwise    Refer to ST_XXX error code.
+ */
+int TSI_Sync(void)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = CMD_TSI_SYNC << 16;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Get the version of TSI firmware.
+ * @param[out]  ver_code     TSI firmware version code.
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_Get_Version(uint32_t *ver_code)
+{
+	TSI_REQ_T req;
+	int ret;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = CMD_TSI_GET_VERSION << 16;
+	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+	*ver_code = req.ack[1];
+	return ret;
+}
+
+
+/*
+ * @brief    Reset TSI.
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_Reset(void)
+{
+	TSI_REQ_T req;
+	int ret;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = CMD_TSI_RESET << 16;
+	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+	return ret;
+}
+
+
+/*
+ * @brief    Reset TSI.
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_Config_UART(uint32_t line, uint32_t baud)
+{
+	TSI_REQ_T req;
+	int ret;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = CMD_TSI_CONFIG_UART << 16;
+	req.cmd[1] = 0x11520087;
+	req.cmd[2] = line;
+	req.cmd[3] = baud;
+	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+	return ret;
+}
+
+/**
+  * @brief    Set TSI system clock.
+  * @param[in]  pllctl   The value to be written to TSI PLL_CTL register
+  * @return   0          success
+  * @return   otherwise  Refer to ST_XXX error code.
+  */
+int TSI_Set_Clock(uint32_t pllctl)
+{
+	TSI_REQ_T  req;
+	int        ret;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_TSI_SET_CLOCK << 16);
+	req.cmd[1] = pllctl;
+	
+	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+	if (ret != 0)
+		return ret;
+	return 0;
+}
+
+/*
+ * @brief    Request an encrypt/decrypt session for AES or SHA.
+ * @param[in]   class_code   The command class. Should be C_CODE_AES or C_CODE_SHA.
+ * @param[out]  session_id   The session ID.
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_Open_Session(int class_code, int *session_id)
+{
+	TSI_REQ_T req;
+	int ret;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_TSI_OPEN_SESSION << 16) | class_code;
+	ret = tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+	if (ret != 0)
+		return ret;
+	*session_id = req.ack[1] & 0xff;
+	return 0;
+}
+
+
+/*
+ * @brief    Close an opened session.
+ * @param[in]   class_code   The command class. Should be C_CODE_AES or C_CODE_SHA.
+ * @param[in]   session_id   The session ID.
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_Close_Session(int class_code, int session_id)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_TSI_CLOSE_SESSION << 16) | (class_code << 8) | session_id;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Configure AES encrypt/decrypt mode.
+ * @param[in]  sid           The session ID obtained from TSI_Open_Session().
+ * @param[in]  kinswap       1: Swap key and initial vector
+ *                           0: Do not swap key and initial vector
+ * @param[in]  koutswap      1: Swap feedback output
+ *                           0: Do not swap AES feedback output
+ * @param[in]  inswap        1: Swap input data
+ *                           0: Do not swap input data
+ * @param[in]  outswap       1: Swap output data
+ *                           0: Do not swap output data
+ * @param[in]  sm4en         1: Use SM4 cipher
+ *                           0: Use AES cipher
+ * @param[in]  encrypt       1: Execute encrypt operation
+ *                           0: Execute decrypt operation
+ * @param[in]  mode          Operation mode
+ *                           - \ref AES_MODE_ECB
+ *                           - \ref AES_MODE_CBC
+ *                           - \ref AES_MODE_CFB
+ *                           - \ref AES_MODE_OFB
+ *                           - \ref AES_MODE_CTR
+ *                           - \ref AES_MODE_CBC_CS1
+ *                           - \ref AES_MODE_CBC_CS2
+ *                           - \ref AES_MODE_CBC_CS3
+ *                           - \ref AES_MODE_GCM
+ *                           - \ref AES_MODE_GHASH
+ *                           - \ref AES_MODE_CCM
+ * @param[in]  keysz         Key size
+ *                           - \ref AES_KEY_SIZE_128
+ *                           - \ref AES_KEY_SIZE_192
+ *                           - \ref AES_KEY_SIZE_256
+ * @param[in]  ks            Key source
+ *                           SEL_KEY_FROM_REG:      Key is assigned by AES_Set_Key command
+ *                           SEL_KEY_FROM_KS_SRAM:  Key is from TSI Key Store SRAM
+ *                           SEL_KEY_FROM_KS_OTP:   Key is from TSI Key Store OTP
+ * @param[in]  ks_num        Key Store key number
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_AES_Set_Mode(int sid, int kinswap, int koutswap, int inswap,
+			int outswap, int sm4en, int encrypt, int mode, int keysz,
+			int ks, int ks_num)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_AES_SET_MODE << 16) | sid;
+	req.cmd[1] = (kinswap << 25) | (koutswap << 24) | (inswap << 23) |
+			 (outswap << 22) | (sm4en << 17) | (encrypt << 16) |
+			 (mode << 8) | (keysz << 2);
+	req.cmd[2] = (ks << 5) | ks_num;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Set AES/SM4 initial vector.
+ * @param[in]  sid           The session ID obtained from TSI_Open_Session().
+ * @param[in]  iv_addr       Address of the buffer for initial vector
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_AES_Set_IV(int sid, uint32_t iv_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_AES_SET_IV << 16) | sid;
+	req.cmd[1] = iv_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Set AES/SM4 initial vector.
+ * @param[in]  sid           The session ID obtained from TSI_Open_Session().
+ * @param[in]  keysz         Key size
+ *                           - \ref AES_KEY_SIZE_128
+ *                           - \ref AES_KEY_SIZE_192
+ *                           - \ref AES_KEY_SIZE_256
+ * @param[in]  key_addr       Address of the buffer for AES/SM4 key
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_AES_Set_Key(int sid, int keysz, uint32_t key_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_AES_SET_KEY << 16) | sid;
+
+	if (keysz == AES_KEY_SIZE_128)
+		req.cmd[1] = 4;
+	else if (keysz == AES_KEY_SIZE_192)
+		req.cmd[1] = 6;
+	else
+		req.cmd[1] = 8;
+
+	req.cmd[2] = key_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Start AES encrypt/decrypt.
+ * @param[in]  sid           The session ID obtained from TSI_Open_Session().
+ * @param[in]  is_last       1: Is the last run of this AES/SM4 session.
+ *                           0: Is not the last session.
+ * @param[in]  data_cnt      AES/SM4 encrypt/decrypt data count in bytes
+ *                           - \ref AES_KEY_SIZE_128
+ *                           - \ref AES_KEY_SIZE_192
+ *                           - \ref AES_KEY_SIZE_256
+ * @param[in]  src_addr      DMA input data address
+ * @param[in]  dest_addr     DMA output data address
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_AES_Run(int sid, int is_last, int data_cnt, uint32_t src_addr,
+		uint32_t dest_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_AES_RUN << 16) | sid;
+	req.cmd[1] = (is_last << 24) | data_cnt;
+	req.cmd[2] = src_addr;
+	req.cmd[3] = dest_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Start AES encrypt/decrypt.
+ * @param[in]  sid           The session ID obtained from TSI_Open_Session().
+ * @param[in]  is_last       1: Is the last run of this AES/SM4 session.
+ *                           0: Is not the last session.
+ * @param[in]  data_cnt      AES/SM4 encrypt/decrypt data count in bytes
+ *                           - \ref AES_KEY_SIZE_128
+ *                           - \ref AES_KEY_SIZE_192
+ *                           - \ref AES_KEY_SIZE_256
+ * @param[in]  src_addr      DMA input data address
+ * @param[in]  dest_addr     DMA output data address
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_AES_GCM_Run(int sid, int is_last, int data_cnt, uint32_t param_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_AES_GCM_RUN << 16) | sid;
+	req.cmd[1] = (is_last << 24) | data_cnt;
+	req.cmd[2] = param_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Read or write AES/SM4 intermediate feedback data.
+ * @param[in]  sid           The session ID obtained from TSI_Open_Session().
+ * @param[in]  rw            1: write feedback data
+ *                           0: read feedback data
+ * @param[in]  wcnt          Word count of feedback data
+ * @param[in]  fdbck_addr    Feedback data address
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_Access_Feedback(int sid, int rw, int wcnt, uint32_t fdbck_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_AES_ACCESS_FEEDBACK << 16) | sid;
+	req.cmd[1] = (rw << 7) | wcnt;
+	req.cmd[2] = fdbck_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Start to process the first block of a SHA session.
+ * @param[in]  sid           The session ID obtained from TSI_Open_Session().
+ * @param[in]  inswap        1: Swap input data
+ *                           0: Do not swap input data
+ * @param[in]  outswap       1: Swap output data
+ *                           0: Do not swap output data
+ * @param[in]  mode_sel      SHA engine mode
+ *                           - \ref SHA_MODE_SEL_SHA1
+ *                           - \ref SHA_MODE_SEL_SHA2
+ *                           - \ref SHA_MODE_SEL_SHA3
+ *                           - \ref SHA_MODE_SEL_SM3
+ *                           - \ref SHA_MODE_SEL_MD5
+ * @param[in]  hmac          1: Use HMAC key
+ *                           0: No HMAC
+ * @param[in]  mode          Operation mode
+ *                           - \ref SHA_MODE_SHA1
+ *                           - \ref SHA_MODE_SHA224
+ *                           - \ref SHA_MODE_SHA256
+ *                           - \ref SHA_MODE_SHA384
+ *                           - \ref SHA_MODE_SHA512
+ *                           - \ref SHA_MODE_SHAKE128
+ *                           - \ref SHA_MODE_SHAKE256
+ * @param[in]  keylen        HMAC key length in bytes. Only effective when <hmac> is 1.
+ * @param[in]  ks            Key source
+ *                           SEL_KEY_FROM_REG:      HMAC key is from TSI_SHA_Update() data
+ *                           SEL_KEY_FROM_KS_SRAM:  HMAC key is from TSI Key Store SRAM
+ *                           SEL_KEY_FROM_KS_OTP:   HMAC key is from TSI Key Store OTP
+ * @param[in]  ks_num        Key Store key number
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_SHA_Start(int sid, int inswap, int outswap, int mode_sel, int hmac,
+			int mode, int keylen, int ks, int ks_num)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_SHA_START << 16) | sid;
+	req.cmd[1] = (inswap << 23) | (outswap << 22) | (mode_sel << 12) |
+			(hmac << 11) | (mode << 8);
+	req.cmd[2] = keylen;
+	req.cmd[3] = (ks << 5) | ks_num;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Update SHA data.
+ * @param[in]  sid           The session ID obtained from TSI_Open_Session().
+ * @param[in]  data_cnt      byte count of input data
+ * @param[in]  src_addr      Address of input data
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_SHA_Update(int sid, int data_cnt, uint32_t src_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_SHA_UPDATE << 16) | sid;
+	req.cmd[1] = data_cnt;
+	req.cmd[2] = src_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Update the last block of data and get result digest.
+ * @param[in]  sid           The session ID obtained from TSI_Open_Session().
+ * @param[in]  wcnt          Word count of output digest
+ * @param[in]  data_cnt      Byte count of input data
+ * @param[in]  src_addr      Address of input data
+ * @param[in]  dest_addr     Address of output digest
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_SHA_Finish(int sid, int wcnt, int data_cnt, uint32_t src_addr,
+		   uint32_t dest_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_SHA_FINISH << 16) | sid;
+	req.cmd[1] = (wcnt << 24) | data_cnt;
+	req.cmd[2] = src_addr;
+	req.cmd[3] = dest_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Run SHA all at once.
+ * @param[in]  inswap        1: Swap input data
+ *                           0: Do not swap input data
+ * @param[in]  outswap       1: Swap output data
+ *                           0: Do not swap output data
+ * @param[in]  mode_sel      SHA engine mode
+ *                           - \ref SHA_MODE_SEL_SHA1
+ *                           - \ref SHA_MODE_SEL_SHA2
+ *                           - \ref SHA_MODE_SEL_SHA3
+ *                           - \ref SHA_MODE_SEL_SM3
+ *                           - \ref SHA_MODE_SEL_MD5
+ * @param[in]  mode          Operation mode
+ *                           - \ref SHA_MODE_SHA1
+ *                           - \ref SHA_MODE_SHA224
+ *                           - \ref SHA_MODE_SHA256
+ *                           - \ref SHA_MODE_SHA384
+ *                           - \ref SHA_MODE_SHA512
+ *                           - \ref SHA_MODE_SHAKE128
+ *                           - \ref SHA_MODE_SHAKE256
+ * @param[in]  wcnt          Word count of output digest
+ * @param[in]  data_cnt      Byte count of input data
+ * @param[in]  src_addr      Address of input data
+ * @param[in]  dest_addr     Address of output digest
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_SHA_All_At_Once(int inswap, int outswap, int mode_sel, int mode,
+			int wcnt, int data_cnt, uint32_t src_addr,
+			uint32_t dest_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_SHA_ALL_AT_ONCE << 16) | ((data_cnt >> 8) & 0xffff);
+	req.cmd[1] = ((data_cnt & 0xff) << 24) | (inswap << 23) | (outswap << 22) |
+			(mode_sel << 12) | (mode << 8) | wcnt;
+	req.cmd[2] = src_addr;
+	req.cmd[3] = dest_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Generate an ECC public key.
+ * @param[in]  curve_id      ECC curve ID
+ * @param[in]  is_ecdh       Only used when psel is ECC_KEY_SEL_KS_SRAM.
+ *                           0: is not ECDH key.
+ *                           1: is ECDH key.
+ * @param[in]  psel          Select private key source
+ *                           ECC_KEY_SEL_TRNG    : Private key is generated by TRNG
+ *                           ECC_KEY_SEL_KS_OTP  : Private Key is from Key Store OTP
+ *                           ECC_KEY_SEL_KS_SRAM : Private Key is from Key Store SRAM
+ *                           ECC_KEY_SEL_USER    : User defined private key
+ * @param[in]  d_knum        The Key Store key index. Effective only when <psel>
+ *                           is 0x01 or 0x02.
+ * @param[in]  priv_key      Address of input private key. Effective only when
+ *                           <psel> is 0x03.
+ * @param[in]  pub_key       Address of the output public key.
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_ECC_GenPublicKey(E_ECC_CURVE curve_id, int is_ecdh, int psel,
+			 int d_knum, uint32_t priv_key, uint32_t pub_key)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_ECC_GEN_PUB_KEY << 16) | curve_id;
+	req.cmd[1] = (is_ecdh << 10) | (psel << 8) | d_knum;
+	req.cmd[2] = priv_key;
+	req.cmd[3] = pub_key;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Generate an ECC signature.
+ * @param[in]  curve_id      ECC curve ID
+ * @param[in]  rsel          0: Random number is generated by TSI TRNG
+ *                           1: Use the random number specified in parameter block.
+ * @param[in]  psel          Select private key source
+ *                           ECC_KEY_SEL_TRNG    : Private key is generated by TRNG
+ *                           ECC_KEY_SEL_KS_OTP  : Private Key is from Key Store OTP
+ *                           ECC_KEY_SEL_KS_SRAM : Private Key is from Key Store SRAM
+ *                           ECC_KEY_SEL_USER    : User defined private key
+ * @param[in]  d_knum        The Key Store key index. Effective only when <psel>
+ *                           is 0x01 or 0x02.
+ * @param[in]  param_addr    Address of the input parameter block, including message
+ *                           and private key.
+ *                           The private key in parameter block is effective only
+ *                           when <psel> is 0x03.
+ * @param[in]  sig_addr      Address of the output signature.
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_ECC_GenSignature(E_ECC_CURVE curve_id, int rsel, int psel, int d_knum,
+			 uint32_t param_addr, uint32_t sig_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_ECC_GEN_SIG << 16) | curve_id;
+	req.cmd[1] = (rsel << 10) | (psel << 8) | d_knum;
+	req.cmd[2] = param_addr;
+	req.cmd[3] = sig_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Generate an ECC signature.
+ * @param[in]  curve_id      ECC curve ID
+ * @param[in]  psel          Select public key source
+ *                           ECC_KEY_SEL_KS_OTP  : Public key is from Key Store OTP
+ *                           ECC_KEY_SEL_KS_SRAM : Public key is from Key Store SRAM
+ *                           ECC_KEY_SEL_USER    : Public key is from input parameter block
+ * @param[in]  x_knum        The Key Store key number of public key X. Effective only
+ *                           when <psel> is 0x01 or 0x02.
+ * @param[in]  y_knum        The Key Store key number of public key Y. Effective only
+ *                           when <psel> is 0x01 or 0x02.
+ * @param[in]  param_addr    Address of the input parameter block.
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_ECC_VerifySignature(E_ECC_CURVE curve_id, int psel, int x_knum,
+			    int y_knum, uint32_t param_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_ECC_VERIFY_SIG << 16) | curve_id;
+	req.cmd[1] = (psel << 16) | (y_knum << 8) | x_knum;
+	req.cmd[2] = param_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
+
+
+/*
+ * @brief    Execute ECC point multiplication.
+ * @param[in]  curve_id      ECC curve ID
+ * @param[in]  type          Type of multipler k. 0x1: is ECDH key
+ * @param[in]  msel          Select the source of multiplier
+ *                           0x1: Multiplier is from Key Store OTP
+ *                           0x2: Multiplier is from Key Store SRAM
+ *                           0x3: Multiplier is from parameter block
+ * @param[in]  sps           Select the source of input point
+ *                           0x1: Input point is from Key Store OTP
+ *                           0x2: Input point is from Key Store SRAM
+ *                           0x3: Input point is from parameter block
+ * @param[in]  m_knum        The Key Store key number of multiplier.
+ *                            Used only when <ms> is 0x01 or 0x02.
+ * @param[in]  x_knum        The Key Store key number of input point X.
+ *                           Effective only when <msel> is 0x01 or 0x02.
+ * @param[in]  y_knum        The Key Store key number of input point Y.
+ *                           Effective only when <msel> is 0x01 or 0x02.
+ * @param[in]  param_addr    Address of the input parameter block.
+ * @param[in]  dest_addr     Address of the output ECC point.
+ * @return   0               success
+ * @return   otherwise       Refer to ST_XXX error code.
+ */
+int TSI_ECC_Multiply(E_ECC_CURVE curve_id, int type, int msel, int sps,
+		     int m_knum, int x_knum, int y_knum, uint32_t param_addr,
+		     uint32_t dest_addr)
+{
+	TSI_REQ_T req;
+
+	memset(&req, 0, sizeof(req));
+	req.cmd[0] = (CMD_ECC_MULTIPLY << 16) | curve_id;
+	req.cmd[1] = (type << 28) | (msel << 26) | (sps << 24) | (m_knum << 16) |
+			(x_knum << 8) | (y_knum);
+	req.cmd[2] = param_addr;
+	req.cmd[3] = dest_addr;
+	return tsi_send_command_and_wait(&req, CMD_TIME_OUT_2S);
+}
diff --git a/plat/nuvoton/ma35d1/include/ma35d1_crypto.h b/plat/nuvoton/ma35d1/include/ma35d1_crypto.h
new file mode 100644
index 0000000..281a2f9
--- /dev/null
+++ b/plat/nuvoton/ma35d1/include/ma35d1_crypto.h
@@ -0,0 +1,268 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _MA35D1_CRYPTO_H_
+#define _MA35D1_CRYPTO_H_
+
+#define INTEN			(CRYPTO_BASE+0x000)
+#define INTEN_AESIEN			(0x1 << 0)
+#define INTEN_AESEIEN			(0x1 << 1)
+#define INTEN_PRNGIEN			(0x1 << 16)
+#define INTEN_ECCIEN			(0x1 << 22)
+#define INTEN_ECCEIEN			(0x1 << 23)
+#define INTEN_HMACIEN			(0x1 << 24)
+#define INTEN_HMACEIEN			(0x1 << 25)
+#define INTSTS			(CRYPTO_BASE+0x004)
+#define INTSTS_AESIF			(0x1 << 0)
+#define INTSTS_AESEIF			(0x1 << 1)
+#define INTSTS_PRNGIF			(0x1 << 16)
+#define INTSTS_ECCIF			(0x1 << 22)
+#define INTSTS_ECCEIF			(0x1 << 23)
+#define INTSTS_HMACIF			(0x1 << 24)
+#define INTSTS_HMACEIF			(0x1 << 25)
+
+#define PRNG_CTL		(CRYPTO_BASE+0x008)
+#define PRNG_CTL_START			(0x1 << 0)
+#define PRNG_CTL_SEEDRLD		(0x1 << 1)
+#define PRNG_CTL_KEYSZ_OFFSET		(2)
+#define PRNG_CTL_KEYSZ_MASK		(0xf << 2)
+#define PRNG_CTL_BUSY			(0x1 << 8)
+#define PRNG_CTL_SEEDSRC		(0x1 << 16)
+#define PRNG_SEED		(CRYPTO_BASE+0x00C)
+#define PRNG_KEY(x)		(CRYPTO_BASE+0x010 + ((x) * 0x04))
+
+#define AES_FDBCK(x)		(CRYPTO_BASE+0x050 + ((x) * 0x04))
+#define AES_GCM_IVCNT(x)	(CRYPTO_BASE+0x080 + ((x) * 0x04))
+#define AES_GCM_ACNT(x)		(CRYPTO_BASE+0x088 + ((x) * 0x04))
+#define AES_GCM_PCNT(x)		(CRYPTO_BASE+0x090 + ((x) * 0x04))
+#define AES_FBADDR		(CRYPTO_BASE+0x0A0)
+#define AES_CTL			(CRYPTO_BASE+0x100)
+#define AES_CTL_START			(0x1 << 0)
+#define AES_CTL_STOP			(0x1 << 1)
+#define AES_CTL_KEYSZ_OFFSET		2
+#define AES_CTL_KEYSZ_MASK		(0x3 << 2)
+#define AES_CTL_DMALAST			(0x1 << 5)
+#define AES_CTL_DMACSCAD		(0x1 << 6)
+#define AES_CTL_DMAEN			(0x1 << 7)
+#define AES_CTL_OPMODE_OFFSET		8
+#define AES_CTL_OPMODE_MASK		(0xff << 8)
+#define AES_CTL_ENCRPT			(0x1 << 16)
+#define AES_CTL_SM4EN			(0x1 << 17)
+#define AES_CTL_FBIN			(0x1 << 20)
+#define AES_CTL_FBOUT			(0x1 << 21)
+#define AES_CTL_OUTSWAP			(0x1 << 22)
+#define AES_CTL_INSWAP			(0x1 << 23)
+#define AES_CTL_KOUTSWAP		(0x1 << 24)
+#define AES_CTL_KINSWAP			(0x1 << 25)
+#define AES_STS			(CRYPTO_BASE+0x104)
+#define AES_STS_BUSY			(0x1 << 0)
+#define AES_STS_INBUFEMPTY		(0x1 << 8)
+#define AES_STS_INBUFFULL		(0x1 << 9)
+#define AES_STS_INBUFERR		(0x1 << 10)
+#define AES_STS_CNTERR			(0x1 << 12)
+#define AES_STS_OUTBUFEMPTY		(0x1 << 16)
+#define AES_STS_OUTBUFFULL		(0x1 << 17)
+#define AES_STS_OUTBUFERR		(0x1 << 18)
+#define AES_STS_BUSERR			(0x1 << 20)
+#define AES_STS_KSERR			(0x1 << 21)
+#define AES_DATIN		(CRYPTO_BASE+0x108)
+#define AES_DATOUT		(CRYPTO_BASE+0x10C)
+#define AES_KEY(x)		(CRYPTO_BASE+0x110 + ((x) * 0x04))
+#define AES_IV(x)		(CRYPTO_BASE+0x130 + ((x) * 0x04))
+#define AES_SADDR		(CRYPTO_BASE+0x140)
+#define AES_DADDR		(CRYPTO_BASE+0x144)
+#define AES_CNT			(CRYPTO_BASE+0x148)
+
+#define HMAC_CTL		(CRYPTO_BASE+0x300)
+#define HMAC_CTL_START			(0x1 << 0)
+#define HMAC_CTL_STOP			(0x1 << 1)
+#define HMAC_CTL_DMAFIRST		(0x1 << 4)
+#define HMAC_CTL_DMALAST		(0x1 << 5)
+#define HMAC_CTL_DMACSCAD		(0x1 << 6)
+#define HMAC_CTL_DMAEN			(0x1 << 7)
+#define HMAC_CTL_OPMODE_OFFSET		8
+#define HMAC_CTL_OPMODE_MASK		(0x7 << 8)
+#define HMAC_CTL_HMACEN			(0x1 << 11)
+#define HMAC_CTL_SHA3EN			(0x1 << 12)
+#define HMAC_CTL_SM3EN			(0x1 << 13)
+#define HMAC_CTL_MD5EN			(0x1 << 14)
+#define HMAC_CTL_FBIN			(0x1 << 20)
+#define HMAC_CTL_FBOUT			(0x1 << 21)
+#define HMAC_CTL_OUTSWAP		(0x1 << 22)
+#define HMAC_CTL_INSWAP			(0x1 << 23)
+#define HMAC_CTL_NEXTDGST		(0x1 << 24)
+#define HMAC_CTL_FINISHDGST		(0x1 << 25)
+#define HMAC_STS		(CRYPTO_BASE+0x304)
+#define HMAC_STS_BUSY			(0x1 << 0)
+#define HMAC_STS_DMABUSY		(0x1 << 1)
+#define HMAC_STS_SHAKEBUSY		(0x1 << 2)
+#define HMAC_STS_DMAERR			(0x1 << 8)
+#define HMAC_STS_KSERR			(0x1 << 9)
+#define HMAC_STS_DATINREQ		(0x1 << 16)
+#define HMAC_DGST(x)		(CRYPTO_BASE+0x308 + ((x) * 0x04))
+#define HMAC_KEYCNT		(CRYPTO_BASE+0x348)
+#define HMAC_SADDR		(CRYPTO_BASE+0x34C)
+#define HMAC_DMACNT		(CRYPTO_BASE+0x350)
+#define HMAC_DATIN		(CRYPTO_BASE+0x354)
+#define HMAC_FDBCK(x)		(CRYPTO_BASE+0x358 + ((x) * 0x04))
+#define HMAC_FDBCK_WCNT			88
+#define HMAC_FBADDR		(CRYPTO_BASE+0x4FC)
+#define HMAC_SHAKEDGST(x)	(CRYPTO_BASE+0x500 + ((x) * 0x04))
+#define HMAC_SHAKEDGST_WCNT		42
+
+#define ECC_CTL			(CRYPTO_BASE+0x800)
+#define ECC_CTL_START			(0x1 << 0)
+#define ECC_CTL_STOP			(0x1 << 1)
+#define ECC_CTL_ECDSAS			(0x1 << 4)
+#define ECC_CTL_ECDSAR			(0x1 << 5)
+#define ECC_CTL_DMAEN			(0x1 << 7)
+#define ECC_CTL_FSEL			(0x1 << 8)
+#define ECC_CTL_ECCOP_OFFSET		9
+#define ECC_CTL_ECCOP_MASK		(0x3 << 9)
+#define ECC_CTL_MODOP_OFFSET		11
+#define ECC_CTL_MODOP_MASK		(0x3 << 9)
+#define ECC_CTL_CSEL			(0x1 << 13)
+#define ECC_CTL_SCAP			(0x1 << 14)
+#define ECC_CTL_LDAP1			(0x1 << 16)
+#define ECC_CTL_LDAP2			(0x1 << 17)
+#define ECC_CTL_LDA			(0x1 << 18)
+#define ECC_CTL_LDB			(0x1 << 19)
+#define ECC_CTL_LDN			(0x1 << 20)
+#define ECC_CTL_LDK			(0x1 << 21)
+#define ECC_CTL_CURVEM_OFFSET		22
+#define ECC_CTL_CURVEM_MASK		(0x3ff << 22)
+#define ECC_STS			(CRYPTO_BASE+0x804)
+#define ECC_STS_BUSY			(0x1 << 0)
+#define ECC_STS_DMABUSY			(0x1 << 1)
+#define ECC_STS_BUSERR			(0x1 << 16)
+#define ECC_STS_KSERR			(0x1 << 17)
+#define ECC_X1(x)		(CRYPTO_BASE+0x808 + ((x) * 0x04))
+#define ECC_Y1(x)		(CRYPTO_BASE+0x850 + ((x) * 0x04))
+#define ECC_X2(x)		(CRYPTO_BASE+0x898 + ((x) * 0x04))
+#define ECC_Y2(x)		(CRYPTO_BASE+0x8E0 + ((x) * 0x04))
+#define ECC_A(x)		(CRYPTO_BASE+0x928 + ((x) * 0x04))
+#define ECC_B(x)		(CRYPTO_BASE+0x970 + ((x) * 0x04))
+#define ECC_N(x)		(CRYPTO_BASE+0x9B8 + ((x) * 0x04))
+#define ECC_K(x)		(CRYPTO_BASE+0xA00 + ((x) * 0x04))
+#define ECC_KEY_WCNT			18
+#define ECC_SADDR		(CRYPTO_BASE+0xA48)
+#define ECC_DADDR		(CRYPTO_BASE+0xA4C)
+#define ECC_STARTREG		(CRYPTO_BASE+0xA50)
+#define ECC_WORDCNT		(CRYPTO_BASE+0xA54)
+
+#define AES_KSCTL		(CRYPTO_BASE+0xF10)
+#define AES_KSCTL_NUM_OFFSET		0
+#define AES_KSCTL_NUM_MASK		(0x1f << 0)
+#define AES_KSCTL_RSRC			(0x1 << 5)
+#define AES_KSCTL_RSSRC_OFFSET		6
+#define AES_KSCTL_RSSRC_MASK		(0x3 << 6)
+
+#define ECC_KSCTL		(CRYPTO_BASE+0xF40)
+#define ECC_KSCTL_NUMK_OFFSET		0
+#define ECC_KSCTL_NUMK_MASK		(0x1f << 0)
+#define ECC_KSCTL_RSRCK			(0x1 << 5)
+#define ECC_KSCTL_RSSRCK_OFFSET		6
+#define ECC_KSCTL_RSSRCK_MASK		(0x3 << 6)
+#define ECC_KSCTL_TRUST			(0x1 << 16)
+#define ECC_KSCTL_PRIV			(0x1 << 18)
+#define ECC_KSCTL_XY			(0x1 << 20)
+#define ECC_KSCTL_WDST			(0x1 << 21)
+#define ECC_KSCTL_WSDST_OFFSET		22
+#define ECC_KSCTL_WSDST_MASK		(0x3 << 22)
+#define ECC_KSCTL_OWNER_OFFSET		24
+#define ECC_KSCTL_OWNER_MASK		(0x7 << 24)
+#define ECC_KSSTS		0xF44
+#define ECC_KSSTS_NUM_OFFSET		0
+#define ECC_KSSTS_NUM_MASK		(0x1f << 0)
+#define ECC_KSXY			0xF48
+#define ECC_KSXY_NUMX_OFFSET		0
+#define ECC_KSXY_NUMX_MASK		(0x1f << 0)
+#define ECC_KSXY_RSRCXY			(0x1 << 5)
+#define ECC_KSXY_RSSRCX_OFFSET		6
+#define ECC_KSXY_RSSRCX_MASK		(0x3 << 6)
+#define ECC_KSXY_NUMY_OFFSET		8
+#define ECC_KSXY_NUMY_MASK		(0x1f << 8)
+#define ECC_KSXY_RSSRCY_OFFSET		14
+#define ECC_KSXY_RSSRCY_MASK		(0x3 << 14)
+
+
+
+#define AES_KEYSZ_SEL_128       (0x0 << AES_CTL_KEYSZ_OFFSET)
+#define AES_KEYSZ_SEL_192       (0x1 << AES_CTL_KEYSZ_OFFSET)
+#define AES_KEYSZ_SEL_256       (0x2 << AES_CTL_KEYSZ_OFFSET)
+
+#define AES_MODE_ECB            (0x00 << AES_CTL_OPMODE_OFFSET)
+#define AES_MODE_CBC            (0x01 << AES_CTL_OPMODE_OFFSET)
+#define AES_MODE_CFB            (0x02 << AES_CTL_OPMODE_OFFSET)
+#define AES_MODE_OFB            (0x03 << AES_CTL_OPMODE_OFFSET)
+#define AES_MODE_CTR            (0x04 << AES_CTL_OPMODE_OFFSET)
+#define AES_MODE_CBC_CS1        (0x10 << AES_CTL_OPMODE_OFFSET)
+#define AES_MODE_CBC_CS2        (0x11 << AES_CTL_OPMODE_OFFSET)
+#define AES_MODE_CBC_CS3        (0x12 << AES_CTL_OPMODE_OFFSET)
+#define AES_MODE_GCM            (0x20 << AES_CTL_OPMODE_OFFSET)
+#define AES_MODE_GHASH          (0x21 << AES_CTL_OPMODE_OFFSET)
+#define AES_MODE_CCM            (0x22 << AES_CTL_OPMODE_OFFSET)
+
+#define SHA_OPMODE_SHA1		(0x0 << HMAC_CTL_OPMODE_OFFSET)
+#define SHA_OPMODE_SHA224	(0x5 << HMAC_CTL_OPMODE_OFFSET)
+#define SHA_OPMODE_SHA256	(0x4 << HMAC_CTL_OPMODE_OFFSET)
+#define SHA_OPMODE_SHA384	(0x7 << HMAC_CTL_OPMODE_OFFSET)
+#define SHA_OPMODE_SHA512	(0x6 << HMAC_CTL_OPMODE_OFFSET)
+#define SHA_OPMODE_SHAKE128	(0x0 << HMAC_CTL_OPMODE_OFFSET)
+#define SHA_OPMODE_SHAKE256	(0x1 << HMAC_CTL_OPMODE_OFFSET)
+
+#define ECCOP_POINT_MUL		(0x0 << ECC_CTL_ECCOP_OFFSET)
+#define ECCOP_MODULE		(0x1 << ECC_CTL_ECCOP_OFFSET)
+#define ECCOP_POINT_ADD		(0x2 << ECC_CTL_ECCOP_OFFSET)
+#define ECCOP_POINT_DOUBLE	(0x3 << ECC_CTL_ECCOP_OFFSET)
+
+#define MODOP_DIV		(0x0 << ECC_CTL_MODOP_OFFSET)
+#define MODOP_MUL		(0x1 << ECC_CTL_MODOP_OFFSET)
+#define MODOP_ADD		(0x2 << ECC_CTL_MODOP_OFFSET)
+#define MODOP_SUB		(0x3 << ECC_CTL_MODOP_OFFSET)
+
+#define AES_BUFF_SIZE		(PAGE_SIZE)
+#define SHA_BUFF_SIZE		(PAGE_SIZE)
+#define SHA_FDBCK_SIZE		(HMAC_FDBCK_WCNT * 4)
+
+#define AES_KEY_SIZE_128	0UL
+#define AES_KEY_SIZE_192	1UL
+#define AES_KEY_SIZE_256	2UL
+
+
+typedef enum {
+	CURVE_P_192  = 0x01,
+	CURVE_P_224  = 0x02,
+	CURVE_P_256  = 0x03,
+	CURVE_P_384  = 0x04,
+	CURVE_P_521  = 0x05,
+	CURVE_K_163  = 0x11,
+	CURVE_K_233  = 0x12,
+	CURVE_K_283  = 0x13,
+	CURVE_K_409  = 0x14,
+	CURVE_K_571  = 0x15,
+	CURVE_B_163  = 0x21,
+	CURVE_B_233  = 0x22,
+	CURVE_B_283  = 0x23,
+	CURVE_B_409  = 0x24,
+	CURVE_B_571  = 0x25,
+	CURVE_KO_192 = 0x31,
+	CURVE_KO_224 = 0x32,
+	CURVE_KO_256 = 0x33,
+	CURVE_BP_256 = 0x41,
+	CURVE_BP_384 = 0x42,
+	CURVE_BP_512 = 0x43,
+	CURVE_SM2_256 = 0x50,
+	CURVE_25519  = 0x51,
+	CURVE_UNDEF,
+} E_ECC_CURVE;
+
+enum {
+	CURVE_GF_P,
+	CURVE_GF_2M,
+};
+
+#endif /* _MA35D1_CRYPTO_H_ */
diff --git a/plat/nuvoton/ma35d1/include/ma35d1_sip_svc.h b/plat/nuvoton/ma35d1/include/ma35d1_sip_svc.h
new file mode 100644
index 0000000..8d1793f
--- /dev/null
+++ b/plat/nuvoton/ma35d1/include/ma35d1_sip_svc.h
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2021 Nuvoton Technology Corp.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MA35D1_SIP_SVC_H
+#define MA35D1_SIP_SVC_H
+
+/* SMC function IDs for SiP Service queries */
+#define SIP_SVC_PMIC			0xC2000008
+#define SIP_CPU_CLK			0xC2000009
+#define SIP_SET_EPLL			0xC200000A
+#define SIP_LOW_SPEED			0xC200000B
+#define SIP_SVC_VERSION			0xC200000F
+
+/* MA35D1 SiP Service Calls PLL setting */
+#define NVT_SIP_SVC_EPLL_DIV_BY_2	0x2
+#define NVT_SIP_SVC_EPLL_DIV_BY_4	0x4
+#define NVT_SIP_SVC_EPLL_DIV_BY_8	0x8
+#define NVT_SIP_SVC_EPLL_RESTORE	0xF
+
+/* MA35D1 SiP Service Calls version numbers */
+#define NVT_SIP_SVC_VERSION_MAJOR	0x0
+#define NVT_SIP_SVC_VERSION_MINOR	0x1
+
+/* Number of MA35D1 SiP Calls implemented */
+#define NVT_COMMON_SIP_NUM_CALLS	0x3
+
+enum {
+	RK_SIP_E_SUCCESS = 0,
+	RK_SIP_E_INVALID_PARAM = -1
+};
+
+#endif /* MA35D1_SIP_SVC_H */
diff --git a/plat/nuvoton/ma35d1/include/plat_macros.S b/plat/nuvoton/ma35d1/include/plat_macros.S
new file mode 100644
index 0000000..558df0b
--- /dev/null
+++ b/plat/nuvoton/ma35d1/include/plat_macros.S
@@ -0,0 +1,27 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef PLAT_MACROS_S
+#define PLAT_MACROS_S
+
+#include <arm_macros.S>
+#include <platform_def.h>
+
+	/* ---------------------------------------------
+	 * The below required platform porting macro
+	 * prints out relevant GIC registers whenever an
+	 * unhandled exception is taken in BL31.
+	 * Clobbers: x0 - x10, x16, x17, sp
+	 * ---------------------------------------------
+	 */
+	.macro plat_crash_print_regs
+
+	/* Assume Base Cortex mmap */
+	mov_imm	x17, BASE_GICC_BASE
+	mov_imm	x16, BASE_GICD_BASE
+	arm_print_gic_regs
+	.endm
+
+#endif /* PLAT_MACROS_S */
diff --git a/plat/nuvoton/ma35d1/include/platform_def.h b/plat/nuvoton/ma35d1/include/platform_def.h
new file mode 100644
index 0000000..db7e050
--- /dev/null
+++ b/plat/nuvoton/ma35d1/include/platform_def.h
@@ -0,0 +1,251 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef PLATFORM_DEF_H
+#define PLATFORM_DEF_H
+
+#include <drivers/arm/tzc400.h>
+#include <lib/utils_def.h>
+#include <plat/arm/board/common/v2m_def.h>
+//#include <plat/arm/common/arm_def.h>
+#include <plat/arm/common/smccc_def.h>
+#include <plat/arm/common/arm_spm_def.h>
+#include <plat/common/common_def.h>
+
+#include "../ma35d1_def.h"
+
+/**************************************************/
+/*
+ * The max number of regions like RO(code), coherent and data required by
+ * different BL stages which need to be mapped in the MMU.
+ */
+#define ARM_BL_REGIONS			5
+
+#define MAX_MMAP_REGIONS		(PLAT_ARM_MMAP_ENTRIES +	\
+					 ARM_BL_REGIONS)
+
+/*******************************************************************************
+ * System counter frequency related constants
+ ******************************************************************************/
+#define SYS_COUNTER_FREQ_IN_TICKS	12000000
+#define SYS_COUNTER_FREQ_IN_MHZ		(SYS_COUNTER_FREQ_IN_TICKS/1000000)
+
+#define ARM_CONSOLE_BAUDRATE		115200
+
+/*
+ * Secure Interrupt: based on the standard ARM mapping
+ */
+#define ARM_IRQ_SEC_PHY_TIMER		U(29)
+
+#define ARM_IRQ_SEC_SGI_0		U(8)
+#define ARM_IRQ_SEC_SGI_1		U(9)
+#define ARM_IRQ_SEC_SGI_2		U(10)
+#define ARM_IRQ_SEC_SGI_3		U(11)
+#define ARM_IRQ_SEC_SGI_4		U(12)
+#define ARM_IRQ_SEC_SGI_5		U(13)
+#define ARM_IRQ_SEC_SGI_6		U(14)
+#define ARM_IRQ_SEC_SGI_7		U(15)
+
+
+/*
+ * Define a list of Group 1 Secure and Group 0 interrupt properties as per GICv3
+ * terminology. On a GICv2 system or mode, the lists will be merged and treated
+ * as Group 0 interrupts.
+ */
+#define ARM_G1S_IRQ_PROPS(grp) \
+	INTR_PROP_DESC(ARM_IRQ_SEC_PHY_TIMER, GIC_HIGHEST_SEC_PRIORITY, (grp), \
+			GIC_INTR_CFG_LEVEL), \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_1, GIC_HIGHEST_SEC_PRIORITY, (grp), \
+			GIC_INTR_CFG_EDGE), \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_2, GIC_HIGHEST_SEC_PRIORITY, (grp), \
+			GIC_INTR_CFG_EDGE), \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_3, GIC_HIGHEST_SEC_PRIORITY, (grp), \
+			GIC_INTR_CFG_EDGE), \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_4, GIC_HIGHEST_SEC_PRIORITY, (grp), \
+			GIC_INTR_CFG_EDGE), \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_5, GIC_HIGHEST_SEC_PRIORITY, (grp), \
+			GIC_INTR_CFG_EDGE), \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_7, GIC_HIGHEST_SEC_PRIORITY, (grp), \
+			GIC_INTR_CFG_EDGE)
+
+#define ARM_G0_IRQ_PROPS(grp) \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_0, PLAT_SDEI_NORMAL_PRI, (grp), \
+			GIC_INTR_CFG_EDGE), \
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_6, GIC_HIGHEST_SEC_PRIORITY, (grp), \
+			GIC_INTR_CFG_EDGE)
+
+
+/* Special value used to verify platform parameters from BL2 to BL31 */
+#define ARM_BL31_PLAT_PARAM_VAL		ULL(0x0f1e2d3c4b5a6978)
+
+#define ARM_CACHE_WRITEBACK_SHIFT	6
+
+/*
+ * Macros mapping the MPIDR Affinity levels to ARM Platform Power levels. The
+ * power levels have a 1:1 mapping with the MPIDR affinity levels.
+ */
+#define ARM_PWR_LVL0		MPIDR_AFFLVL0
+#define ARM_PWR_LVL1		MPIDR_AFFLVL1
+#define ARM_PWR_LVL2		MPIDR_AFFLVL2
+#define ARM_PWR_LVL3		MPIDR_AFFLVL3
+
+/*
+ *  Macros for local power states in ARM platforms encoded by State-ID field
+ *  within the power-state parameter.
+ */
+/* Local power state for power domains in Run state. */
+#define ARM_LOCAL_STATE_RUN	U(0)
+/* Local power state for retention. Valid only for CPU power domains */
+#define ARM_LOCAL_STATE_RET	U(1)
+/* Local power state for OFF/power-down. Valid for CPU and cluster power domains */
+#define ARM_LOCAL_STATE_OFF	U(2)
+
+/* The first 4KB of Trusted SRAM are used as shared memory */
+#define ARM_TRUSTED_SRAM_BASE		UL(0x28000000)
+#define ARM_SHARED_RAM_BASE		ARM_TRUSTED_SRAM_BASE
+#define ARM_SHARED_RAM_SIZE		UL(0x00001000)	/* 4 KB */
+
+/* The remaining Trusted SRAM is used to load the BL images */
+#define ARM_BL_RAM_BASE			(ARM_SHARED_RAM_BASE +	\
+					 ARM_SHARED_RAM_SIZE)
+#define ARM_BL_RAM_SIZE			(PLAT_ARM_TRUSTED_SRAM_SIZE -	\
+					 ARM_SHARED_RAM_SIZE)
+
+/*
+ * Some data must be aligned on the biggest cache line size in the platform.
+ * This is known only to the platform as it might have a combination of
+ * integrated and external caches.
+ */
+#define CACHE_WRITEBACK_GRANULE		(U(1) << ARM_CACHE_WRITEBACK_SHIFT)
+
+#define ARM_MAP_BL_RO			MAP_REGION_FLAT(			\
+						BL_CODE_BASE,			\
+						BL_CODE_END - BL_CODE_BASE,	\
+						MT_CODE | MT_SECURE)
+
+/* Priority levels for ARM platforms */
+#define PLAT_RAS_PRI			0x10
+#define PLAT_SDEI_CRITICAL_PRI		0x60
+#define PLAT_SDEI_NORMAL_PRI		0x70
+
+
+/**************************************************/
+
+/* Required platform porting definitions */
+#define PLATFORM_MAX_CPUS_PER_CLUSTER	U(2)
+#define PLATFORM_CLUSTER_COUNT		U(1)
+#define PLATFORM_CLUSTER0_CORE_COUNT	PLATFORM_MAX_CPUS_PER_CLUSTER
+
+#define PLATFORM_CORE_COUNT		PLATFORM_CLUSTER0_CORE_COUNT
+
+#define PLAT_NUM_PWR_DOMAINS		(PLATFORM_CLUSTER_COUNT + \
+					PLATFORM_CORE_COUNT + 1)
+#define PLAT_MAX_PWR_LVL		MPIDR_AFFLVL2
+#define PLAT_MAX_RET_STATE		1
+#define PLAT_MAX_OFF_STATE		2
+
+/*
+ * Other platform porting definitions are provided by included headers
+ */
+
+/*
+ * Required ARM standard platform porting definitions
+ */
+#define PLAT_ARM_CLUSTER_COUNT		MA35D1_CLUSTER_COUNT
+
+#define PLAT_ARM_TRUSTED_SRAM_SIZE	UL(0x00040000)	/* 256 KB */
+
+/*
+ * Load address of BL33 for this platform port
+ */
+#define PLAT_ARM_NS_IMAGE_BASE		UL(0x80000000)	/* TBD */
+
+/*
+ * PLAT_ARM_MMAP_ENTRIES depends on the number of entries in the
+ * plat_arm_mmap array defined for each BL stage.
+ */
+#define PLAT_ARM_MMAP_ENTRIES		8
+#define MAX_XLAT_TABLES			5
+
+
+/*
+ * Size of cacheable stacks
+ */
+#if defined(IMAGE_BL2)
+# if TRUSTED_BOARD_BOOT
+#  define PLATFORM_STACK_SIZE		UL(0x1000)
+# else
+#  define PLATFORM_STACK_SIZE		UL(0x400)
+# endif
+#elif defined(IMAGE_BL31)
+#  define PLATFORM_STACK_SIZE		UL(0x800)
+#elif defined(IMAGE_BL32)
+# define PLATFORM_STACK_SIZE		UL(0x440)
+#endif
+
+
+#define PLAT_ARM_CRASH_UART_BASE	UL(0x40700000)
+#define PLAT_ARM_CRASH_UART_CLK_IN_HZ	UL(24000000)
+
+/* System timer related constants */
+#define PLAT_ARM_NSTIMER_FRAME_ID		U(1)
+
+/* Mailbox base address */
+#define PLAT_ARM_TRUSTED_MAILBOX_BASE	ARM_TRUSTED_SRAM_BASE
+
+
+/* TrustZone controller related constants
+ */
+#define PLAT_ARM_TZC_BASE		UL(0x404E1000)
+#define PLAT_ARM_TZC_FILTERS		TZC_400_REGION_ATTR_FILTER_BIT(0)
+
+#define PLAT_ARM_TZC_NS_DEV_ACCESS	(				\
+		TZC_REGION_ACCESS_RDWR(MA35D1_NSAID_TZNS)	|	\
+		TZC_REGION_ACCESS_RDWR(MA35D1_NSAID_SUBM))
+
+/*
+ * GIC related constants to cater for both GICv2 and GICv3 instances of an
+ * MA35D1. They could be overriden at runtime in case the MA35D1 implements the legacy
+ * VE memory map.
+ */
+#define PLAT_ARM_GICD_BASE		BASE_GICD_BASE
+#define PLAT_ARM_GICR_BASE		BASE_GICR_BASE
+#define PLAT_ARM_GICC_BASE		BASE_GICC_BASE
+
+/*
+ * Define a list of Group 1 Secure and Group 0 interrupts as per GICv3
+ * terminology. On a GICv2 system or mode, the lists will be merged and treated
+ * as Group 0 interrupts.
+ */
+#define PLAT_ARM_G1S_IRQ_PROPS(grp) \
+	ARM_G1S_IRQ_PROPS(grp), \
+	INTR_PROP_DESC(MA35D1_IRQ_TZ_WDOG, GIC_HIGHEST_SEC_PRIORITY, (grp), \
+			GIC_INTR_CFG_LEVEL), \
+	INTR_PROP_DESC(MA35D1_IRQ_SEC_SYS_TIMER, GIC_HIGHEST_SEC_PRIORITY, (grp), \
+			GIC_INTR_CFG_LEVEL)
+
+#define PLAT_ARM_G0_IRQ_PROPS(grp)	ARM_G0_IRQ_PROPS(grp)
+
+#define PLAT_ARM_PRIVATE_SDEI_EVENTS	ARM_SDEI_PRIVATE_EVENTS
+#define PLAT_ARM_SHARED_SDEI_EVENTS	ARM_SDEI_SHARED_EVENTS
+
+#define PLAT_ARM_SP_IMAGE_STACK_BASE	(PLAT_SP_IMAGE_NS_BUF_BASE +	\
+					 PLAT_SP_IMAGE_NS_BUF_SIZE)
+
+#define PLAT_SP_PRI			PLAT_RAS_PRI
+
+/*
+ * Physical and virtual address space limits for MMU in AARCH64 & AARCH32 modes
+ */
+#ifdef __aarch64__
+#define PLAT_PHY_ADDR_SPACE_SIZE	(1ULL << 36)
+#define PLAT_VIRT_ADDR_SPACE_SIZE	(1ULL << 36)
+#else
+#define PLAT_PHY_ADDR_SPACE_SIZE	(1ULL << 32)
+#define PLAT_VIRT_ADDR_SPACE_SIZE	(1ULL << 32)
+#endif
+
+#endif /* PLATFORM_DEF_H */
diff --git a/plat/nuvoton/ma35d1/include/sspcc.h b/plat/nuvoton/ma35d1/include/sspcc.h
new file mode 100644
index 0000000..26b41e8
--- /dev/null
+++ b/plat/nuvoton/ma35d1/include/sspcc.h
@@ -0,0 +1,852 @@
+/*
+ * Copyright (c) 2020, Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __SSPCC_H__
+#define __SSPCC_H__
+
+#define PDMA0_TZS	0	16	0
+#define PDMA0_TZNS	0	16	1
+#define PDMA1_TZS	0	18	0
+#define PDMA1_TZNS	0	18	1
+#define PDMA2_TZNS	0	20	1
+#define PDMA2_SUBM	0	20	3
+#define PDMA3_TZNS	0	22	1
+#define PDMA3_SUBM	0	22	3
+
+#define EBI_TZNS	4	0	1
+#define EBI_SUBM	4	0	3
+#define SDH0_TZS	4	16	0
+#define SDH0_TZNS	4	16	1
+#define SDH1_TZS	4	18	0
+#define SDH1_TZNS	4	18	1
+#define NAND_TZS	4	20	0
+#define NAND_TZNS	4	20	1
+
+#define HSUSBD_TZS	8	0	0
+#define HSUSBD_TZNS	8	0	1
+#define MCAN0_TZNS	8	24	1
+#define MCAN0_SUBM	8	24	3
+#define MCAN1_TZNS	8	28	1
+#define MCAN1_SUBM	8	28	3
+
+#define CRYPTO_TZS	12	0	0
+#define CRYPTO_TZNS	12	0	1
+#define MCAN2_TZNS	12	24	1
+#define MCAN2_SUBM	12	24	3
+#define MCAN3_TZNS	12	28	1
+#define MCAN3_SUBM	12	28	3
+
+#define ADC0_TZNS	16	4	1
+#define ADC0_SUBM	16	4	3
+#define EADC_TZNS	16	6	1
+#define EADC_SUBM	16	6	3
+#define WDTWWDT1_TZS	16	8	0
+#define WDTWWDT1_TZNS	16	8	1
+#define I2S0_TZNS	16	16	1
+#define I2S0_SUBM	16	16	3
+#define I2S1_TZNS	16	18	1
+#define I2S1_SUBM	16	18	3
+#define KPI_TZNS	16	20	1
+#define KPI_SUBM	16	20	3
+#define DDRPHY_TZS	16	24	0
+#define DDRPHY_TZNS	16	24	1
+#define MCTL_TZS	16	26	0
+#define MCTL_TZNS	16	26	1
+
+#define TIMER01_TZS	20	0	0
+#define TIMER01_TZNS	20	0	1
+#define TIMER23_TZNS	20	2	1
+#define TIMER23_SUBM	20	2	3
+#define TIMER45_TZNS	20	4	1
+#define TIMER45_SUBM	20	4	3
+#define TIMER67_TZNS	20	6	1
+#define TIMER67_SUBM	20	6	3
+#define TIMER89_TZNS	20	8	1
+#define TIMER89_SUBM	20	8	3
+#define TIMER1011_TZNS	20	10	1
+#define TIMER1011_SUBM	20	10	3
+#define EPWM0_TZNS	20	16	1
+#define EPWM0_SUBM	20	16	3
+#define EPWM1_TZNS	20	18	1
+#define EPWM1_SUBM	20	18	3
+#define EPWM2_TZNS	20	20	1
+#define EPWM3_SUBM	20	20	3
+
+#define SPI0_TZNS	24	0	1
+#define SPI0_SUBM	24	0	3
+#define SPI1_TZNS	24	2	1
+#define SPI1_SUBM	24	2	3
+#define SPI2_TZNS	24	4	1
+#define SPI2_SUBM	24	4	3
+#define SPI3_TZNS	24	6	1
+#define SPI3_SUBM	24	6	3
+#define QSPI0_TZS	24	16	0
+#define QSPI0_TZNS	24	16	1
+#define QSPI1_TZNS	24	18	1
+#define QSPI1_SUBM	24	18	3
+
+#define UART0_TZS	28	0	0
+#define UART0_TZNS	28	0	1
+#define UART1_TZNS	28	2	1
+#define UART1_SUBM	28	2	3
+#define UART2_TZNS	28	4	1
+#define UART2_SUBM	28	4	3
+#define UART3_TZNS	28	6	1
+#define UART3_SUBM	28	6	3
+#define UART4_TZNS	28	8	1
+#define UART4_SUBM	28	8	3
+#define UART5_TZNS	28	10	1
+#define UART5_SUBM	28	10	3
+#define UART6_TZNS	28	12	1
+#define UART6_SUBM	28	12	3
+#define UART7_TZNS	28	14	1
+#define UART7_SUBM	28	14	3
+#define UART8_TZNS	28	16	1
+#define UART8_SUBM	28	16	3
+#define UART9_TZNS	28	18	1
+#define UART9_SUBM	28	18	3
+#define UART10_TZNS	28	20	1
+#define UART10_SUBM	28	20	3
+#define UART11_TZNS	28	22	1
+#define UART11_SUBM	28	22	3
+#define UART12_TZNS	28	24	1
+#define UART12_SUBM	28	24	3
+#define UART13_TZNS	28	26	1
+#define UART13_SUBM	28	26	3
+#define UART14_TZNS	28	28	1
+#define UART14_SUBM	28	28	3
+#define UART15_TZNS	28	30	1
+#define UART15_SUBM	28	30	3
+
+#define I2C0_TZS	32	0	0
+#define I2C0_TZNS	32	0	1
+#define I2C1_TZNS	32	2	1
+#define I2C1_SUBM	32	2	3
+#define I2C2_TZNS	32	4	1
+#define I2C2_SUBM	32	4	3
+#define I2C3_TZNS	32	6	1
+#define I2C3_SUBM	32	6	3
+#define I2C4_TZNS	32	8	1
+#define I2C4_SUBM	32	8	3
+#define I2C5_TZNS	32	10	1
+#define I2C5_SUBM	32	10	3
+#define UART16_TZNS	32	16	1
+#define UART16_SUBM	32	16	3
+
+#define SC0_TZNS	36	0	1
+#define SC0_SUBM	36	0	3
+#define SC1_TZNS	36	2	1
+#define SC1_SUBM	36	2	3
+
+#define QEI0_TZNS	44	0	1
+#define QEI0_SUBM	44	0	3
+#define QEI1_TZNS	44	2	1
+#define QEI1_SUBM	44	2	3
+#define QEI2_TZNS	44	4	1
+#define QEI2_SUBM	44	4	3
+#define ECAP0_TZNS	44	8	1
+#define ECAP0_SUBM	44	8	3
+#define ECAP1_TZNS	44	10	1
+#define ECAP1_SUBM	44	10	3
+#define ECAP2_TZNS	44	12	1
+#define ECAP2_SUBM	44	12	3
+#define TRNG_TZS	44	18	0
+#define TRNG_TZNS	44	18	1
+
+#define EBI0_NS		80	0	1
+#define EBI0_SUBM	80	0	3
+#define EBI1_NS		80	2	1
+#define EBI1_SUBM	80	2	3
+#define EBI2_NS		80	4	1
+#define EBI2_SUBM	80	4	3
+
+#define PA0_S		96	0	0
+#define PA0_NS		96	0	1
+#define PA0_SUBM	96	0	3
+#define PA1_S		96	2	0
+#define PA1_NS		96	2	1
+#define PA1_SUBM	96	2	3
+#define PA2_S		96	4	0
+#define PA2_NS		96	4	1
+#define PA2_SUBM	96	4	3
+#define PA3_S		96	6	0
+#define PA3_NS		96	6	1
+#define PA3_SUBM	96	6	3
+#define PA4_S		96	8	0
+#define PA4_NS		96	8	1
+#define PA4_SUBM	96	8	3
+#define PA5_S		96	10	0
+#define PA5_NS		96	10	1
+#define PA5_SUBM	96	10	3
+#define PA6_S		96	12	0
+#define PA6_NS		96	12	1
+#define PA6_SUBM	96	12	3
+#define PA7_S		96	14	0
+#define PA7_NS		96	14	1
+#define PA7_SUBM	96	14	3
+#define PA8_S		96	16	0
+#define PA8_NS		96	16	1
+#define PA8_SUBM	96	16	3
+#define PA9_S		96	18	0
+#define PA9_NS		96	18	1
+#define PA9_SUBM	96	18	3
+#define PA10_S		96	20	0
+#define PA10_NS		96	20	1
+#define PA10_SUBM	96	20	3
+#define PA11_S		96	22	0
+#define PA11_NS		96	22	1
+#define PA11_SUBM	96	22	3
+#define PA12_S		96	24	0
+#define PA12_NS		96	24	1
+#define PA12_SUBM	96	24	3
+#define PA13_S		96	26	0
+#define PA13_NS		96	26	1
+#define PA13_SUBM	96	26	3
+#define PA14_S		96	28	0
+#define PA14_NS		96	28	1
+#define PA14_SUBM	96	28	3
+#define PA15_S		96	30	0
+#define PA15_NS		96	30	1
+#define PA15_SUBM	96	30	3
+
+#define PB0_S		100	0	0
+#define PB0_NS		100	0	1
+#define PB0_SUBM	100	0	3
+#define PB1_S		100	2	0
+#define PB1_NS		100	2	1
+#define PB1_SUBM	100	2	3
+#define PB2_S		100	4	0
+#define PB2_NS		100	4	1
+#define PB2_SUBM	100	4	3
+#define PB3_S		100	6	0
+#define PB3_NS		100	6	1
+#define PB3_SUBM	100	6	3
+#define PB4_S		100	8	0
+#define PB4_NS		100	8	1
+#define PB4_SUBM	100	8	3
+#define PB5_S		100	10	0
+#define PB5_NS		100	10	1
+#define PB5_SUBM	100	10	3
+#define PB6_S		100	12	0
+#define PB6_NS		100	12	1
+#define PB6_SUBM	100	12	3
+#define PB7_S		100	14	0
+#define PB7_NS		100	14	1
+#define PB7_SUBM	100	14	3
+#define PB8_S		100	16	0
+#define PB8_NS		100	16	1
+#define PB8_SUBM	100	16	3
+#define PB9_S		100	18	0
+#define PB9_NS		100	18	1
+#define PB9_SUBM	100	18	3
+#define PB10_S		100	20	0
+#define PB10_NS		100	20	1
+#define PB10_SUBM	100	20	3
+#define PB11_S		100	22	0
+#define PB11_NS		100	22	1
+#define PB11_SUBM	100	22	3
+#define PB12_S		100	24	0
+#define PB12_NS		100	24	1
+#define PB12_SUBM	100	24	3
+#define PB13_S		100	26	0
+#define PB13_NS		100	26	1
+#define PB13_SUBM	100	26	3
+#define PB14_S		100	28	0
+#define PB14_NS		100	28	1
+#define PB14_SUBM	100	28	3
+#define PB15_S		100	30	0
+#define PB15_NS		100	30	1
+#define PB15_SUBM	100	30	3
+
+#define PC0_S		104	0	0
+#define PC0_NS		104	0	1
+#define PC0_SUBM	104	0	3
+#define PC1_S		104	2	0
+#define PC1_NS		104	2	1
+#define PC1_SUBM	104	2	3
+#define PC2_S		104	4	0
+#define PC2_NS		104	4	1
+#define PC2_SUBM	104	4	3
+#define PC3_S		104	6	0
+#define PC3_NS		104	6	1
+#define PC3_SUBM	104	6	3
+#define PC4_S		104	8	0
+#define PC4_NS		104	8	1
+#define PC4_SUBM	104	8	3
+#define PC5_S		104	10	0
+#define PC5_NS		104	10	1
+#define PC5_SUBM	104	10	3
+#define PC6_S		104	12	0
+#define PC6_NS		104	12	1
+#define PC6_SUBM	104	12	3
+#define PC7_S		104	14	0
+#define PC7_NS		104	14	1
+#define PC7_SUBM	104	14	3
+#define PC8_S		104	16	0
+#define PC8_NS		104	16	1
+#define PC8_SUBM	104	16	3
+#define PC9_S		104	18	0
+#define PC9_NS		104	18	1
+#define PC9_SUBM	104	18	3
+#define PC10_S		104	20	0
+#define PC10_NS		104	20	1
+#define PC10_SUBM	104	20	3
+#define PC11_S		104	22	0
+#define PC11_NS		104	22	1
+#define PC11_SUBM	104	22	3
+#define PC12_S		104	24	0
+#define PC12_NS		104	24	1
+#define PC12_SUBM	104	24	3
+#define PC13_S		104	26	0
+#define PC13_NS		104	26	1
+#define PC13_SUBM	104	26	3
+#define PC14_S		104	28	0
+#define PC14_NS		104	28	1
+#define PC14_SUBM	104	28	3
+#define PC15_S		104	30	0
+#define PC15_NS		104	30	1
+#define PC15_SUBM	104	30	3
+
+#define PD0_S		108	0	0
+#define PD0_NS		108	0	1
+#define PD0_SUBM	108	0	3
+#define PD1_S		108	2	0
+#define PD1_NS		108	2	1
+#define PD1_SUBM	108	2	3
+#define PD2_S		108	4	0
+#define PD2_NS		108	4	1
+#define PD2_SUBM	108	4	3
+#define PD3_S		108	6	0
+#define PD3_NS		108	6	1
+#define PD3_SUBM	108	6	3
+#define PD4_S		108	8	0
+#define PD4_NS		108	8	1
+#define PD4_SUBM	108	8	3
+#define PD5_S		108	10	0
+#define PD5_NS		108	10	1
+#define PD5_SUBM	108	10	3
+#define PD6_S		108	12	0
+#define PD6_NS		108	12	1
+#define PD6_SUBM	108	12	3
+#define PD7_S		108	14	0
+#define PD7_NS		108	14	1
+#define PD7_SUBM	108	14	3
+#define PD8_S		108	16	0
+#define PD8_NS		108	16	1
+#define PD8_SUBM	108	16	3
+#define PD9_S		108	18	0
+#define PD9_NS		108	18	1
+#define PD9_SUBM	108	18	3
+#define PD10_S		108	20	0
+#define PD10_NS		108	20	1
+#define PD10_SUBM	108	20	3
+#define PD11_S		108	22	0
+#define PD11_NS		108	22	1
+#define PD11_SUBM	108	22	3
+#define PD12_S		108	24	0
+#define PD12_NS		108	24	1
+#define PD12_SUBM	108	24	3
+#define PD13_S		108	26	0
+#define PD13_NS		108	26	1
+#define PD13_SUBM	108	26	3
+#define PD14_S		108	28	0
+#define PD14_NS		108	28	1
+#define PD14_SUBM	108	28	3
+#define PD15_S		108	30	0
+#define PD15_NS		108	30	1
+#define PD15_SUBM	108	30	3
+
+#define PE0_S		112	0	0
+#define PE0_NS		112	0	1
+#define PE0_SUBM	112	0	3
+#define PE1_S		112	2	0
+#define PE1_NS		112	2	1
+#define PE1_SUBM	112	2	3
+#define PE2_S		112	4	0
+#define PE2_NS		112	4	1
+#define PE2_SUBM	112	4	3
+#define PE3_S		112	6	0
+#define PE3_NS		112	6	1
+#define PE3_SUBM	112	6	3
+#define PE4_S		112	8	0
+#define PE4_NS		112	8	1
+#define PE4_SUBM	112	8	3
+#define PE5_S		112	10	0
+#define PE5_NS		112	10	1
+#define PE5_SUBM	112	10	3
+#define PE6_S		112	12	0
+#define PE6_NS		112	12	1
+#define PE6_SUBM	112	12	3
+#define PE7_S		112	14	0
+#define PE7_NS		112	14	1
+#define PE7_SUBM	112	14	3
+#define PE8_S		112	16	0
+#define PE8_NS		112	16	1
+#define PE8_SUBM	112	16	3
+#define PE9_S		112	18	0
+#define PE9_NS		112	18	1
+#define PE9_SUBM	112	18	3
+#define PE10_S		112	20	0
+#define PE10_NS		112	20	1
+#define PE10_SUBM	112	20	3
+#define PE11_S		112	22	0
+#define PE11_NS		112	22	1
+#define PE11_SUBM	112	22	3
+#define PE12_S		112	24	0
+#define PE12_NS		112	24	1
+#define PE12_SUBM	112	24	3
+#define PE13_S		112	26	0
+#define PE13_NS		112	26	1
+#define PE13_SUBM	112	26	3
+#define PE14_S		112	28	0
+#define PE14_NS		112	28	1
+#define PE14_SUBM	112	28	3
+#define PE15_S		112	30	0
+#define PE15_NS		112	30	1
+#define PE15_SUBM	112	30	3
+
+#define PF0_S		116	0	0
+#define PF0_NS		116	0	1
+#define PF0_SUBM	116	0	3
+#define PF1_S		116	2	0
+#define PF1_NS		116	2	1
+#define PF1_SUBM	116	2	3
+#define PF2_S		116	4	0
+#define PF2_NS		116	4	1
+#define PF2_SUBM	116	4	3
+#define PF3_S		116	6	0
+#define PF3_NS		116	6	1
+#define PF3_SUBM	116	6	3
+#define PF4_S		116	8	0
+#define PF4_NS		116	8	1
+#define PF4_SUBM	116	8	3
+#define PF5_S		116	10	0
+#define PF5_NS		116	10	1
+#define PF5_SUBM	116	10	3
+#define PF6_S		116	12	0
+#define PF6_NS		116	12	1
+#define PF6_SUBM	116	12	3
+#define PF7_S		116	14	0
+#define PF7_NS		116	14	1
+#define PF7_SUBM	116	14	3
+#define PF8_S		116	16	0
+#define PF8_NS		116	16	1
+#define PF8_SUBM	116	16	3
+#define PF9_S		116	18	0
+#define PF9_NS		116	18	1
+#define PF9_SUBM	116	18	3
+#define PF10_S		116	20	0
+#define PF10_NS		116	20	1
+#define PF10_SUBM	116	20	3
+#define PF11_S		116	22	0
+#define PF11_NS		116	22	1
+#define PF11_SUBM	116	22	3
+#define PF12_S		116	24	0
+#define PF12_NS		116	24	1
+#define PF12_SUBM	116	24	3
+#define PF13_S		116	26	0
+#define PF13_NS		116	26	1
+#define PF13_SUBM	116	26	3
+#define PF14_S		116	28	0
+#define PF14_NS		116	28	1
+#define PF14_SUBM	116	28	3
+#define PF15_S		116	30	0
+#define PF15_NS		116	30	1
+#define PF15_SUBM	116	30	3
+
+#define PG0_S		120	0	0
+#define PG0_NS		120	0	1
+#define PG0_SUBM	120	0	3
+#define PG1_S		120	2	0
+#define PG1_NS		120	2	1
+#define PG1_SUBM	120	2	3
+#define PG2_S		120	4	0
+#define PG2_NS		120	4	1
+#define PG2_SUBM	120	4	3
+#define PG3_S		120	6	0
+#define PG3_NS		120	6	1
+#define PG3_SUBM	120	6	3
+#define PG4_S		120	8	0
+#define PG4_NS		120	8	1
+#define PG4_SUBM	120	8	3
+#define PG5_S		120	10	0
+#define PG5_NS		120	10	1
+#define PG5_SUBM	120	10	3
+#define PG6_S		120	12	0
+#define PG6_NS		120	12	1
+#define PG6_SUBM	120	12	3
+#define PG7_S		120	14	0
+#define PG7_NS		120	14	1
+#define PG7_SUBM	120	14	3
+#define PG8_S		120	16	0
+#define PG8_NS		120	16	1
+#define PG8_SUBM	120	16	3
+#define PG9_S		120	18	0
+#define PG9_NS		120	18	1
+#define PG9_SUBM	120	18	3
+#define PG10_S		120	20	0
+#define PG10_NS		120	20	1
+#define PG10_SUBM	120	20	3
+#define PG11_S		120	22	0
+#define PG11_NS		120	22	1
+#define PG11_SUBM	120	22	3
+#define PG12_S		120	24	0
+#define PG12_NS		120	24	1
+#define PG12_SUBM	120	24	3
+#define PG13_S		120	26	0
+#define PG13_NS		120	26	1
+#define PG13_SUBM	120	26	3
+#define PG14_S		120	28	0
+#define PG14_NS		120	28	1
+#define PG14_SUBM	120	28	3
+#define PG15_S		120	30	0
+#define PG15_NS		120	30	1
+#define PG15_SUBM	120	30	3
+
+#define PH0_S		124	0	0
+#define PH0_NS		124	0	1
+#define PH0_SUBM	124	0	3
+#define PH1_S		124	2	0
+#define PH1_NS		124	2	1
+#define PH1_SUBM	124	2	3
+#define PH2_S		124	4	0
+#define PH2_NS		124	4	1
+#define PH2_SUBM	124	4	3
+#define PH3_S		124	6	0
+#define PH3_NS		124	6	1
+#define PH3_SUBM	124	6	3
+#define PH4_S		124	8	0
+#define PH4_NS		124	8	1
+#define PH4_SUBM	124	8	3
+#define PH5_S		124	10	0
+#define PH5_NS		124	10	1
+#define PH5_SUBM	124	10	3
+#define PH6_S		124	12	0
+#define PH6_NS		124	12	1
+#define PH6_SUBM	124	12	3
+#define PH7_S		124	14	0
+#define PH7_NS		124	14	1
+#define PH7_SUBM	124	14	3
+#define PH8_S		124	16	0
+#define PH8_NS		124	16	1
+#define PH8_SUBM	124	16	3
+#define PH9_S		124	18	0
+#define PH9_NS		124	18	1
+#define PH9_SUBM	124	18	3
+#define PH10_S		124	20	0
+#define PH10_NS		124	20	1
+#define PH10_SUBM	124	20	3
+#define PH11_S		124	22	0
+#define PH11_NS		124	22	1
+#define PH11_SUBM	124	22	3
+#define PH12_S		124	24	0
+#define PH12_NS		124	24	1
+#define PH12_SUBM	124	24	3
+#define PH13_S		124	26	0
+#define PH13_NS		124	26	1
+#define PH13_SUBM	124	26	3
+#define PH14_S		124	28	0
+#define PH14_NS		124	28	1
+#define PH14_SUBM	124	28	3
+#define PH15_S		124	30	0
+#define PH15_NS		124	30	1
+#define PH15_SUBM	124	30	3
+
+#define PI0_S		128	0	0
+#define PI0_NS		128	0	1
+#define PI0_SUBM	128	0	3
+#define PI1_S		128	2	0
+#define PI1_NS		128	2	1
+#define PI1_SUBM	128	2	3
+#define PI2_S		128	4	0
+#define PI2_NS		128	4	1
+#define PI2_SUBM	128	4	3
+#define PI3_S		128	6	0
+#define PI3_NS		128	6	1
+#define PI3_SUBM	128	6	3
+#define PI4_S		128	8	0
+#define PI4_NS		128	8	1
+#define PI4_SUBM	128	8	3
+#define PI5_S		128	10	0
+#define PI5_NS		128	10	1
+#define PI5_SUBM	128	10	3
+#define PI6_S		128	12	0
+#define PI6_NS		128	12	1
+#define PI6_SUBM	128	12	3
+#define PI7_S		128	14	0
+#define PI7_NS		128	14	1
+#define PI7_SUBM	128	14	3
+#define PI8_S		128	16	0
+#define PI8_NS		128	16	1
+#define PI8_SUBM	128	16	3
+#define PI9_S		128	18	0
+#define PI9_NS		128	18	1
+#define PI9_SUBM	128	18	3
+#define PI10_S		128	20	0
+#define PI10_NS		128	20	1
+#define PI10_SUBM	128	20	3
+#define PI11_S		128	22	0
+#define PI11_NS		128	22	1
+#define PI11_SUBM	128	22	3
+#define PI12_S		128	24	0
+#define PI12_NS		128	24	1
+#define PI12_SUBM	128	24	3
+#define PI13_S		128	26	0
+#define PI13_NS		128	26	1
+#define PI13_SUBM	128	26	3
+#define PI14_S		128	28	0
+#define PI14_NS		128	28	1
+#define PI14_SUBM	128	28	3
+#define PI15_S		128	30	0
+#define PI15_NS		128	30	1
+#define PI15_SUBM	128	30	3
+
+#define PJ0_S		132	0	0
+#define PJ0_NS		132	0	1
+#define PJ0_SUBM	132	0	3
+#define PJ1_S		132	2	0
+#define PJ1_NS		132	2	1
+#define PJ1_SUBM	132	2	3
+#define PJ2_S		132	4	0
+#define PJ2_NS		132	4	1
+#define PJ2_SUBM	132	4	3
+#define PJ3_S		132	6	0
+#define PJ3_NS		132	6	1
+#define PJ3_SUBM	132	6	3
+#define PJ4_S		132	8	0
+#define PJ4_NS		132	8	1
+#define PJ4_SUBM	132	8	3
+#define PJ5_S		132	10	0
+#define PJ5_NS		132	10	1
+#define PJ5_SUBM	132	10	3
+#define PJ6_S		132	12	0
+#define PJ6_NS		132	12	1
+#define PJ6_SUBM	132	12	3
+#define PJ7_S		132	14	0
+#define PJ7_NS		132	14	1
+#define PJ7_SUBM	132	14	3
+#define PJ8_S		132	16	0
+#define PJ8_NS		132	16	1
+#define PJ8_SUBM	132	16	3
+#define PJ9_S		132	18	0
+#define PJ9_NS		132	18	1
+#define PJ9_SUBM	132	18	3
+#define PJ10_S		132	20	0
+#define PJ10_NS		132	20	1
+#define PJ10_SUBM	132	20	3
+#define PJ11_S		132	22	0
+#define PJ11_NS		132	22	1
+#define PJ11_SUBM	132	22	3
+#define PJ12_S		132	24	0
+#define PJ12_NS		132	24	1
+#define PJ12_SUBM	132	24	3
+#define PJ13_S		132	26	0
+#define PJ13_NS		132	26	1
+#define PJ13_SUBM	132	26	3
+#define PJ14_S		132	28	0
+#define PJ14_NS		132	28	1
+#define PJ14_SUBM	132	28	3
+#define PJ15_S		132	30	0
+#define PJ15_NS		132	30	1
+#define PJ15_SUBM	132	30	3
+
+#define PK0_S		136	0	0
+#define PK0_NS		136	0	1
+#define PK0_SUBM	136	0	3
+#define PK1_S		136	2	0
+#define PK1_NS		136	2	1
+#define PK1_SUBM	136	2	3
+#define PK2_S		136	4	0
+#define PK2_NS		136	4	1
+#define PK2_SUBM	136	4	3
+#define PK3_S		136	6	0
+#define PK3_NS		136	6	1
+#define PK3_SUBM	136	6	3
+#define PK4_S		136	8	0
+#define PK4_NS		136	8	1
+#define PK4_SUBM	136	8	3
+#define PK5_S		136	10	0
+#define PK5_NS		136	10	1
+#define PK5_SUBM	136	10	3
+#define PK6_S		136	12	0
+#define PK6_NS		136	12	1
+#define PK6_SUBM	136	12	3
+#define PK7_S		136	14	0
+#define PK7_NS		136	14	1
+#define PK7_SUBM	136	14	3
+#define PK8_S		136	16	0
+#define PK8_NS		136	16	1
+#define PK8_SUBM	136	16	3
+#define PK9_S		136	18	0
+#define PK9_NS		136	18	1
+#define PK9_SUBM	136	18	3
+#define PK10_S		136	20	0
+#define PK10_NS		136	20	1
+#define PK10_SUBM	136	20	3
+#define PK11_S		136	22	0
+#define PK11_NS		136	22	1
+#define PK11_SUBM	136	22	3
+#define PK12_S		136	24	0
+#define PK12_NS		136	24	1
+#define PK12_SUBM	136	24	3
+#define PK13_S		136	26	0
+#define PK13_NS		136	26	1
+#define PK13_SUBM	136	26	3
+#define PK14_S		136	28	0
+#define PK14_NS		136	28	1
+#define PK14_SUBM	136	28	3
+#define PK15_S		136	30	0
+#define PK15_NS		136	30	1
+#define PK15_SUBM	136	30	3
+
+#define PL0_S		140	0	0
+#define PL0_NS		140	0	1
+#define PL0_SUBM	140	0	3
+#define PL1_S		140	2	0
+#define PL1_NS		140	2	1
+#define PL1_SUBM	140	2	3
+#define PL2_S		140	4	0
+#define PL2_NS		140	4	1
+#define PL2_SUBM	140	4	3
+#define PL3_S		140	6	0
+#define PL3_NS		140	6	1
+#define PL3_SUBM	140	6	3
+#define PL4_S		140	8	0
+#define PL4_NS		140	8	1
+#define PL4_SUBM	140	8	3
+#define PL5_S		140	10	0
+#define PL5_NS		140	10	1
+#define PL5_SUBM	140	10	3
+#define PL6_S		140	12	0
+#define PL6_NS		140	12	1
+#define PL6_SUBM	140	12	3
+#define PL7_S		140	14	0
+#define PL7_NS		140	14	1
+#define PL7_SUBM	140	14	3
+#define PL8_S		140	16	0
+#define PL8_NS		140	16	1
+#define PL8_SUBM	140	16	3
+#define PL9_S		140	18	0
+#define PL9_NS		140	18	1
+#define PL9_SUBM	140	18	3
+#define PL10_S		140	20	0
+#define PL10_NS		140	20	1
+#define PL10_SUBM	140	20	3
+#define PL11_S		140	22	0
+#define PL11_NS		140	22	1
+#define PL11_SUBM	140	22	3
+#define PL12_S		140	24	0
+#define PL12_NS		140	24	1
+#define PL12_SUBM	140	24	3
+#define PL13_S		140	26	0
+#define PL13_NS		140	26	1
+#define PL13_SUBM	140	26	3
+#define PL14_S		140	28	0
+#define PL14_NS		140	28	1
+#define PL14_SUBM	140	28	3
+#define PL15_S		140	30	0
+#define PL15_NS		140	30	1
+#define PL15_SUBM	140	30	3
+
+#define PM0_S		144	0	0
+#define PM0_NS		144	0	1
+#define PM0_SUBM	144	0	3
+#define PM1_S		144	2	0
+#define PM1_NS		144	2	1
+#define PM1_SUBM	144	2	3
+#define PM2_S		144	4	0
+#define PM2_NS		144	4	1
+#define PM2_SUBM	144	4	3
+#define PM3_S		144	6	0
+#define PM3_NS		144	6	1
+#define PM3_SUBM	144	6	3
+#define PM4_S		144	8	0
+#define PM4_NS		144	8	1
+#define PM4_SUBM	144	8	3
+#define PM5_S		144	10	0
+#define PM5_NS		144	10	1
+#define PM5_SUBM	144	10	3
+#define PM6_S		144	12	0
+#define PM6_NS		144	12	1
+#define PM6_SUBM	144	12	3
+#define PM7_S		144	14	0
+#define PM7_NS		144	14	1
+#define PM7_SUBM	144	14	3
+#define PM8_S		144	16	0
+#define PM8_NS		144	16	1
+#define PM8_SUBM	144	16	3
+#define PM9_S		144	18	0
+#define PM9_NS		144	18	1
+#define PM9_SUBM	144	18	3
+#define PM10_S		144	20	0
+#define PM10_NS		144	20	1
+#define PM10_SUBM	144	20	3
+#define PM11_S		144	22	0
+#define PM11_NS		144	22	1
+#define PM11_SUBM	144	22	3
+#define PM12_S		144	24	0
+#define PM12_NS		144	24	1
+#define PM12_SUBM	144	24	3
+#define PM13_S		144	26	0
+#define PM13_NS		144	26	1
+#define PM13_SUBM	144	26	3
+#define PM14_S		144	28	0
+#define PM14_NS		144	28	1
+#define PM14_SUBM	144	28	3
+#define PM15_S		144	30	0
+#define PM15_NS		144	30	1
+#define PM15_SUBM	144	30	3
+
+#define PN0_S		148	0	0
+#define PN0_NS		148	0	1
+#define PN0_SUBM	148	0	3
+#define PN1_S		148	2	0
+#define PN1_NS		148	2	1
+#define PN1_SUBM	148	2	3
+#define PN2_S		148	4	0
+#define PN2_NS		148	4	1
+#define PN2_SUBM	148	4	3
+#define PN3_S		148	6	0
+#define PN3_NS		148	6	1
+#define PN3_SUBM	148	6	3
+#define PN4_S		148	8	0
+#define PN4_NS		148	8	1
+#define PN4_SUBM	148	8	3
+#define PN5_S		148	10	0
+#define PN5_NS		148	10	1
+#define PN5_SUBM	148	10	3
+#define PN6_S		148	12	0
+#define PN6_NS		148	12	1
+#define PN6_SUBM	148	12	3
+#define PN7_S		148	14	0
+#define PN7_NS		148	14	1
+#define PN7_SUBM	148	14	3
+#define PN8_S		148	16	0
+#define PN8_NS		148	16	1
+#define PN8_SUBM	148	16	3
+#define PN9_S		148	18	0
+#define PN9_NS		148	18	1
+#define PN9_SUBM	148	18	3
+#define PN10_S		148	20	0
+#define PN10_NS		148	20	1
+#define PN10_SUBM	148	20	3
+#define PN11_S		148	22	0
+#define PN11_NS		148	22	1
+#define PN11_SUBM	148	22	3
+#define PN12_S		148	24	0
+#define PN12_NS		148	24	1
+#define PN12_SUBM	148	24	3
+#define PN13_S		148	26	0
+#define PN13_NS		148	26	1
+#define PN13_SUBM	148	26	3
+#define PN14_S		148	28	0
+#define PN14_NS		148	28	1
+#define PN14_SUBM	148	28	3
+#define PN15_S		148	30	0
+#define PN15_NS		148	30	1
+#define PN15_SUBM	148	30	3
+
+#endif // __SSPCC_H__
diff --git a/plat/nuvoton/ma35d1/include/tsi_cmd.h b/plat/nuvoton/ma35d1/include/tsi_cmd.h
new file mode 100644
index 0000000..4cdf13b
--- /dev/null
+++ b/plat/nuvoton/ma35d1/include/tsi_cmd.h
@@ -0,0 +1,187 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+#ifndef __TSI_CMD_H__
+#define __TSI_CMD_H__
+
+/*------------------------------------------------------------------*/
+/*  TSI command class code                                          */
+/*------------------------------------------------------------------*/
+#define C_CODE_TSI_CTRL         0x01
+#define C_CODE_TRNG             0x02
+#define C_CODE_PRNG             0x03
+#define C_CODE_AES              0x04
+#define C_CODE_SHA              0x05
+#define C_CODE_ECC              0x06
+#define C_CODE_RSA              0x07
+#define C_CODE_KS               0x08
+#define C_CODE_OTP              0x09
+
+/*------------------------------------------------------------------*/
+/*  TSI commands                                                    */
+/*------------------------------------------------------------------*/
+#define CMD_TSI_SYNC            0x0101
+#define CMD_TSI_GET_VERSION     0x0102
+#define CMD_TSI_SET_CLOCK       0x0110
+#define CMD_TSI_RESET           0x0111
+#define CMD_TSI_CONFIG_UART     0x0130
+#define CMD_TSI_LOAD_EX_FUNC    0x0140
+#define CMD_TSI_MONITOR_SET     0x0142
+#define CMD_TSI_MONITOR_STATUS  0x0143
+#define CMD_TSI_MONITOR_CLOSE   0x0144
+#define CMD_TSI_OPEN_SESSION    0x0150
+#define CMD_TSI_CLOSE_SESSION   0x0151
+#define CMD_TRNG_INIT           0x0201
+#define CMD_TRNG_GEN_RANDOM     0x0205
+#define CMD_PRNG_RESEED         0x0301
+#define CMD_PRNG_GEN_RANDOM     0x0305
+#define CMD_PRNG_GEN_RAN_MASS   0x0315
+#define CMD_PRNG_GEN_KS_SRAM    0x0320
+#define CMD_AES_SET_MODE        0x0401
+#define CMD_AES_SET_IV          0x0402
+#define CMD_AES_SET_KEY         0x0403
+#define CMD_AES_RUN             0x0405
+#define CMD_AES_GCM_RUN         0x0406
+#define CMD_AES_CCM_RUN         0x0408
+#define CMD_AES_ACCESS_FEEDBACK 0x0409
+#define CMD_SHA_START           0x0501
+#define CMD_SHA_UPDATE          0x0502
+#define CMD_SHA_FINISH          0x0503
+#define CMD_SHA_ALL_AT_ONCE     0x0505
+#define CMD_ECC_GEN_PUB_KEY     0x0601
+#define CMD_ECC_GEN_SIG         0x0602
+#define CMD_ECC_VERIFY_SIG      0x0603
+#define CMD_ECC_MULTIPLY        0x0604
+#define CMD_RSA_EXP_MOD         0x0702
+#define CMD_KS_WRITE_SRAM_KEY   0x0A01
+#define CMD_KS_WRITE_OTP_KEY    0x0A02
+#define CMD_KS_READ_KEY         0x0A05
+#define CMD_KS_REVOKE_KEY       0x0A08
+#define CMD_KS_ERASE_KEY        0x0A10
+#define CMD_KS_ERASE_ALL        0x0A11
+#define CMD_KS_REMAIN_SIZE      0x0A15
+#define CMD_KS_GET_STATUS       0x0A20
+
+/*------------------------------------------------------------------*/
+/*  TSI command ACK status                                          */
+/*------------------------------------------------------------------*/
+#define ST_SUCCESS              0x00
+#define ST_WAIT_TSI_SYNC        0x01    /* Waiting host to send TSI_SYNC command        */
+#define ST_UNKNOWN_CMD          0x02    /* Unknown command                              */
+#define ST_NO_TSI_IMAGE         0x03    /* TSI image is required                        */
+#define ST_CMD_QUEUE_FULL       0x04    /* TSI command queue is full                    */
+#define ST_TIME_OUT             0x10    /* Command request was not completed in time    */
+#define ST_INVALID_PARAM        0x11    /* Invalid parameter                            */
+#define ST_NO_AVAIL_SESSION     0x12    /* No available AES/SHA sessions                */
+#define ST_INVALID_SESSION_ID   0x13    /* Not an opened AES/SHA session ID             */
+#define ST_INVALID_OPERATION    0x14    /* Invalid operation                            */
+#define ST_HW_NOT_READY         0x31    /* Hrdawre engine in not ready                  */
+#define ST_HW_ERROR             0x32    /* Hardware engine report error                 */
+#define ST_HW_BUSY              0x33    /* Hardware engine is busy on other request     */
+#define ST_HW_TIME_OUT          0x34    /* Hardware engine time-out                     */
+#define ST_BUS_ERROR            0x35    /* Memory address can not access                */
+#define ST_KS_ERROR             0x40    /* Key Store key error                          */
+#define ST_MON_FULL             0x41    /* All monitors are used.                       */
+#define ST_MON_ID_ERR           0x42    /* Invalid monitor ID                           */
+#define ST_MON_CHECK_FAIL       0x43    /* Monitor found memory area modified           */
+#define ST_IMG_SIZE             0x45    /* Patch image size over limitation             */
+#define ST_IMG_VERIFY           0x46    /* Patch image size authentication failed       */
+#define ST_ECC_UNKNOWN_CURVE    0x61    /* Unknown ECC curve                            */
+#define ST_ECC_INVALID_PRIV_KEY 0x62    /* ECC private key in not valid                 */
+#define ST_SIG_VERIFY_ERROR     0x70    /* ECC/RSA signature verification failed        */
+#define ST_KS_READ_PROTECT      0x80    /* Key Store key entry cannot read by CPU       */
+#define ST_KS_FULL              0x81    /* Key Store full                               */
+#define ST_WHC_TX_BUSY          0xd1    /* All TX channel of Wormhole are busy          */
+#define ST_CMD_ACK_TIME_OUT     0xd2    /* TSI does not ack command in time limit       */
+
+typedef struct tsi_cmd_t {
+	uint32_t	cmd[4];
+	uint32_t	ack[4];
+	int		tx_channel;	/* WHC TX channel used to send this command  */
+	uint32_t	tx_jiffy;	/* the jiffy of command being send           */
+	int		session_id;	/* for AES and SHA only                      */
+	uint32_t	addr_param;	/* parameter block address                   */
+	uint32_t	caddr_src;	/* current data source address               */
+	uint32_t	caddr_dst;	/* current data destination address          */
+	uint32_t	remain_len;	/* remaining data length                     */
+} TSI_REQ_T;
+
+enum {
+	TREQ_ST_UNUSED = 0,
+	TREQ_ST_WAIT_PROCESS,
+	TREQ_ST_PROCESSING,
+	TREQ_ST_ACK_SEND,
+};
+
+#define TC_GET_CLASS_CODE(r)	((((r)->cmd[0])>>24)&0xff)
+#define TC_GET_SUB_CODE(r)	((((r)->cmd[0])>>16)&0xff)
+#define TC_GET_COMMAND(r)	((((r)->cmd[0])>>16)&0xffff)
+#define TC_GET_SESSION_ID(r)	(((r)->cmd[0])&0xff)
+#define TC_SET_CLASS_CODE(r, c)	(r)->cmd[0] = (((r)->cmd[0])&0x00ffffff)|((c&0xff)<<24)
+#define TC_SET_SUB_CODE(r, c)	(r)->cmd[0] = (((r)->cmd[0])&0xff00ffff)|((c&0xff)<<16)
+#define TC_SET_SESSION_ID(r, s)	(r)->cmd[0] = (((r)->cmd[0])&0xffffff00)|(s&0xff)
+#define TA_GET_CLASS_CODE(a)	((((a)->ack[0])>>24)&0xff)
+#define TA_GET_SESSION_ID(a)	(((a)->ack[0])&0xff)
+#define TA_GET_STATUS(a)	((((a)->ack[0])>>8)&0xff)
+
+/* Command/ACK characteristic is composed of class code, sub-code, and session ID */
+#define TCK_CHR_MASK			(0xffff00ff)
+
+#define TSI_CMD_WORD0(cc, sc, sid)	((cc<<24)|(sc<<16)|sid)
+
+
+#define CMD_TIME_OUT_1S             100     /* general time-out 1 seconds */
+#define CMD_TIME_OUT_2S             200     /* general time-out 2 seconds */
+#define CMD_TIME_OUT_3S             300     /* general time-out 3 seconds */
+#define CMD_TIME_OUT_5S             500     /* general time-out 5 seconds */
+
+#define SEL_KEY_FROM_REG            0x0
+#define SEL_KEY_FROM_KS_SRAM        0x1
+#define SEL_KEY_FROM_KS_OTP         0x5
+
+
+#define ECC_KEY_SEL_TRNG            0x0
+#define ECC_KEY_SEL_KS_OTP          0x1
+#define ECC_KEY_SEL_KS_SRAM         0x2
+#define ECC_KEY_SEL_USER            0x3
+
+#define RSA_KEY_SEL_KS_OTP          0x1
+#define RSA_KEY_SEL_KS_SRAM         0x2
+#define RSA_KEY_SEL_USER            0x3
+
+
+int TSI_Sync(void);
+int TSI_Get_Version(uint32_t *ver_code);
+int TSI_Reset(void);
+int TSI_Config_UART(uint32_t line, uint32_t baud);
+int TSI_Set_Clock(uint32_t pllctl);
+int TSI_Open_Session(int class_code, int *session_id);
+int TSI_Close_Session(int class_code, int session_id);
+int TSI_AES_Set_Mode(int sid, int kinswap, int koutswap, int inswap, int outswap,
+		int sm4en, int encrypt, int mode, int keysz, int ks, int ks_num);
+int TSI_AES_Set_IV(int sid, uint32_t iv_addr);
+int TSI_AES_Set_Key(int sid, int keysz, uint32_t key_addr);
+int TSI_AES_Run(int sid, int is_last, int data_cnt, uint32_t src_addr,
+		uint32_t dest_addr);
+int TSI_AES_GCM_Run(int sid, int is_last, int data_cnt, uint32_t param_addr);
+int TSI_Access_Feedback(int sid, int rw, int wcnt, uint32_t fdbck_addr);
+int TSI_SHA_Start(int sid, int inswap, int outswap, int mode_sel, int hmac,
+		int mode, int keylen, int ks, int ks_num);
+int TSI_SHA_Update(int sid, int data_cnt, uint32_t src_addr);
+int TSI_SHA_Finish(int sid, int wcnt, int data_cnt, uint32_t src_addr,
+		uint32_t dest_addr);
+int TSI_SHA_All_At_Once(int inswap, int outswap, int mode_sel, int mode,
+		int wcnt, int data_cnt, uint32_t src_addr, uint32_t dest_addr);
+int TSI_ECC_GenPublicKey(E_ECC_CURVE curve_id, int is_ecdh, int psel,
+		int d_knum, uint32_t priv_key, uint32_t pub_key);
+int TSI_ECC_GenSignature(E_ECC_CURVE curve_id, int rsel, int psel, int key_idx,
+		uint32_t param_addr, uint32_t sig_addr);
+int TSI_ECC_VerifySignature(E_ECC_CURVE curve_id, int psel, int x_knum,
+		int y_knum, uint32_t param_addr);
+int TSI_ECC_Multiply(E_ECC_CURVE curve_id, int type, int msel, int sps, int m_knum,
+		int x_knum, int y_knum, uint32_t param_addr, uint32_t dest_addr);
+
+#endif
+/* __TSI_CMD_H__ */
diff --git a/plat/nuvoton/ma35d1/include/whc.h b/plat/nuvoton/ma35d1/include/whc.h
new file mode 100644
index 0000000..27d5147
--- /dev/null
+++ b/plat/nuvoton/ma35d1/include/whc.h
@@ -0,0 +1,289 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef __WHC_H__
+#define __WHC_H__
+
+
+typedef struct {
+	uint32_t WKCTL;
+	uint32_t INTEN_;
+	uint32_t INTSTS_;
+	uint32_t RESERVE0[13];
+	uint32_t CPSTS;
+	uint32_t RESERVE1[15];
+	uint32_t GINTTRG;
+	uint32_t RESERVE2[15];
+	uint32_t TXCTL;
+	uint32_t TXSTS;
+	uint32_t RXCTL;
+	uint32_t RXSTS;
+	uint32_t RESERVE3[12];
+	uint32_t TMDAT[4][4];
+	uint32_t RESERVE4[48];
+	uint32_t RMDAT[4][4];
+} WHC_T;
+
+#define WHC_WKCTL_RST0WKEN_Pos              (0)
+#define WHC_WKCTL_RST0WKEN_Msk              (0x1ul << WHC_WKCTL_RST0WKEN_Pos)
+
+#define WHC_WKCTL_POFF0WKEN_Pos             (1)
+#define WHC_WKCTL_POFF0WKEN_Msk             (0x1ul << WHC_WKCTL_POFF0WKEN_Pos)
+
+#define WHC_WKCTL_PD0WKEN_Pos               (2)
+#define WHC_WKCTL_PD0WKEN_Msk               (0x1ul << WHC_WKCTL_PD0WKEN_Pos)
+
+#define WHC_WKCTL_RST1WKEN_Pos              (3)
+#define WHC_WKCTL_RST1WKEN_Msk              (0x1ul << WHC_WKCTL_RST1WKEN_Pos)
+
+#define WHC_WKCTL_POFF1WKEN_Pos             (4)
+#define WHC_WKCTL_POFF1WKEN_Msk             (0x1ul << WHC_WKCTL_POFF1WKEN_Pos)
+
+#define WHC_WKCTL_PD1WKEN_Pos               (5)
+#define WHC_WKCTL_PD1WKEN_Msk               (0x1ul << WHC_WKCTL_PD1WKEN_Pos)
+
+#define WHC_WKCTL_GI0WKEN_Pos               (8)
+#define WHC_WKCTL_GI0WKEN_Msk               (0x1ul << WHC_WKCTL_GI0WKEN_Pos)
+
+#define WHC_WKCTL_GI1WKEN_Pos               (9)
+#define WHC_WKCTL_GI1WKEN_Msk               (0x1ul << WHC_WKCTL_GI1WKEN_Pos)
+
+#define WHC_WKCTL_GI2WKEN_Pos               (10)
+#define WHC_WKCTL_GI2WKEN_Msk               (0x1ul << WHC_WKCTL_GI2WKEN_Pos)
+
+#define WHC_WKCTL_GI3WKEN_Pos               (11)
+#define WHC_WKCTL_GI3WKEN_Msk               (0x1ul << WHC_WKCTL_GI3WKEN_Pos)
+
+#define WHC_WKCTL_TX0WKEN_Pos               (16)
+#define WHC_WKCTL_TX0WKEN_Msk               (0x1ul << WHC_WKCTL_TX0WKEN_Pos)
+
+#define WHC_WKCTL_TX1WKEN_Pos               (17)
+#define WHC_WKCTL_TX1WKEN_Msk               (0x1ul << WHC_WKCTL_TX1WKEN_Pos)
+
+#define WHC_WKCTL_TX2WKEN_Pos               (18)
+#define WHC_WKCTL_TX2WKEN_Msk               (0x1ul << WHC_WKCTL_TX2WKEN_Pos)
+
+#define WHC_WKCTL_TX3WKEN_Pos               (19)
+#define WHC_WKCTL_TX3WKEN_Msk               (0x1ul << WHC_WKCTL_TX3WKEN_Pos)
+
+#define WHC_WKCTL_RX0WKEN_Pos               (24)
+#define WHC_WKCTL_RX0WKEN_Msk               (0x1ul << WHC_WKCTL_RX0WKEN_Pos)
+
+#define WHC_WKCTL_RX1WKEN_Pos               (25)
+#define WHC_WKCTL_RX1WKEN_Msk               (0x1ul << WHC_WKCTL_RX1WKEN_Pos)
+
+#define WHC_WKCTL_RX2WKEN_Pos               (26)
+#define WHC_WKCTL_RX2WKEN_Msk               (0x1ul << WHC_WKCTL_RX2WKEN_Pos)
+
+#define WHC_WKCTL_RX3WKEN_Pos               (27)
+#define WHC_WKCTL_RX3WKEN_Msk               (0x1ul << WHC_WKCTL_RX3WKEN_Pos)
+
+#define WHC_INTEN_RST0IEN_Pos               (0)
+#define WHC_INTEN_RST0IEN_Msk               (0x1ul << WHC_INTEN_RST0IEN_Pos)
+
+#define WHC_INTEN_POFF0IEN_Pos              (1)
+#define WHC_INTEN_POFF0IEN_Msk              (0x1ul << WHC_INTEN_POFF0IEN_Pos)
+
+#define WHC_INTEN_PD0IEN_Pos                (2)
+#define WHC_INTEN_PD0IEN_Msk                (0x1ul << WHC_INTEN_PD0IEN_Pos)
+
+#define WHC_INTEN_RST1IEN_Pos               (3)
+#define WHC_INTEN_RST1IEN_Msk               (0x1ul << WHC_INTEN_RST1IEN_Pos)
+
+#define WHC_INTEN_POFF1IEN_Pos              (4)
+#define WHC_INTEN_POFF1IEN_Msk              (0x1ul << WHC_INTEN_POFF1IEN_Pos)
+
+#define WHC_INTEN_PD1IEN_Pos                (5)
+#define WHC_INTEN_PD1IEN_Msk                (0x1ul << WHC_INTEN_PD1IEN_Pos)
+
+#define WHC_INTEN_GI0IEN_Pos                (8)
+#define WHC_INTEN_GI0IEN_Msk                (0x1ul << WHC_INTEN_GI0IEN_Pos)
+
+#define WHC_INTEN_GI1IEN_Pos                (9)
+#define WHC_INTEN_GI1IEN_Msk                (0x1ul << WHC_INTEN_GI1IEN_Pos)
+
+#define WHC_INTEN_GI2IEN_Pos                (10)
+#define WHC_INTEN_GI2IEN_Msk                (0x1ul << WHC_INTEN_GI2IEN_Pos)
+
+#define WHC_INTEN_GI3IEN_Pos                (11)
+#define WHC_INTEN_GI3IEN_Msk                (0x1ul << WHC_INTEN_GI3IEN_Pos)
+
+#define WHC_INTEN_TX0IEN_Pos                (16)
+#define WHC_INTEN_TX0IEN_Msk                (0x1ul << WHC_INTEN_TX0IEN_Pos)
+
+#define WHC_INTEN_TX1IEN_Pos                (17)
+#define WHC_INTEN_TX1IEN_Msk                (0x1ul << WHC_INTEN_TX1IEN_Pos)
+
+#define WHC_INTEN_TX2IEN_Pos                (18)
+#define WHC_INTEN_TX2IEN_Msk                (0x1ul << WHC_INTEN_TX2IEN_Pos)
+
+#define WHC_INTEN_TX3IEN_Pos                (19)
+#define WHC_INTEN_TX3IEN_Msk                (0x1ul << WHC_INTEN_TX3IEN_Pos)
+
+#define WHC_INTEN_RX0IEN_Pos                (24)
+#define WHC_INTEN_RX0IEN_Msk                (0x1ul << WHC_INTEN_RX0IEN_Pos)
+
+#define WHC_INTEN_RX1IEN_Pos                (25)
+#define WHC_INTEN_RX1IEN_Msk                (0x1ul << WHC_INTEN_RX1IEN_Pos)
+
+#define WHC_INTEN_RX2IEN_Pos                (26)
+#define WHC_INTEN_RX2IEN_Msk                (0x1ul << WHC_INTEN_RX2IEN_Pos)
+
+#define WHC_INTEN_RX3IEN_Pos                (27)
+#define WHC_INTEN_RX3IEN_Msk                (0x1ul << WHC_INTEN_RX3IEN_Pos)
+
+#define WHC_INTSTS_RST0IF_Pos               (0)
+#define WHC_INTSTS_RST0IF_Msk               (0x1ul << WHC_INTSTS_RST0IF_Pos)
+
+#define WHC_INTSTS_POFF0IF_Pos              (1)
+#define WHC_INTSTS_POFF0IF_Msk              (0x1ul << WHC_INTSTS_POFF0IF_Pos)
+
+#define WHC_INTSTS_PD0IF_Pos                (2)
+#define WHC_INTSTS_PD0IF_Msk                (0x1ul << WHC_INTSTS_PD0IF_Pos)
+
+#define WHC_INTSTS_RST1IF_Pos               (3)
+#define WHC_INTSTS_RST1IF_Msk               (0x1ul << WHC_INTSTS_RST1IF_Pos)
+
+#define WHC_INTSTS_POFF1IF_Pos              (4)
+#define WHC_INTSTS_POFF1IF_Msk              (0x1ul << WHC_INTSTS_POFF1IF_Pos)
+
+#define WHC_INTSTS_PD1IF_Pos                (5)
+#define WHC_INTSTS_PD1IF_Msk                (0x1ul << WHC_INTSTS_PD1IF_Pos)
+
+#define WHC_INTSTS_GI0IF_Pos                (8)
+#define WHC_INTSTS_GI0IF_Msk                (0x1ul << WHC_INTSTS_GI0IF_Pos)
+
+#define WHC_INTSTS_GI1IF_Pos                (9)
+#define WHC_INTSTS_GI1IF_Msk                (0x1ul << WHC_INTSTS_GI1IF_Pos)
+
+#define WHC_INTSTS_GI2IF_Pos                (10)
+#define WHC_INTSTS_GI2IF_Msk                (0x1ul << WHC_INTSTS_GI2IF_Pos)
+
+#define WHC_INTSTS_GI3IF_Pos                (11)
+#define WHC_INTSTS_GI3IF_Msk                (0x1ul << WHC_INTSTS_GI3IF_Pos)
+
+#define WHC_INTSTS_TX0IF_Pos                (16)
+#define WHC_INTSTS_TX0IF_Msk                (0x1ul << WHC_INTSTS_TX0IF_Pos)
+
+#define WHC_INTSTS_TX1IF_Pos                (17)
+#define WHC_INTSTS_TX1IF_Msk                (0x1ul << WHC_INTSTS_TX1IF_Pos)
+
+#define WHC_INTSTS_TX2IF_Pos                (18)
+#define WHC_INTSTS_TX2IF_Msk                (0x1ul << WHC_INTSTS_TX2IF_Pos)
+
+#define WHC_INTSTS_TX3IF_Pos                (19)
+#define WHC_INTSTS_TX3IF_Msk                (0x1ul << WHC_INTSTS_TX3IF_Pos)
+
+#define WHC_INTSTS_RX0IF_Pos                (24)
+#define WHC_INTSTS_RX0IF_Msk                (0x1ul << WHC_INTSTS_RX0IF_Pos)
+
+#define WHC_INTSTS_RX1IF_Pos                (25)
+#define WHC_INTSTS_RX1IF_Msk                (0x1ul << WHC_INTSTS_RX1IF_Pos)
+
+#define WHC_INTSTS_RX2IF_Pos                (26)
+#define WHC_INTSTS_RX2IF_Msk                (0x1ul << WHC_INTSTS_RX2IF_Pos)
+
+#define WHC_INTSTS_RX3IF_Pos                (27)
+#define WHC_INTSTS_RX3IF_Msk                (0x1ul << WHC_INTSTS_RX3IF_Pos)
+
+#define WHC_CPSTS_WDTRF_Pos                 (2)
+#define WHC_CPSTS_WDTRF_Msk                 (0x1ul << WHC_INTSTS_WDTRF_Pos)
+
+#define WHC_CPSTS_SYSRF_Pos                 (5)
+#define WHC_CPSTS_SYSRF_Msk                 (0x1ul << WHC_INTSTS_SYSRF_Pos)
+
+#define WHC_CPSTS_CPURF_Pos                 (7)
+#define WHC_CPSTS_CPURF_Msk                 (0x1ul << WHC_INTSTS_CPURF_Pos)
+
+#define WHC_CPSTS_CPULKRF_Pos               (8)
+#define WHC_CPSTS_CPULKRF_Msk               (0x1ul << WHC_INTSTS_CPULKRF_Pos)
+
+#define WHC_CPSTS_OPMODE_Pos                (24)
+#define WHC_CPSTS_OPMODE_Msk                (0xful << WHC_INTSTS_OPMODE_Pos)
+
+#define WHC_GINTTRG_TRGG0_Pos               (0)
+#define WHC_GINTTRG_TRGG0_Msk               (0x1ul << WHC_GINTTRG_TRGG0_Pos)
+
+#define WHC_GINTTRG_TRGG1_Pos               (1)
+#define WHC_GINTTRG_TRGG1_Msk               (0x1ul << WHC_GINTTRG_TRGG1_Pos)
+
+#define WHC_GINTTRG_TRGG2_Pos               (2)
+#define WHC_GINTTRG_TRGG2_Msk               (0x1ul << WHC_GINTTRG_TRGG2_Pos)
+
+#define WHC_GINTTRG_TRGG3_Pos               (3)
+#define WHC_GINTTRG_TRGG3_Msk               (0x1ul << WHC_GINTTRG_TRGG3_Pos)
+
+#define WHC_TXCTL_CH0SND_Pos                (0)
+#define WHC_TXCTL_CH0SND_Msk                (0x1ul << WHC_TXCTL_CH0SND_Pos)
+
+#define WHC_TXCTL_CH1SND_Pos                (1)
+#define WHC_TXCTL_CH1SND_Msk                (0x1ul << WHC_TXCTL_CH1SND_Pos)
+
+#define WHC_TXCTL_CH2SND_Pos                (2)
+#define WHC_TXCTL_CH2SND_Msk                (0x1ul << WHC_TXCTL_CH2SND_Pos)
+
+#define WHC_TXCTL_CH3SND_Pos                (3)
+#define WHC_TXCTL_CH3SND_Msk                (0x1ul << WHC_TXCTL_CH3SND_Pos)
+
+#define WHC_TXCTL_CH0RC_Pos                 (16)
+#define WHC_TXCTL_CH0RC_Msk                 (0x1ul << WHC_TXCTL_CH0RC_Pos)
+
+#define WHC_TXCTL_CH1RC_Pos                 (17)
+#define WHC_TXCTL_CH1RC_Msk                 (0x1ul << WHC_TXCTL_CH1RC_Pos)
+
+#define WHC_TXCTL_CH2RC_Pos                 (18)
+#define WHC_TXCTL_CH2RC_Msk                 (0x1ul << WHC_TXCTL_CH2RC_Pos)
+
+#define WHC_TXCTL_CH3RC_Pos                 (19)
+#define WHC_TXCTL_CH3RC_Msk                 (0x1ul << WHC_TXCTL_CH3RC_Pos)
+
+#define WHC_TXSTS_CH0RDY_Pos                (0)
+#define WHC_TXSTS_CH0RDY_Msk                (0x1ul << WHC_TXSTS_CH0RDY_Pos)
+
+#define WHC_TXSTS_CH1RDY_Pos                (1)
+#define WHC_TXSTS_CH1RDY_Msk                (0x1ul << WHC_TXSTS_CH1RDY_Pos)
+
+#define WHC_TXSTS_CH2RDY_Pos                (2)
+#define WHC_TXSTS_CH2RDY_Msk                (0x1ul << WHC_TXSTS_CH2RDY_Pos)
+
+#define WHC_TXSTS_CH3RDY_Pos                (3)
+#define WHC_TXSTS_CH3RDY_Msk                (0x1ul << WHC_TXSTS_CH3RDY_Pos)
+
+#define WHC_RXCTL_CH0ACK_Pos                (0)
+#define WHC_RXCTL_CH0ACK_Msk                (0x1ul << WHC_RXCTL_CH0ACK_Pos)
+
+#define WHC_RXCTL_CH1ACK_Pos                (1)
+#define WHC_RXCTL_CH1ACK_Msk                (0x1ul << WHC_RXCTL_CH1ACK_Pos)
+
+#define WHC_RXCTL_CH2ACK_Pos                (2)
+#define WHC_RXCTL_CH2ACK_Msk                (0x1ul << WHC_RXCTL_CH2ACK_Pos)
+
+#define WHC_RXCTL_CH3ACK_Pos                (3)
+#define WHC_RXCTL_CH3ACK_Msk                (0x1ul << WHC_RXCTL_CH3ACK_Pos)
+
+#define WHC_RXSTS_CH0RDY_Pos                (0)
+#define WHC_RXSTS_CH0RDY_Msk                (0x1ul << WHC_RXSTS_CH0RDY_Pos)
+
+#define WHC_RXSTS_CH1RDY_Pos                (1)
+#define WHC_RXSTS_CH1RDY_Msk                (0x1ul << WHC_RXSTS_CH1RDY_Pos)
+
+#define WHC_RXSTS_CH2RDY_Pos                (2)
+#define WHC_RXSTS_CH2RDY_Msk                (0x1ul << WHC_RXSTS_CH2RDY_Pos)
+
+#define WHC_RXSTS_CH3RDY_Pos                (3)
+#define WHC_RXSTS_CH3RDY_Msk                (0x1ul << WHC_RXSTS_CH3RDY_Pos)
+
+#define WHC_TMDAT_DAT_Pos                   (0)
+#define WHC_TMDAT_DAT_Msk                   (0xfffffffful << WHC_TMDAT_DAT_Pos)
+
+#define WHC_RMDAT_DAT_Pos                   (0)
+#define WHC_RMDAT_DAT_Msk                   (0xfffffffful << WHC_RMDAT_DAT_Pos)
+
+#define WHC0                  ((volatile WHC_T *)   WHC0_BASE)
+#define WHC1                  ((volatile WHC_T *)   WHC1_BASE)
+
+#endif
+
diff --git a/plat/nuvoton/ma35d1/ma35d1_bl2_el3_setup.c b/plat/nuvoton/ma35d1/ma35d1_bl2_el3_setup.c
new file mode 100644
index 0000000..9710ac3
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_bl2_el3_setup.c
@@ -0,0 +1,32 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <common/debug.h>
+#include <plat/arm/common/plat_arm.h>
+
+#include "ma35d1_private.h"
+
+void bl2_el3_early_platform_setup(u_register_t arg0 __unused,
+				  u_register_t arg1 __unused,
+				  u_register_t arg2 __unused,
+				  u_register_t arg3 __unused)
+{
+	/* Initialize the platform config for future decision making */
+	ma35d1_config_setup();
+
+	ma35d1_ddr_init();
+
+	/*
+	 * Initialize Interconnect for this cluster during cold boot.
+	 * No need for locks as no other CPU is active.
+	 */
+	ma35d1_interconnect_init();
+	/*
+	 * Enable coherency in Interconnect for the primary CPU's cluster.
+	 */
+	ma35d1_interconnect_enable();
+
+}
diff --git a/plat/nuvoton/ma35d1/ma35d1_bl2_mem_params_desc.c b/plat/nuvoton/ma35d1/ma35d1_bl2_mem_params_desc.c
new file mode 100644
index 0000000..9500b50
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_bl2_mem_params_desc.c
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <common/bl_common.h>
+#include <common/desc_image_load.h>
+#include <plat/common/platform.h>
+
+/*******************************************************************************
+ * Following descriptor provides BL image/ep information that gets used
+ * by BL2 to load the images and also subset of this information is
+ * passed to next BL image. The image loading sequence is managed by
+ * populating the images in required loading order. The image execution
+ * sequence is managed by populating the `next_handoff_image_id` with
+ * the next executable image id.
+ ******************************************************************************/
+static bl_mem_params_node_t bl2_mem_params_descs[] = {
+#ifdef MA35D1_LOAD_SCP_BL2
+	{
+		.image_id = SCP_BL2_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, entry_point_info_t,
+				      NON_SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_IMAGE_BINARY,
+				      VERSION_2, image_info_t, 0),
+		.image_info.image_base = SCP_BL2_BASE,
+		.image_info.image_max_size = SCP_BL2_SIZE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+#endif
+	{
+		.image_id = BL31_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+			VERSION_2, entry_point_info_t,
+			SECURE | EXECUTABLE | EP_FIRST_EXE),
+
+		.ep_info.pc = BL31_BASE,
+		.ep_info.spsr = SPSR_64(MODE_EL3, MODE_SP_ELX,
+			DISABLE_ALL_EXCEPTIONS),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+			VERSION_2, image_info_t, IMAGE_ATTRIB_PLAT_SETUP),
+
+		.image_info.image_base = BL31_BASE,
+		.image_info.image_max_size = BL31_LIMIT - BL31_BASE,
+
+#ifdef MA35D1_LOAD_BL32
+		.next_handoff_image_id = BL32_IMAGE_ID,
+#else
+		.next_handoff_image_id = BL33_IMAGE_ID,
+#endif
+	},
+#ifdef MA35D1_LOAD_BL32
+	/* Fill BL32 related information */
+	{
+		.image_id = BL32_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+			VERSION_2, entry_point_info_t,
+			SECURE | EXECUTABLE ),
+
+		.ep_info.pc = BL32_BASE,
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+			VERSION_2, image_info_t,
+			0),
+
+		.image_info.image_base = BL32_BASE,
+		.image_info.image_max_size = BL32_LIMIT - BL32_BASE,
+
+		.next_handoff_image_id = BL33_IMAGE_ID,
+	},
+
+	/*
+	 * Fill BL32 external 1 related information.
+	 * A typical use for extra1 image is with OP-TEE where it is the pager image.
+	 */
+	{
+		.image_id = BL32_EXTRA1_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+			VERSION_2, entry_point_info_t, SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+			VERSION_2, image_info_t, IMAGE_ATTRIB_SKIP_LOADING),
+
+		.image_info.image_base = BL32_BASE,
+		.image_info.image_max_size = BL32_LIMIT - BL32_BASE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+	/*
+	 * Fill BL32 external 2 related information.
+	 * A typical use for extra2 image is with OP-TEE where it is the paged image.
+	 */
+	{
+		.image_id = BL32_EXTRA2_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+			VERSION_2, entry_point_info_t, SECURE | NON_EXECUTABLE),
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+			VERSION_2, image_info_t, IMAGE_ATTRIB_SKIP_LOADING),
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+	},
+#endif
+	/* Fill BL33 related information */
+	{
+		.image_id = BL33_IMAGE_ID,
+
+		SET_STATIC_PARAM_HEAD(ep_info, PARAM_EP,
+			VERSION_2, entry_point_info_t,
+			NON_SECURE | EXECUTABLE),
+
+		.ep_info.pc = BL33_BASE,
+
+		SET_STATIC_PARAM_HEAD(image_info, PARAM_EP,
+			VERSION_2, image_info_t, 0),
+
+		.image_info.image_base = BL33_BASE,
+		.image_info.image_max_size = BL33_LIMIT - BL33_BASE,
+
+		.next_handoff_image_id = INVALID_IMAGE_ID,
+
+	}
+};
+
+REGISTER_BL_IMAGE_DESCS(bl2_mem_params_descs)
diff --git a/plat/nuvoton/ma35d1/ma35d1_bl2_setup.c b/plat/nuvoton/ma35d1/ma35d1_bl2_setup.c
new file mode 100644
index 0000000..49572ca
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_bl2_setup.c
@@ -0,0 +1,195 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <drivers/arm/sp804_delay_timer.h>
+#include <common/desc_image_load.h>
+#include <drivers/generic_delay_timer.h>
+#include <lib/mmio.h>
+#include <plat/arm/common/plat_arm.h>
+#include <plat/common/platform.h>
+#include <platform_def.h>
+#include <common/debug.h>
+#include <lib/optee_utils.h>
+
+#include "ma35d1_private.h"
+
+void bl2_early_platform_setup2(u_register_t arg0, u_register_t arg1, u_register_t arg2, u_register_t arg3)
+{
+	arm_bl2_early_platform_setup((uintptr_t)arg0, (meminfo_t *)arg1);
+
+	/* Initialize the platform config for future decision making */
+	ma35d1_config_setup();
+}
+
+/*
+ * bl2_platform_setup()
+ * MMU on - enabled by bl2_el3_plat_arch_setup()
+ */
+void bl2_platform_setup(void)
+{
+}
+
+
+void bl2_el3_plat_arch_setup(void)
+{
+	/* Setup the MMU here */
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+	/* Prevent corruption of preloaded Device Tree */
+	mmap_add_region(DTB_BASE, DTB_BASE,
+			DTB_LIMIT - DTB_BASE,
+			MT_RO_DATA | MT_SECURE);
+
+	/* config MMC */
+	configure_mmu();
+
+	generic_delay_timer_init();
+
+	/* TODO: system config initial, power? */
+
+	ma35d1_arch_security_setup();
+
+	ma35d1_io_setup();
+}
+
+/*******************************************************************************
+ * Transfer SCP_BL2 from Trusted RAM using the SCP Download protocol.
+ * Return 0 on success, -1 otherwise.
+ ******************************************************************************/
+int plat_ma35d1_bl2_handle_scp_bl2(image_info_t *scp_bl2_image_info)
+{
+	if (scp_bl2_image_info->image_size > 0x80000) {	/* 512KB */
+		WARN("code size is large than 512KB\n");
+		return -1;
+	}
+
+	/* unlock */
+	outp32((void *)SYS_RLKTZS, 0x59);
+	outp32((void *)SYS_RLKTZS, 0x16);
+	outp32((void *)SYS_RLKTZS, 0x88);
+
+	/* Stop MCU - Enable M4 Core reset */
+	outp32((void *)(SYS_BA+0x20), inp32((void *)(SYS_BA+0x20)) | 0x8);
+
+	/* Load MCU binary into SRAM and DDR, depend on image size */
+	if (scp_bl2_image_info->image_size <= 0x20000) {	/* 128KB */
+		memcpy((void *)0x24000000, (void *)scp_bl2_image_info->image_base, scp_bl2_image_info->image_size);
+	}
+	else {
+		memcpy((void *)0x24000000, (void *)scp_bl2_image_info->image_base, 0x20000);
+		memcpy((void *)0x80020000, (void *)scp_bl2_image_info->image_base+0x20000, scp_bl2_image_info->image_size-0x20000);
+	}
+	flush_dcache_range(0x24000000,scp_bl2_image_info->image_size);
+
+	/* Enable RTP clock */
+	outp32((void *)CLK_SYSCLK0, inp32((void *)CLK_SYSCLK0) | 0x2);
+
+	/* lock */
+	outp32((void *)SYS_RLKTZS, 0);
+
+	INFO("Load RTP M4\n");
+
+	return 0;
+}
+
+/*******************************************************************************
+ * Gets SPSR for BL32 entry
+ ******************************************************************************/
+static uint32_t ma35d1_get_spsr_for_bl32_entry(void)
+{
+	return 0;
+}
+
+/*******************************************************************************
+ * Gets SPSR for BL33 entry
+ ******************************************************************************/
+static uint32_t ma35d1_get_spsr_for_bl33_entry(void)
+{
+	unsigned int mode;
+	uint32_t spsr;
+
+	/* Figure out what mode we enter the non-secure world in */
+	mode = el_implemented(2) ? MODE_EL2 : MODE_EL1;
+
+	/*
+	 * TODO: Consider the possibility of specifying the SPSR in
+	 * the FIP ToC and allowing the platform to have a say as
+	 * well.
+	 */
+	spsr = SPSR_64(mode, MODE_SP_ELX, DISABLE_ALL_EXCEPTIONS);
+	return spsr;
+}
+
+/*******************************************************************************
+ * This function can be used by the platforms to update/use image
+ * information for given `image_id`.
+ ******************************************************************************/
+int bl2_plat_handle_post_image_load(unsigned int image_id)
+{
+	int err = 0;
+	bl_mem_params_node_t *bl_mem_params = get_bl_mem_params_node(image_id);
+
+	bl_mem_params_node_t *pager_mem_params;
+	bl_mem_params_node_t *paged_mem_params = NULL;
+
+	assert(bl_mem_params != NULL);
+
+	switch (image_id) {
+	case BL32_IMAGE_ID:
+		pager_mem_params = get_bl_mem_params_node(BL32_EXTRA1_IMAGE_ID);
+		assert(pager_mem_params);
+
+		paged_mem_params = get_bl_mem_params_node(BL32_EXTRA2_IMAGE_ID);
+		assert(paged_mem_params);
+
+		err = parse_optee_header(&bl_mem_params->ep_info,
+				&pager_mem_params->image_info,
+				&paged_mem_params->image_info);
+		if (err != 0) {
+			WARN("OPTEE header parse error.\n");
+		}
+
+		/*
+		 * When ATF loads the DTB the address of the DTB is passed in
+		 * arg2, if an hw config image is present use the base address
+		 * as DTB address an pass it as arg2
+		 */
+		bl_mem_params->ep_info.args.arg0 = bl_mem_params->ep_info.args.arg1;
+		bl_mem_params->ep_info.args.arg1 = 0;
+		bl_mem_params->ep_info.args.arg2 = 0;
+		bl_mem_params->ep_info.args.arg3 = 0;
+
+		bl_mem_params->ep_info.spsr = ma35d1_get_spsr_for_bl32_entry();
+
+		break;
+
+	case BL33_IMAGE_ID:
+		/* BL33 expects to receive the primary CPU MPID (through r0) */
+		bl_mem_params->ep_info.args.arg0 = 0xffff & read_mpidr();
+		bl_mem_params->ep_info.spsr = ma35d1_get_spsr_for_bl33_entry();
+		break;
+
+	case SCP_BL2_IMAGE_ID:
+		/* The subsequent handling of SCP_BL2 is platform specific */
+		err = plat_ma35d1_bl2_handle_scp_bl2(&bl_mem_params->image_info);
+		if (err) {
+			WARN("Failure in platform-specific handling of SCP_BL2 image.\n");
+		}
+		break;
+
+	default:
+		/* Do nothing in default case */
+		break;
+	}
+
+	return err;
+}
+
+
diff --git a/plat/nuvoton/ma35d1/ma35d1_bl31_setup.c b/plat/nuvoton/ma35d1/ma35d1_bl31_setup.c
new file mode 100644
index 0000000..85fe3f3
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_bl31_setup.c
@@ -0,0 +1,168 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <common/debug.h>
+#include <plat/arm/common/arm_config.h>
+#include <plat/arm/common/plat_arm.h>
+#include <plat/common/platform.h>
+#include <drivers/generic_delay_timer.h>
+#include <drivers/arm/gicv2.h>
+
+#include <lib/debugfs.h>
+
+#include "ma35d1_private.h"
+
+/*
+ * Placeholder variables for copying the arguments that have been passed to
+ * BL31 from BL2.
+ */
+static entry_point_info_t bl32_image_ep_info;
+static entry_point_info_t bl33_image_ep_info;
+
+
+void bl31_early_platform_setup2(u_register_t arg0,
+		u_register_t arg1, u_register_t arg2, u_register_t arg3)
+{
+	/* Initialize the platform config for future decision making */
+	ma35d1_config_setup();
+
+	/*************************************************************/
+	/*
+	 * Check params passed from BL2 should not be NULL,
+	 */
+	bl_params_t *params_from_bl2 = (bl_params_t *)arg0;
+	assert(params_from_bl2 != NULL);
+	assert(params_from_bl2->h.type == PARAM_BL_PARAMS);
+	assert(params_from_bl2->h.version >= VERSION_2);
+
+	bl_params_node_t *bl_params = params_from_bl2->head;
+
+	/*
+	 * Copy BL33 and BL32 (if present), entry point information.
+	 * They are stored in Secure RAM, in BL2's address space.
+	 */
+	while (bl_params != NULL) {
+		if (bl_params->image_id == BL32_IMAGE_ID)
+			bl32_image_ep_info = *bl_params->ep_info;
+
+		if (bl_params->image_id == BL33_IMAGE_ID)
+			bl33_image_ep_info = *bl_params->ep_info;
+
+		bl_params = bl_params->next_params_info;
+	}
+
+	if (bl33_image_ep_info.pc == 0U)
+		panic();
+
+	/*************************************************************/
+
+	/*
+	 * Initialize the correct interconnect for this cluster during cold
+	 * boot. No need for locks as no other CPU is active.
+	 */
+	ma35d1_interconnect_init();
+
+	/*
+	 * Enable coherency in interconnect for the primary CPU's cluster.
+	 * Earlier bootloader stages might already do this (e.g. Trusted
+	 * Firmware's BL1 does it) but we can't assume so. There is no harm in
+	 * executing this code twice anyway.
+	 * MA35D1 PSCI code will enable coherency for other clusters.
+	 */
+	ma35d1_interconnect_enable();
+
+	/* Initialize System level generic or SP804 timer */
+	ma35d1_timer_init();
+
+}
+
+void bl31_plat_arch_setup(void)
+{
+	mmap_add_region(BL_CODE_BASE, BL_CODE_BASE,
+			BL_CODE_END - BL_CODE_BASE,
+			MT_CODE | MT_SECURE);
+
+	/* config MMC */
+	configure_mmu();
+}
+
+/*******************************************************************************
+ * Return a pointer to the 'entry_point_info' structure of the next image for the
+ * security state specified. BL33 corresponds to the non-secure image type
+ * while BL32 corresponds to the secure image type. A NULL pointer is returned
+ * if the image does not exist.
+ ******************************************************************************/
+entry_point_info_t *bl31_plat_get_next_image_ep_info(unsigned int type)
+{
+	if (type == NON_SECURE)
+		return &bl33_image_ep_info;
+	if (type == SECURE)
+		return &bl32_image_ep_info;
+
+	return NULL;
+}
+
+
+/*******************************************************************************
+ * GICv2 driver setup information
+ ******************************************************************************/
+static const interrupt_prop_t nvt_interrupt_props[] = {
+	INTR_PROP_DESC(ARM_IRQ_SEC_PHY_TIMER, GIC_HIGHEST_SEC_PRIORITY,
+		       GICV2_INTR_GROUP0, GIC_INTR_CFG_LEVEL),
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_0, GIC_HIGHEST_SEC_PRIORITY,
+		       GICV2_INTR_GROUP0, GIC_INTR_CFG_LEVEL),
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_1, GIC_HIGHEST_SEC_PRIORITY,
+		       GICV2_INTR_GROUP0, GIC_INTR_CFG_LEVEL),
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_2, GIC_HIGHEST_SEC_PRIORITY,
+		       GICV2_INTR_GROUP0, GIC_INTR_CFG_LEVEL),
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_3, GIC_HIGHEST_SEC_PRIORITY,
+		       GICV2_INTR_GROUP0, GIC_INTR_CFG_LEVEL),
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_4, GIC_HIGHEST_SEC_PRIORITY,
+		       GICV2_INTR_GROUP0, GIC_INTR_CFG_LEVEL),
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_5, GIC_HIGHEST_SEC_PRIORITY,
+		       GICV2_INTR_GROUP0, GIC_INTR_CFG_LEVEL),
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_6, GIC_HIGHEST_SEC_PRIORITY,
+		       GICV2_INTR_GROUP0, GIC_INTR_CFG_LEVEL),
+	INTR_PROP_DESC(ARM_IRQ_SEC_SGI_7, GIC_HIGHEST_SEC_PRIORITY,
+		       GICV2_INTR_GROUP0, GIC_INTR_CFG_LEVEL)
+};
+
+static unsigned int target_mask_array[PLATFORM_CORE_COUNT];
+
+gicv2_driver_data_t arm_gic_data = {
+	.gicd_base = BASE_GICD_BASE,
+	.gicc_base = BASE_GICC_BASE,
+	.interrupt_props = nvt_interrupt_props,
+	.interrupt_props_num = ARRAY_SIZE(nvt_interrupt_props),
+	.target_masks = target_mask_array,
+	.target_masks_num = ARRAY_SIZE(target_mask_array),
+};
+
+
+/*******************************************************************************
+ * Perform any BL3-1 platform setup code
+ ******************************************************************************/
+void bl31_platform_setup(void)
+{
+	generic_delay_timer_init();
+
+	/* Initialize the gic cpu and distributor interfaces */
+	gicv2_driver_init(&arm_gic_data);
+	gicv2_distif_init();
+	gicv2_pcpu_distif_init();
+	gicv2_cpuif_enable();
+
+	plat_ma35d1_init();
+}
+
+void bl31_plat_runtime_setup(void)
+{
+}
+
+
+
diff --git a/plat/nuvoton/ma35d1/ma35d1_common.c b/plat/nuvoton/ma35d1/ma35d1_common.c
new file mode 100644
index 0000000..974916a
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_common.c
@@ -0,0 +1,382 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <common/debug.h>
+#include <drivers/arm/cci.h>
+#include <drivers/arm/ccn.h>
+#include <drivers/arm/gicv2.h>
+#include <drivers/arm/sp804_delay_timer.h>
+#include <drivers/generic_delay_timer.h>
+#include <lib/mmio.h>
+#include <libfdt.h>
+#include <lib/xlat_tables/xlat_tables_compat.h>
+#include <plat/arm/common/arm_config.h>
+#include <plat/arm/common/plat_arm.h>
+#include <plat/common/platform.h>
+#include <platform_def.h>
+#include <services/spm_mm_partition.h>
+#include <common/fdt_wrappers.h>
+#include <drivers/nuvoton/ma35d1_pmic.h>
+
+#include "ma35d1_private.h"
+
+/* Defines for GIC Driver build time selection */
+#define MA35D1_GICV2		1
+#define MA35D1_GICV3		2
+
+/*******************************************************************************
+ * arm_config holds the characteristics of the differences between the
+ * three MA35D1 platforms (Base, A53_A57 & Foundation). It will be
+ * populated during cold boot at each boot stage by the primary before
+ * enabling the MMU (to allow interconnect configuration) & used thereafter.
+ * Each BL will have its own copy to allow independent operation.
+ ******************************************************************************/
+arm_config_t arm_config;
+
+#if MA35D1_INTERCONNECT_DRIVER != MA35D1_CCN
+
+static unsigned int get_interconnect_master(void)
+{
+	unsigned int master;
+	u_register_t mpidr;
+
+	mpidr = read_mpidr_el1();
+	master = ((arm_config.flags & ARM_CONFIG_FVP_SHIFTED_AFF) != 0U) ?
+		MPIDR_AFFLVL2_VAL(mpidr) : MPIDR_AFFLVL1_VAL(mpidr);
+
+	assert(master < MA35D1_CLUSTER_COUNT);
+	return master;
+}
+#endif
+
+int console_ma35d1_register(uintptr_t baseaddr, uint32_t clock,
+					uint32_t baud, console_t *console);
+int console_ma35d1_putc(int character, struct console *console);
+int console_ma35d1_getc(struct console *console);
+void console_ma35d1_flush(struct console *console);
+static console_t ma35d1_console;
+
+static console_t ma35d1_console = {
+	.flags = CONSOLE_FLAG_BOOT | CONSOLE_FLAG_RUNTIME |
+			CONSOLE_FLAG_CRASH | CONSOLE_FLAG_TRANSLATE_CRLF,
+	.putc = console_ma35d1_putc,
+	.getc = console_ma35d1_getc,
+	.flush = console_ma35d1_flush,
+};
+
+void ma35d1_i2c0_init(unsigned int sys_clk);
+
+/* CPU-PLL: 1000MHz 800MHz 700MHz */
+static unsigned int CAPLL_MODE0[3] = {
+	0x000006FA,	/* 1000 MHz */
+	0x00000364,	/* 800 MHz */
+	0x000006AF,	/* 700 MHz */
+};
+
+static void *fdt = (void *)(uintptr_t)MA35D1_DTB_BASE;
+
+static void ma35d1_clock_setup(void)
+{
+	unsigned int pllmode[6] = { 0, 0, 0, 0, 0, 0 };
+	unsigned int pllfreq[6] = { 0, 0, 0, 0, 0, 0 };
+	unsigned int speed = 500000000;
+	unsigned int clock, index = 2;
+	int node;
+
+	/* get device tree information */
+	if (fdt_check_header(fdt) < 0) {
+		WARN("device tree header check error.\n");
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, "nuvoton,ma35d1-clk");
+	if (node < 0) {
+		WARN("The compatible property `nuvoton,ma35d1-clk` not found\n");
+	}
+
+	fdt_read_uint32_array(fdt, node, "clock-pll-mode", 6, pllmode);
+	fdt_read_uint32_array(fdt, node, "assigned-clock-rates", 6, pllfreq);
+
+	/* E-PLL: 500MHz */
+	if ((inp32((void *)CLK_PLL4CTL1) & 0x1) == 0x1) {
+		outp32((void *)CLK_PLL4CTL0, 0x000060FA);
+		outp32((void *)CLK_PLL4CTL1, 0x00000020);
+		outp32((void *)CLK_PLL4CTL2, 0x0);
+		/* check PLL stable */
+		while (1) {
+			if ((inp32((void *)CLK_STATUS) & 0x200) == 0x200)
+				break;
+		}
+	}
+
+	pmic_clk = pllfreq[1]; /* I2C0 clck for PMIC */
+
+	/* CA-PLL */
+	clock = (pllfreq[0] < speed) ? speed : pllfreq[0];
+	switch (clock) {
+	case 1000000000: /* 1.302V */
+		/* set the voltage VDD_CPU first */
+		if (ma35d1_set_pmic(VOL_CPU, VOL_1_30))
+			INFO("CA-PLL is %d Hz\n", clock);
+		else
+			WARN("CA-PLL is %d Hz without PSCI setting.\n",
+				clock);
+		index = 0;
+		break;
+	case 800000000: /* 1.248V */
+			/* set the voltage VDD_CPU first */
+			if (ma35d1_set_pmic(VOL_CPU, VOL_1_25))
+				INFO("CA-PLL is %d Hz\n", clock);
+			else
+				WARN("CA-PLL is %d Hz without PSCI setting.\n",
+					clock);
+			break;
+			index = 1;
+	case 700000000:
+			index = 2;
+			INFO("CA-PLL is %d Hz\n", clock);
+			break;
+	default:
+			INFO("CA-PLL is %d Hz\n", clock);
+			return;
+	};
+
+	/* DDR-PLL */
+	/* Set DDR-PLL control register0 */
+	outp32((void *)CLK_BA + 0x80,0x0F04102C);  //for DDRPLL is 266Mhz
+	/* Set DDR-PLL control register1 */
+	outp32((void *)CLK_BA + 0x84,0x6B851E40);
+	/* Set DDR-PLL control register2 */
+	outp32((void *)CLK_BA + 0x88,0x000048A3);
+	/* polling DDR-PLL stable */
+	while((inp32((void *)CLK_BA + 0x50) & 0x00000100) != 0x00000100);
+
+	/* set CA35 to E-PLL */
+	outp32((void *)CLK_CLKSEL0, (inp32((void *)CLK_CLKSEL0) & ~0x3) | 0x2);
+
+	outp32((void *)CLK_PLL0CTL0, CAPLL_MODE0[index]);
+
+	/* check PLL stable */
+	while (1) {
+		if ((inp32((void *)CLK_STATUS) & 0x40) == 0x40)
+			break;
+	}
+	/* set CA35 to CA-PLL */
+	outp32((void *)CLK_CLKSEL0, (inp32((void *)CLK_CLKSEL0) & ~0x3) | 0x1);
+
+	/* check LXT */
+	if (fdt_read_uint32_default(fdt, node, "lxt-enable", 0) == 1) {
+		outp32((void *)CLK_PWRCTL, inp32((void *)CLK_PWRCTL) | 0x2);
+	}
+
+	/* Enable RTC clock */
+	outp32((void *)CLK_APBCLK0, inp32((void*)CLK_APBCLK0) | (0x1 << 29));
+	if (fdt_read_uint32_default(fdt, node, "rtc-pwrctl-enable", 1) == 1)
+		outp32((void *)(0x40410180),
+			inp32((void *)(0x40410180)) |
+			0x5aa50040);  /* power control enable */
+	else	/* power control disable */
+		outp32((void *)(0x40410180),
+			(inp32((void *)(0x40410180)) & ~0xffff0040) |
+			0x5aa50000);
+
+	/* Set PH8/PH9 */
+	if (fdt_read_uint32_default(fdt, node, "set-ph8-ph9-hight", 1) == 1) {
+		outp32((void *)(0x40410100),
+			(inp32((void *)(0x40410100)) & ~0x00000100) |
+			0x00000100);  /* Enable IOCTLSET */
+
+		outp32((void *)(0x40410104),
+			(inp32((void *)(0x40410104)) & ~0x00000707) |
+			0x00000505); /* Set PH8/PH9 output high */
+	}
+	else {
+		outp32((void *)(0x40410100),
+			(inp32((void *)(0x40410100)) & ~0x00000100));  /* Disable IOCTLSET */
+	}
+
+}
+
+/*******************************************************************************
+ * A single boot loader stack is expected to work on both the Foundation MA35D1
+ * models and the two flavours of the Base MA35D1 models (AEMv8 & Cortex). The
+ * SYS_ID register provides a mechanism for detecting the differences between
+ * these platforms. This information is stored in a per-BL array to allow the
+ * code to take the correct path.Per BL platform configuration.
+ ******************************************************************************/
+void __init ma35d1_config_setup(void)
+{
+	/* unlock */
+	outp32((void *)SYS_RLKTZS, 0x59);
+	outp32((void *)SYS_RLKTZS, 0x16);
+	outp32((void *)SYS_RLKTZS, 0x88);
+
+	/* Enable UART0 clock */
+	outp32((void *)CLK_APBCLK0, inp32((void *)CLK_APBCLK0) | (1 << 12));
+	outp32((void *)CLK_CLKSEL2, inp32((void *)CLK_CLKSEL2) & ~(3 << 16));
+	outp32((void *)CLK_CLKDIV1, inp32((void *)CLK_CLKDIV1) & ~(0xf << 16));
+	/* UART0 multi-function */
+	outp32((void *)SYS_GPE_MFPH, (inp32((void *)SYS_GPE_MFPH) &
+			~0xff000000) | 0x11000000);
+
+	console_ma35d1_register(PLAT_ARM_CRASH_UART_BASE,
+				PLAT_ARM_CRASH_UART_CLK_IN_HZ,
+				ARM_CONSOLE_BAUDRATE,
+				&ma35d1_console);
+
+	INFO("ma35d1 config setup\n");
+
+	/* Set the PLL */
+	ma35d1_clock_setup();
+
+}
+
+
+void __init ma35d1_interconnect_init(void)
+{
+}
+
+void ma35d1_interconnect_enable(void)
+{
+	unsigned int master;
+
+	if ((arm_config.flags & (ARM_CONFIG_FVP_HAS_CCI400 |
+				 ARM_CONFIG_FVP_HAS_CCI5XX)) != 0U) {
+		master = get_interconnect_master();
+		cci_enable_snoop_dvm_reqs(master);
+	}
+}
+
+void ma35d1_interconnect_disable(void)
+{
+	unsigned int master;
+
+	if ((arm_config.flags & (ARM_CONFIG_FVP_HAS_CCI400 |
+				 ARM_CONFIG_FVP_HAS_CCI5XX)) != 0U) {
+		master = get_interconnect_master();
+		cci_disable_snoop_dvm_reqs(master);
+	}
+}
+
+unsigned int plat_get_syscnt_freq2(void)
+{
+	return SYS_COUNTER_FREQ_IN_TICKS;
+}
+
+void ma35d1_timer_init(void)
+{
+	generic_delay_timer_init();
+}
+
+void plat_ma35d1_init(void)
+{
+	int value_len = 0, i, count = 0;
+	int node;
+	unsigned int cells[70 * 3];
+	unsigned int reg;
+
+	/* unlock */
+	outp32((void *)SYS_RLKTZS, 0x59);
+	outp32((void *)SYS_RLKTZS, 0x16);
+	outp32((void *)SYS_RLKTZS, 0x88);
+
+	/* get device tree information */
+	if (fdt_check_header(fdt) < 0) {
+		WARN("device tree header check error.\n");
+	}
+
+	/* enable CRYPTO */
+	if ((inp32((void *)SYS_CHIPCFG) & 0x100) == 0x100) {
+		/* un-lock */
+		do {
+			outp32((void *)(TSI_SYS_BASE+0x100), 0x59);
+			outp32((void *)(TSI_SYS_BASE+0x100), 0x16);
+			outp32((void *)(TSI_SYS_BASE+0x100), 0x88);
+		} while (inp32((void *)(TSI_SYS_BASE+0x100)) == 0UL);
+
+		/* set TSI-PLL to HIRC */
+		if ((inp32((void *)(TSI_CLK_BASE+0x10)) & 0x7) == 0x2) {
+			outp32((void *)(TSI_CLK_BASE+0x10),
+				inp32((void *)(TSI_CLK_BASE+0x10)) & ~0x7);
+		}
+		/* PLL to 200 MHz */
+		outp32((void *)(TSI_CLK_BASE+0x40), 0x808cc8);
+		while (1) {
+			if ((inp32((void *)(TSI_CLK_BASE+0x50))
+				& 0x4) == 0x4) {
+				outp32((void *)(TSI_CLK_BASE+0x10),
+					(inp32((void *)(TSI_CLK_BASE+0x10)) &
+					~0x7) | 0x2);
+				break;
+			}
+		}
+		/* initial crypto engine and ks clock */
+		outp32((void *)(TSI_CLK_BASE+0x04),
+			    (inp32((void *)(TSI_CLK_BASE+0x04)) | 0x5000));
+		/* initial trng clock */
+		outp32((void *)(TSI_CLK_BASE+0x0c),
+			    (inp32((void *)(TSI_CLK_BASE+0x0c)) |
+			    0x2000000));
+
+		/* Init KeyStore */
+		/* KS INIT(KS_CTL[8]) + START(KS_CTL[0]) */
+		outp32((void *)(KS_BASE+0x00), 0x101);
+		while ((inp32((void *)(KS_BASE+0x08)) & 0x80) == 0)
+			;   /* wait for INITDONE(KS_STS[7]) set */
+		while (inp32((void *)(KS_BASE+0x08)) & 0x4)
+			;      /* wait for BUSY(KS_STS[2]) cleared */
+	}
+
+	node = fdt_node_offset_by_compatible(fdt, -1, "nuvoton,ma35d1-sspcc");
+	if (node < 0) {
+		WARN("The compatible property `nuvoton,ma35d1-sspcc` not found\n");
+	}
+	/* Enable RTP clock */
+	outp32((void *)CLK_SYSCLK0, inp32((void *)CLK_SYSCLK0) | 0x2);
+	/* enable SSPCC/GPIO clock */
+	outp32((void *)CLK_APBCLK2, inp32((void *)CLK_APBCLK2) | 0x8);
+	outp32((void *)CLK_SYSCLK1, inp32((void *)CLK_SYSCLK1) | 0x3FFF0000);
+	/* set GPIO to TZNS */
+	for (i = 0; i < 0x38; i += 4)
+		outp32(SSPCC_BASE+0x60+i, 0x55555555);
+
+	/* get peripheral attribution from DTB */
+	if (fdt_getprop(fdt, node, "config", &value_len) != 0) {
+		count = value_len / 4;
+		fdt_read_uint32_array(fdt, node, "config", count, cells);
+
+		for (i = 0; i < count; i += 3) {
+			reg = inp32(SSPCC_BASE+cells[i]) &
+					    ~(0x3 << cells[i+1]);
+			outp32(SSPCC_BASE+cells[i], reg |
+				    cells[i+2] << cells[i+1]);
+		}
+	}
+
+	if (fdt_getprop(fdt, node, "gpio_s", &value_len) != 0) {
+		count = value_len / 4;
+		fdt_read_uint32_array(fdt, node, "gpio_s", count, cells);
+
+		for (i = 0; i < count; i += 3) {
+			reg = inp32(SSPCC_BASE+cells[i]) &
+					    ~(0x3 << cells[i+1]);
+			outp32(SSPCC_BASE+cells[i],  reg | cells[i+2] <<
+				    cells[i+1]);
+		}
+	}
+
+	/* enable WDT1/WDT2 reset */
+	outp32((void *)(SYS_BA+0x14), 0x70000);
+
+	/* Let MCU running - Disable M4 Core reset */
+	outp32((void *)(SYS_BA+0x20), inp32((void *)(SYS_BA+0x20)) & ~0x8);
+
+	/* lock */
+	outp32((void *)SYS_RLKTZS, 0);
+}
+
+
diff --git a/plat/nuvoton/ma35d1/ma35d1_def.h b/plat/nuvoton/ma35d1/ma35d1_def.h
new file mode 100644
index 0000000..adbbde6
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_def.h
@@ -0,0 +1,241 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef _MA35D1_DEF_H_
+#define _MA35D1_DEF_H_
+
+#include <lib/utils_def.h>
+
+#ifndef MA35D1_CLUSTER_COUNT
+#define MA35D1_CLUSTER_COUNT		1
+#endif
+
+#ifndef MA35D1_MAX_CPUS_PER_CLUSTER
+#define MA35D1_MAX_CPUS_PER_CLUSTER	2
+#endif
+
+#ifndef MA35D1_MAX_PE_PER_CPU
+#define MA35D1_MAX_PE_PER_CPU		1
+#endif
+
+#define MA35D1_PRIMARY_CPU		0x0
+
+/* Defines for the Interconnect build selection */
+#define MA35D1_CCI			1
+#define MA35D1_CCN			2
+
+#define MAX_IO_DEVICES			U(2)
+#define MAX_IO_HANDLES			U(2)
+#define MAX_IO_BLOCK_DEVICES		U(1)
+//#define MAX_IO_MTD_DEVICES		U(1)
+
+/* Define maximum page size for NAND devices */
+//#define PLATFORM_MTD_MAX_PAGE_SIZE	U(0x2000)
+
+/*******************************************************************************
+ * MA35D1 memory map related constants
+ ******************************************************************************/
+//#define MA35D1_ROM_BASE              U(0x5FFC0000)
+//#define MA35D1_ROM_SIZE              U(0x00020000)
+
+#define MA35D1_SRAM0_BASE		U(0x24000000)
+#define MA35D1_SRAM0_SIZE		U(0x00020000)
+
+#define MA35D1_SRAM1_BASE		U(0x28000000)
+#define MA35D1_SRAM1_SIZE		U(0x00040000)
+
+/* DDR configuration */
+#define MA35D1_DDR_BASE		U(0x80000000)
+
+#define MA35D1_BL2_BASE		U(0x28000000)
+#define MA35D1_BL2_SIZE		U(0x00023000)
+
+#define MA35D1_DTB_BASE		U(0x28023000)
+#define MA35D1_DTB_SIZE		U(0x00002000)
+
+#define MA35D1_BL31_BASE		U(0x28025000)
+#define MA35D1_BL31_SIZE		U(0x00016000)	/* 0x2803C000 is reserved to IBR */
+
+#define MA35D1_BL32_SIZE		U(0x00200000)
+
+#define MA35D1_BL33_BASE		U(0x85500000)
+#define MA35D1_BL33_SIZE		U(0x00200000)
+
+#define BL2_BASE			MA35D1_BL2_BASE
+#define BL2_LIMIT			(MA35D1_BL2_BASE + MA35D1_BL2_SIZE)
+
+#define DTB_BASE			MA35D1_DTB_BASE
+#define DTB_LIMIT			(MA35D1_DTB_BASE + MA35D1_DTB_SIZE)
+
+#define SCP_BL2_BASE			U(0x85000000)	/* temp address */
+#define SCP_BL2_SIZE			U(0x00080000)	/* 512KB */
+
+#define MA35D1_FIP_SIZE		0x00200000
+#define MA35D1_FIP_BASE		U(0x86000000)	//(MA35D1_DDR_BASE)
+#define MA35D1_FIP_LIMIT		(MA35D1_FIP_BASE + MA35D1_FIP_SIZE)
+
+/*
+ * Put BL31 at the bottom of TZC secured DRAM
+ */
+#define BL31_BASE			MA35D1_BL31_BASE
+#define BL31_LIMIT			(MA35D1_BL31_BASE + MA35D1_BL31_SIZE)
+
+#define BL32_BASE			MA35D1_BL32_BASE
+#define BL32_LIMIT			(MA35D1_BL32_BASE + MA35D1_BL32_SIZE)
+
+#define BL33_BASE			MA35D1_BL33_BASE
+#define BL33_LIMIT			(MA35D1_BL33_BASE + MA35D1_BL33_SIZE)
+
+/*******************************************************************************
+ * ma35d1 device/io map related constants (used for MMU)
+ ******************************************************************************/
+#define MA35D1_REG_BASE			U(0x40000000)
+#define MA35D1_REG_SIZE			U(0x20000000)
+
+#define MA35D1_DRAM_BASE		U(0x80000000)
+
+#define MA35D1_DRAM_S_SIZE		U(0x00800000)
+
+/* Non-volatile counters */
+//#define TRUSTED_NVCTR_BASE		UL(0x7fe70000)
+//#define TFW_NVCTR_BASE		(TRUSTED_NVCTR_BASE + UL(0x0000))
+//#define TFW_NVCTR_SIZE		UL(4)
+//#define NTFW_CTR_BASE			(TRUSTED_NVCTR_BASE + UL(0x0004))
+//#define NTFW_CTR_SIZE			UL(4)
+
+/* Keys */
+//#define SOC_KEYS_BASE			UL(0x7fe80000)
+//#define TZ_PUB_KEY_HASH_BASE		(SOC_KEYS_BASE + UL(0x0000))
+//#define TZ_PUB_KEY_HASH_SIZE		UL(32)
+//#define HU_KEY_BASE			(SOC_KEYS_BASE + UL(0x0020))
+//#define HU_KEY_SIZE			UL(16)
+//#define END_KEY_BASE			(SOC_KEYS_BASE + UL(0x0044))
+//#define END_KEY_SIZE			UL(32)
+
+/* Constants to distinguish MA35D1 type */
+//#define HBI_BASE_MA35D1		U(0x020)
+//#define REV_BASE_MA35D1_V0		U(0x0)
+//#define REV_BASE_MA35D1_REVC		U(0x2)
+
+//#define HBI_FOUNDATION_MA35D1		U(0x010)
+//#define REV_FOUNDATION_MA35D1_V2_0	U(0x0)
+//#define REV_FOUNDATION_MA35D1_V2_1	U(0x1)
+//#define REV_FOUNDATION_MA35D1_v9_1	U(0x2)
+//#define REV_FOUNDATION_MA35D1_v9_6	U(0x3)
+
+//#define ARCH_MODEL			U(0x1)
+
+/* MA35D1 Power controller base address*/
+#define PWRC_BASE			UL(0x1c100000)
+
+/*******************************************************************************
+ * GIC-400 & interrupt handling related constants
+ ******************************************************************************/
+/* Base MA35D1 compatible GIC memory map */
+#define BASE_GICD_BASE			UL(0x50801000)
+#define BASE_GICR_BASE			0	/* no GICR in GIC-400 */
+#define BASE_GICC_BASE			UL(0x50802000)
+#define BASE_GICH_BASE			UL(0x50804000)
+#define BASE_GICV_BASE			UL(0x50806000)
+
+#define MA35D1_IRQ_TZ_WDOG		39	/* wdt0 */
+#define MA35D1_IRQ_SEC_SYS_TIMER	79	/* tmr0? */
+
+/*******************************************************************************
+ * MA35D1 TZC (TZ400)
+ ******************************************************************************/
+#define MA35D1_TZC0_BASE		U(0x404E1000)
+#define MA35D1_TZC1_BASE		U(0x404E2000)
+#define MA35D1_TZC2_BASE		U(0x404E3000)
+
+/* NSAIDs used by devices in TZC filter 0 on MA35D1 */
+#define MA35D1_NSAID_TZNS		U(0)
+#define MA35D1_NSAID_SUBM		U(1)
+
+#define MA35D1_FILTER_BIT_ALL		U(7)
+
+/*******************************************************************************
+ * Memprotect definitions
+ ******************************************************************************/
+/* PSCI memory protect definitions:
+ * This variable is stored in a non-secure flash because some ARM reference
+ * platforms do not have secure NVRAM. Real systems that provided MEM_PROTECT
+ * support must use a secure NVRAM to store the PSCI MEM_PROTECT definitions.
+ */
+/*#define PLAT_ARM_MEM_PROT_ADDR	(V2M_FLASH0_BASE + V2M_FLASH0_SIZE \
+ *					 - V2M_FLASH_BLOCK_SIZE)
+ */
+
+/*************************************/
+#define UMCTL2_BA       U(0x404d0000)
+#define DDRPHY_BA       U(0x404c0000)
+#define SYS_BA          U(0x40460000)
+#define CLK_BA          U(0x40460200)
+
+/* sys registers */
+#define SYS_PWRONOTP	U(0x40460004)
+#define SYS_PWRONPIN	U(0x40460008)
+#define SYS_IPRST0	U(0x40460020)
+#define SYS_IPRST1	U(0x40460024)
+#define SYS_CHIPCFG	U(0x404601F4)
+
+#define SYS_GPA_MFPL	U(0x40460080)
+#define SYS_GPA_MFPH	U(0x40460084)
+#define SYS_GPC_MFPL	U(0x40460090)
+#define SYS_GPC_MFPH	U(0x40460094)
+#define SYS_GPD_MFPL	U(0x40460098)
+#define SYS_GPE_MFPH	U(0x404600A4)
+#define SYS_GPJ_MFPL	U(0x404600C8)
+#define SYS_GPJ_MFPH	U(0x404600CC)
+
+#define SYS_RLKTZS	U(0x404601A0)
+#define SYS_RLKTZNS	U(0x404601A4)
+
+/* clock registers */
+#define CLK_PWRCTL	U(0x40460200)
+#define CLK_SYSCLK0	U(0x40460204)
+#define CLK_SYSCLK1	U(0x40460208)
+#define CLK_APBCLK0	U(0x4046020C)
+#define CLK_APBCLK1	U(0x40460210)
+#define CLK_APBCLK2	U(0x40460214)
+#define CLK_CLKSEL0	U(0x40460218)
+#define CLK_CLKSEL1	U(0x4046021C)
+#define CLK_CLKSEL2	U(0x40460220)
+#define CLK_CLKDIV1	U(0x40460230)
+#define CLK_STATUS	U(0x40460250)
+
+#define CLK_PLL0CTL0	U(0x40460260)
+#define CLK_PLL0CTL1	U(0x40460264)
+#define CLK_PLL0CTL2	U(0x40460268)
+#define CLK_PLL1CTL0	U(0x40460270)
+#define CLK_PLL1CTL1	U(0x40460274)
+#define CLK_PLL1CTL2	U(0x40460278)
+#define CLK_PLL3CTL0    U(0x40460290)
+#define CLK_PLL3CTL1    U(0x40460294)
+#define CLK_PLL3CTL2    U(0x40460298)
+#define CLK_PLL4CTL0	U(0x404602A0)
+#define CLK_PLL4CTL1	U(0x404602A4)
+#define CLK_PLL4CTL2	U(0x404602A8)
+#define CLK_PLL5CTL0	U(0x404602B0)
+#define CLK_PLL5CTL1	U(0x404602B4)
+#define CLK_PLL5CTL2	U(0x404602B8)
+
+/* sspcc registers */
+#define SSPCC_BASE	U(0x404F0000)
+
+/* crypto define */
+#define CRYPTO_BASE	U(0x40300000)
+#define TSI_SYS_BASE	U(0x40360000)
+#define TSI_CLK_BASE	U(0x40360200)
+#define KS_BASE		U(0x40340000)
+#define WHC0_BASE	U(0x403A0000)
+#define WHC1_BASE	U(0x503B0000)
+
+#define outp32(addr, data) (*(volatile uint32_t *)((uint64_t)(addr))) = (data)
+#define inp32(addr) (*(volatile uint32_t *)((uint64_t)(addr)))
+#define inp8(addr) (*(volatile uint8_t *)((uint64_t)(addr)))
+
+#endif /* _MA35D1_DEF_H_ */
diff --git a/plat/nuvoton/ma35d1/ma35d1_image_load.c b/plat/nuvoton/ma35d1/ma35d1_image_load.c
new file mode 100644
index 0000000..042c1f9
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_image_load.c
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <common/bl_common.h>
+#include <common/desc_image_load.h>
+#if defined(SPD_spmd)
+#include <plat/arm/common/fconf_arm_sp_getter.h>
+#endif
+#include <plat/arm/common/plat_arm.h>
+#include <plat/common/platform.h>
+
+
+/*******************************************************************************
+ * This function flushes the data structures so that they are visible
+ * in memory for the next BL image.
+ ******************************************************************************/
+void plat_flush_next_bl_params(void)
+{
+	flush_bl_params_desc();
+}
+
+
+/*******************************************************************************
+ * This function returns the list of loadable images.
+ ******************************************************************************/
+bl_load_info_t *plat_get_bl_image_load_info(void)
+{
+	return get_bl_load_info_from_mem_params_desc();
+}
+
+
+/*******************************************************************************
+ * ARM helper function to return the list of executable images.Since the default
+ * descriptors are allocated within BL2 RW memory, this prevents BL31/BL32
+ * overlay of BL2 memory. Hence this function also copies the descriptors to a
+ * pre-allocated memory indicated by ARM_BL2_MEM_DESC_BASE.
+ ******************************************************************************/
+bl_params_t *plat_get_next_bl_params(void)
+{
+	return get_next_bl_params_from_mem_params_desc();
+}
+
+
diff --git a/plat/nuvoton/ma35d1/ma35d1_io_storage.c b/plat/nuvoton/ma35d1/ma35d1_io_storage.c
new file mode 100644
index 0000000..9ca67b5
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_io_storage.c
@@ -0,0 +1,373 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <platform_def.h>
+
+#include <common/debug.h>
+#include <drivers/io/io_block.h>
+#include <drivers/io/io_driver.h>
+#include <drivers/io/io_fip.h>
+#include <drivers/io/io_memmap.h>
+#include <lib/utils_def.h>
+
+#include <tools_share/firmware_image_package.h>
+
+#include "ma35d1_private.h"
+
+//#define NVT_FIP_MMAP
+
+int ma35d1_nand_init(struct io_block_dev_spec **block_dev_spec, long *offset);
+int ma35d1_spinand_init(struct io_block_dev_spec **block_dev_spec, long *offset, int is_quad);
+int ma35d1_spinor_init(struct io_block_dev_spec **block_dev_spec, long *offset, int is_quad);
+int ma35d1_sdhc_init(struct io_block_dev_spec **block_dev_spec, long *offset, int sdhc);
+
+/* IO devices */
+static const io_dev_connector_t *fip_dev_con;
+static uintptr_t fip_dev_handle;
+
+#ifndef NVT_FIP_MMAP
+static const io_dev_connector_t *backend_dev_con;
+static uintptr_t backend_dev_handle;
+
+static io_block_spec_t fip_block_spec = {
+	.length = MA35D1_FIP_SIZE
+};
+#else
+static const io_dev_connector_t *memmap_dev_con;
+static uintptr_t memmap_dev_handle;
+
+static const io_block_spec_t fip_block_spec = {
+	.offset = MA35D1_FIP_BASE,
+	.length = MA35D1_FIP_SIZE
+};
+#endif
+
+static const io_uuid_spec_t bl31_uuid_spec = {
+	.uuid = UUID_EL3_RUNTIME_FIRMWARE_BL31,
+};
+
+static const io_uuid_spec_t bl32_uuid_spec = {
+	.uuid = UUID_SECURE_PAYLOAD_BL32,
+};
+
+static const io_uuid_spec_t bl32_extra1_uuid_spec = {
+	.uuid = UUID_SECURE_PAYLOAD_BL32_EXTRA1,
+};
+
+static const io_uuid_spec_t bl33_uuid_spec = {
+	.uuid = UUID_NON_TRUSTED_FIRMWARE_BL33,
+};
+
+static const io_uuid_spec_t scp_bl2_uuid_spec = {
+	.uuid = UUID_SCP_FIRMWARE_SCP_BL2,
+};
+
+#if TRUSTED_BOARD_BOOT
+static const io_uuid_spec_t trusted_key_cert_spec = {
+	.uuid = UUID_TRUSTED_KEY_CERT,
+};
+
+static const io_uuid_spec_t scp_fw_key_cert_uuid_spec = {
+	.uuid = UUID_SCP_FW_KEY_CERT,
+};
+
+static const io_uuid_spec_t soc_fw_key_cert_spec = {
+	.uuid = UUID_SOC_FW_KEY_CERT,
+};
+
+static const io_uuid_spec_t tos_fw_key_cert_uuid_spec = {
+	.uuid = UUID_TRUSTED_OS_FW_KEY_CERT,
+};
+
+static const io_uuid_spec_t soc_fw_cert_uuid_spec = {
+	.uuid = UUID_SOC_FW_CONTENT_CERT,
+};
+
+static const io_uuid_spec_t tos_fw_cert_uuid_spec = {
+	.uuid = UUID_TRUSTED_OS_FW_CONTENT_CERT,
+};
+
+static const io_uuid_spec_t nt_fw_key_cert_uuid_spec = {
+	.uuid = UUID_NON_TRUSTED_FW_KEY_CERT,
+};
+
+static const io_uuid_spec_t scp_fw_cert_uuid_spec = {
+	.uuid = UUID_SCP_FW_CONTENT_CERT,
+};
+
+static const io_uuid_spec_t nt_fw_cert_uuid_spec = {
+	.uuid = UUID_NON_TRUSTED_FW_CONTENT_CERT,
+};
+#endif /* TRUSTED_BOARD_BOOT */
+
+struct plat_io_policy {
+	uintptr_t *dev_handle;
+	uintptr_t image_spec;
+	uintptr_t init_params;
+};
+
+static const struct plat_io_policy policies[] = {
+#ifndef NVT_FIP_MMAP
+	[FIP_IMAGE_ID] = {
+		.dev_handle = &backend_dev_handle,
+		.image_spec = (uintptr_t)&fip_block_spec,
+	},
+#else
+	[FIP_IMAGE_ID] = {
+		.dev_handle = &memmap_dev_handle,
+		.image_spec = (uintptr_t)&fip_block_spec,
+	},
+#endif
+	[SCP_BL2_IMAGE_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&scp_bl2_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[BL31_IMAGE_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&bl31_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[BL32_IMAGE_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&bl32_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[BL32_EXTRA1_IMAGE_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&bl32_extra1_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[BL33_IMAGE_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&bl33_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+#if TRUSTED_BOARD_BOOT
+	[TRUSTED_KEY_CERT_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&trusted_key_cert_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[SCP_FW_KEY_CERT_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&scp_fw_key_cert_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[SOC_FW_KEY_CERT_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&soc_fw_key_cert_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[TRUSTED_OS_FW_KEY_CERT_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&tos_fw_key_cert_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[NON_TRUSTED_FW_KEY_CERT_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&nt_fw_key_cert_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[SCP_FW_CONTENT_CERT_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&scp_fw_cert_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[SOC_FW_CONTENT_CERT_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&soc_fw_cert_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[TRUSTED_OS_FW_CONTENT_CERT_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&tos_fw_cert_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+	[NON_TRUSTED_FW_CONTENT_CERT_ID] = {
+		.dev_handle = &fip_dev_handle,
+		.image_spec = (uintptr_t)&nt_fw_cert_uuid_spec,
+		.init_params = FIP_IMAGE_ID,
+	},
+#endif /* TRUSTED_BOARD_BOOT */
+};
+
+static int ma35d1_io_fip_setup(void)
+{
+	int ret;
+
+	ret = register_io_dev_fip(&fip_dev_con);
+	if (ret)
+		return ret;
+
+	return io_dev_open(fip_dev_con, 0, &fip_dev_handle);
+}
+
+#ifndef NVT_FIP_MMAP
+static int ma35d1_io_block_setup(struct io_block_dev_spec *block_dev_spec)
+{
+	int ret;
+
+	block_dev_spec->buffer.offset = MA35D1_FIP_BASE;
+	block_dev_spec->buffer.length = MA35D1_FIP_SIZE;
+
+	ret = register_io_dev_block(&backend_dev_con);
+	if (ret)
+		return ret;
+
+	return io_dev_open(backend_dev_con, (uintptr_t)block_dev_spec,
+			   &backend_dev_handle);
+}
+
+static int ma35d1_io_sdhc_setup(int sdhc)
+{
+	struct io_block_dev_spec *block_dev_spec;
+	long offset;
+	int ret;
+
+	ret = ma35d1_sdhc_init(&block_dev_spec, &offset, sdhc);
+	if (ret)
+		return ret;
+	fip_block_spec.offset = offset;
+
+	return ma35d1_io_block_setup(block_dev_spec);
+}
+
+static int ma35d1_io_nand_setup(void)
+{
+	struct io_block_dev_spec *block_dev_spec;
+	long offset;
+	int ret;
+
+	ret = ma35d1_nand_init(&block_dev_spec, &offset);
+	if (ret)
+		return ret;
+	fip_block_spec.offset = offset;
+
+	return ma35d1_io_block_setup(block_dev_spec);
+}
+
+static int ma35d1_io_spinand_setup(int is_quad)
+{
+	struct io_block_dev_spec *block_dev_spec;
+	long offset;
+	int ret;
+
+	ret = ma35d1_spinand_init(&block_dev_spec, &offset, is_quad);
+	if (ret)
+		return ret;
+	fip_block_spec.offset = offset;
+
+	return ma35d1_io_block_setup(block_dev_spec);
+}
+
+static int ma35d1_io_spinor_setup(int is_quad)
+{
+	struct io_block_dev_spec *block_dev_spec;
+	long offset;
+	int ret;
+
+	ret = ma35d1_spinor_init(&block_dev_spec, &offset, is_quad);
+	if (ret)
+		return ret;
+	fip_block_spec.offset = offset;
+
+	return ma35d1_io_block_setup(block_dev_spec);
+}
+#endif
+
+void ma35d1_io_setup(void)
+{
+	int result __unused;
+#ifndef NVT_FIP_MMAP
+	unsigned int por;
+
+	/* check power-on-setting from OTP or PIN */
+	por = inp32(SYS_PWRONOTP);
+	if ((por & 0x1) == 0) {    /* from pin */
+		por = inp32(SYS_PWRONPIN);
+		por = por << 8;
+	}
+	printf("POR: 0x%x\n", por);
+
+	switch (por & PWRON_BOOT_MSK) {
+
+	case PWRON_BOOT_SPI:
+		if (por & PWRON_SPI_NOR) {
+			if ((por & 0xC000) == PWRON_SPI_4_NOR) {
+				INFO("Boot from 4-bit SPI-NOR\n");
+				ma35d1_io_spinor_setup(1);
+			} else {
+				INFO("Boot from 1-bit SPI-NOR\n");
+				ma35d1_io_spinor_setup(0);
+			}
+		} else {
+			if ((por & 0x4000) == PWRON_SPI_1_NAND) {
+				INFO("Boot from 1-bit SPI-NAND\n");
+				ma35d1_io_spinand_setup(0);
+			} else {
+				INFO("Boot from 4-bit SPI-NAND\n");
+				ma35d1_io_spinand_setup(1);
+			}
+		}
+		break;
+
+	case PWRON_BOOT_NAND:
+		INFO("Boot from NAND\n");
+		ma35d1_io_nand_setup();
+		break;
+
+	case PWRON_BOOT_SD:
+		if ((por & 0x4000) == PWRON_SD0) {
+			INFO("Boot from SDHC0\n");
+			ma35d1_io_sdhc_setup(0);
+		} else  {
+			INFO("Boot from SDHC1\n");
+			ma35d1_io_sdhc_setup(1);
+		}
+		break;
+
+	default:
+		ERROR("Boot interface 0x%x not supported\n", por);
+	}
+#else
+	result = register_io_dev_memmap(&memmap_dev_con);
+	assert(result == 0);
+
+	result = io_dev_open(memmap_dev_con, (uintptr_t)NULL,
+			     &memmap_dev_handle);
+	assert(result == 0);
+
+#endif
+	result = ma35d1_io_fip_setup();
+	assert(result == 0);
+
+}
+
+/*
+ * Return an IO device handle and specification which can be used to access
+ * an image. Use this to enforce platform load policy.
+ */
+int plat_get_image_source(unsigned int image_id, uintptr_t *dev_handle,
+			  uintptr_t *image_spec)
+{
+	uintptr_t init_params;
+
+	assert(image_id < ARRAY_SIZE(policies));
+
+	*dev_handle = *policies[image_id].dev_handle;
+	*image_spec = policies[image_id].image_spec;
+	init_params = policies[image_id].init_params;
+
+	return io_dev_init(*dev_handle, init_params);
+}
+
+
+
+
+
diff --git a/plat/nuvoton/ma35d1/ma35d1_platform.c b/plat/nuvoton/ma35d1/ma35d1_platform.c
new file mode 100644
index 0000000..ac9e415
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_platform.c
@@ -0,0 +1,98 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <common/debug.h>
+#include <lib/mmio.h>
+#include <drivers/delay_timer.h>
+#include <drivers/nuvoton/ma35d1_pmic.h>
+#include "ma35d1_private.h"
+
+/*
+ * This function returns soc revision in below format
+ *
+ *   soc_revision[8:15] = major version number
+ *   soc_revision[0:7]  = minor version number
+ */
+int32_t plat_get_soc_revision(void)
+{
+	return (int32_t)(mmio_read_32(SYS_BA));
+}
+
+/* CPU-PLL: 1000MHz 700MHz */
+static unsigned int CAPLL_MODE[4] = {
+	0x000006FA,	/* 1000 MHz */
+	0x00000364,	/* 800 MHz */
+	0x000006AF,	/* 700 MHz */
+	0x0000137D,	/* 500 MHz */
+};
+
+/*
+ * This function changes the CPU PLL
+ */
+int32_t ma35d1_change_pll(int pll)
+{
+	uint64_t timeout;
+	uint32_t index = 2; /* 500 MHz */
+
+	/* CA-PLL */
+	switch (pll) {
+	case CPU_PLL_1G:	/* 1.302V */
+		/* set the voltage VDD_CPU first */
+		if (ma35d1_set_pmic(VOL_CPU, VOL_1_30)) {
+			index = 0;
+			INFO("CA-PLL is 1000 MHz\n");
+		} else {
+			index = 2;
+			WARN("Set 1GHz fail, try to set 700 MHz.\n");
+		}
+		break;
+	case CPU_PLL_800: /* 1.248V */
+		/* set the voltage VDD_CPU first */
+		if (ma35d1_set_pmic(VOL_CPU, VOL_1_25)) {
+			index = 1;
+			INFO("CA-PLL is 800 MHz\n");
+		} else {
+			index = 2;
+			WARN("Set 800MHz fail, try to set 700 MHz.\n");
+		}
+		break;
+	case CPU_PLL_700:
+		index = 2;
+		INFO("CA-PLL is 700 MHz\n");
+		break;
+	case CPU_PLL_500:
+		index = 3;
+		INFO("CA-PLL is 500 MHz\n");
+		break;
+	default:
+		WARN("Invaild CA-PLL !!\n");
+		return 1;
+	};
+	/* set CA35 to E-PLL */
+	outp32((void *)CLK_CLKSEL0, (inp32((void *)CLK_CLKSEL0) & ~0x3) | 0x2);
+
+	outp32((void *)CLK_PLL0CTL0, CAPLL_MODE[index]);
+
+	timeout = timeout_init_us(12000);	/* 1ms */
+	/* check PLL stable */
+	while (1) {
+		if ((inp32((void *)CLK_STATUS) & 0x40) == 0x40)
+			break;
+
+		if (timeout_elapsed(timeout)) {
+			ERROR("PLL wait stable timeout!\n");
+			return 1;
+		}
+	}
+	/* set CA35 to CA-PLL */
+	outp32((void *)CLK_CLKSEL0, (inp32((void *)CLK_CLKSEL0) & ~0x3) | 0x1);
+
+	return 0;
+}
+
+
diff --git a/plat/nuvoton/ma35d1/ma35d1_pm.c b/plat/nuvoton/ma35d1/ma35d1_pm.c
new file mode 100644
index 0000000..861937b
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_pm.c
@@ -0,0 +1,522 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <errno.h>
+
+#include <arch_helpers.h>
+#include <common/debug.h>
+#include <lib/extensions/spe.h>
+#include <lib/mmio.h>
+#include <lib/psci/psci.h>
+#include <plat/arm/common/arm_config.h>
+#include <plat/arm/common/plat_arm.h>
+#include <plat/common/platform.h>
+#include <platform_def.h>
+#include <drivers/arm/gicv2.h>
+#include <platform_def.h>
+
+#include <common/interrupt_props.h>
+#include <lib/utils.h>
+#include "ma35d1_private.h"
+
+#define MA35D1_DDR_HW_POWER_DOWN	0
+
+/* Macros to read the rk power domain state */
+#define MA35D1_CORE_PWR_STATE(state) \
+    ((state)->pwr_domain_state[MPIDR_AFFLVL0])
+#define MA35D1_CLUSTER_PWR_STATE(state) \
+    ((state)->pwr_domain_state[MPIDR_AFFLVL1])
+#define MA35D1_SYSTEM_PWR_STATE(state) \
+((state)->pwr_domain_state[PLAT_MAX_PWR_LVL])
+
+static uintptr_t ma35d1_sec_entrypoint;
+
+#define SYS_BASE 0x40460000
+#define PMUCR 0x30
+#define DDRCQCSR 0x34
+#define PMUIEN 0x38
+#define PMUSTS 0x3C
+#define MISCFCR 0x70
+#define CA35WRBADR1 0x40
+#define CA35WRBPAR1 0x44
+#define CA35WRBADR2 0x48
+#define CA35WRBPAR2 0x4C
+
+#define CLK_BASE 0x40460200
+#define PWRCTL 0x0
+#define STATUS 0x50
+
+static __inline void ma35d1_UnlockReg(void)
+{
+	do {
+		mmio_write_32(0x404601A0, 0x59UL);
+		mmio_write_32(0x404601A0, 0x16UL);
+		mmio_write_32(0x404601A0, 0x88UL);
+	} while (mmio_read_32(0x404601A0) == 0UL);
+
+}
+
+
+static __inline void ma35d1_LockReg(void)
+{
+	mmio_write_32(0x404601A0, 0);
+}
+
+#if MA35D1_DDR_HW_POWER_DOWN
+// Q ch
+void ma35d1_ddr_hw_pd(void)
+{
+	int DDR_QCH_BPPORT0;
+	int DDR_QCH_BPPORT1;
+	int DDR_QCH_BPPORT2;
+	int DDR_QCH_BPPORT3;
+	int DDR_QCH_BPPORT4;
+	int DDR_QCH_BPPORT5;
+	int DDR_QCH_BPPORT6;
+
+	//enable DDR CG bypass
+	mmio_write_32(SYS_BASE + MISCFCR, mmio_read_32(SYS_BASE + MISCFCR) & ~(1 << 23));
+
+	//[11:8]= pg chain time period for voltage stable
+	mmio_write_32(SYS_BASE + PMUCR, mmio_read_32(SYS_BASE + PMUCR) & 0xfffff0ff);
+
+	//[15:12]= pg chain timeout
+	mmio_write_32(SYS_BASE + PMUCR, (mmio_read_32(SYS_BASE + PMUCR) & 0xffff0fff) | (0x2 << 12));
+
+	//[31:24]=DDR time out & delay
+	mmio_write_32(SYS_BASE + DDRCQCSR, mmio_read_32(SYS_BASE + DDRCQCSR) & 0x00ff7f7f);
+
+	//[16]=DDRCQBYPAS, disable ddrc qch bypass
+	mmio_write_32(SYS_BASE + DDRCQCSR, mmio_read_32(SYS_BASE + DDRCQCSR) & ~(0x1 << 16));
+
+//------------------------------------------------------------------------
+	//[7:0]=AXIQBYPAS,
+	DDR_QCH_BPPORT0 = 1;
+	DDR_QCH_BPPORT1 = 1;
+	DDR_QCH_BPPORT2 = 1;
+	DDR_QCH_BPPORT3 = 1;
+	DDR_QCH_BPPORT4 = 1;
+	DDR_QCH_BPPORT5 = 1;
+	DDR_QCH_BPPORT6 = 1;
+
+	if ((mmio_read_32((0x404d0000 + 0x490)) & 0x1) &
+		((mmio_read_32((0x40460000 + 0x204)) >> 4) & 0x1))
+		DDR_QCH_BPPORT0 = 0;	//A35
+	if ((mmio_read_32(0x404d0000 + 0x540) & 0x1) &
+		((mmio_read_32((0x40460000 + 0x204)) >> 24) & 0x1))
+		DDR_QCH_BPPORT1 = 0;	//GFX
+	if ((mmio_read_32((0x404d0000 + 0x5f0)) & 0x1) &
+		((mmio_read_32((0x40460000 + 0x204)) >> 26) & 0x1))
+		DDR_QCH_BPPORT2 = 0;	//DC
+	if ((mmio_read_32((0x404d0000 + 0x6a0)) & 0x1) &
+		((mmio_read_32((0x40460000 + 0x204)) >> 25) & 0x1))
+		DDR_QCH_BPPORT3 = 0;	//VC8000
+	if ((mmio_read_32((0x404d0000 + 0x750)) & 0x1) &
+		(((mmio_read_32((0x40460000 + 0x204)) >> 27) |
+		(mmio_read_32((0x40460000 + 0x200)) >> 28)) & 0x1))
+		DDR_QCH_BPPORT4 = 0;	//GMAC
+	if ((mmio_read_32((0x404d0000 + 0x800)) & 0x1) &
+		(((mmio_read_32((0x40460000 + 0x204)) >> 29) |
+		(mmio_read_32((0x40460000 + 0x200)) >> 30)) & 0x1))
+		DDR_QCH_BPPORT5 = 0;	//CCAP
+	if ((mmio_read_32((0x404d0000 + 0x8b0)) & 0x1) &
+		((mmio_read_32((0x40460000 + 0x204)) >> 5) & 0x1))
+		DDR_QCH_BPPORT6 = 0;	//system
+
+	mmio_write_32(SYS_BASE + DDRCQCSR,
+			(mmio_read_32(SYS_BASE + DDRCQCSR) & ~0x7F) |
+			(DDR_QCH_BPPORT0 << 0) |
+			(DDR_QCH_BPPORT1 << 1) |
+			(DDR_QCH_BPPORT2 << 2) |
+			(DDR_QCH_BPPORT3 << 3) |
+			(DDR_QCH_BPPORT4 << 4) |
+			(DDR_QCH_BPPORT5 << 5) |
+			(DDR_QCH_BPPORT6 << 6));//disable ddr 7 ports qch bypass
+
+	//L2 auto-flush
+	mmio_write_32(SYS_BASE + PMUCR,
+			mmio_read_32(SYS_BASE + PMUCR) & ~(1 << 4));
+}
+
+void ma35d1_deep_power_down(void)
+{
+	ma35d1_UnlockReg();
+
+	ma35d1_ddr_hw_pd();
+
+	//[0]=pg_eanble, Enable clock gating
+	mmio_write_32(SYS_BASE + PMUCR,
+			mmio_read_32(SYS_BASE + PMUCR) | (1 << 0));
+
+	//[16]=pd_eanble, Enable PD
+	mmio_write_32(SYS_BASE + PMUCR,
+			mmio_read_32(SYS_BASE + PMUCR) | (1 << 16));
+
+	//[16]=PMUIEN, Enable PD
+	mmio_write_32(SYS_BASE + PMUIEN,
+			mmio_read_32(SYS_BASE + PMUIEN) | (1 << 8));
+
+	ma35d1_LockReg();
+}
+#else
+
+void ma35d1_ddr_pd(void)
+{
+	//Set ddrc core clock gating circuit bypass
+	mmio_write_32(SYS_BASE + MISCFCR, mmio_read_32(SYS_BASE + MISCFCR) | (1 << 23));
+
+	//disable powerdown_en and selfref_en
+	mmio_write_32(UMCTL2_BA + 0x30, mmio_read_32((UMCTL2_BA + 0x30))&~(0x3));
+
+	//enable static registers write enable
+	mmio_write_32((UMCTL2_BA + 0x328), 0x00000001);
+
+	//set value of dfi_lp_wakeup_sr
+	mmio_write_32((UMCTL2_BA + 0x198), ((mmio_read_32((UMCTL2_BA + 0x198))) & ~(0x0000f000)) | 0x0000f000);
+
+	//disable static registers write enable
+	mmio_write_32((UMCTL2_BA + 0x328), 0x00000000);
+
+	//enable static registers write enable
+	mmio_write_32((UMCTL2_BA + 0x328), 0x00000001);
+
+	//enable dfi_lp_en_sr
+	mmio_write_32((UMCTL2_BA + 0x198), ((mmio_read_32((UMCTL2_BA + 0x198))) & ~(0x00000100)) | 0x00000100);
+
+	//disable static registers write enable
+	mmio_write_32((UMCTL2_BA + 0x328), 0x00000000);
+
+	//wait DDR AXI port0 idle
+	while((mmio_read_32((UMCTL2_BA + 0x3fc)) & 0x00010001) != 0x00000000);
+	//disable DDR AXI port0 ~ DDR AXI port6
+	mmio_write_32((UMCTL2_BA + 0x490), 0x00000000);  //AXI port0
+	mmio_write_32((UMCTL2_BA + 0x540), 0x00000000);  //AXI port1
+	mmio_write_32((UMCTL2_BA + 0x5f0), 0x00000000);  //AXI port2
+	mmio_write_32((UMCTL2_BA + 0x6a0), 0x00000000);  //AXI port3
+	mmio_write_32((UMCTL2_BA + 0x750), 0x00000000);  //AXI port4
+	mmio_write_32((UMCTL2_BA + 0x800), 0x00000000);  //AXI port5
+	mmio_write_32((UMCTL2_BA + 0x8b0), 0x00000000);  //AXI port6
+
+	//wait DDR AXI port0 ~ DDR AXI port6 idle
+	while((mmio_read_32((UMCTL2_BA + 0x3fc)) & 0x003f003f) != 0x00000000);
+	//enter DDR software self-refresh mode
+	mmio_write_32((UMCTL2_BA + 0x30), mmio_read_32((UMCTL2_BA + 0x30)) | 0x20);
+
+	//wait DDR enter software self-refresh mode
+	while((mmio_read_32((UMCTL2_BA + 0x04)) & 0x30) != 0x20);
+	//disable DDR AXI port0 clock ~ DDR AXI port5 clock
+	mmio_write_32(0x40460204, (mmio_read_32(0x40460204) & ~(0x7f000030)));
+
+	//disable DDR core clock
+	mmio_write_32(0x4046020C, mmio_read_32(0x4046020C) & ~(0x40000000));
+
+	//disable DDR PLL clock
+	mmio_write_32(0x40460284, mmio_read_32(0x40460284) | 0x1);
+}
+
+void ma35d1_ddr_wk(void)
+{
+	ma35d1_UnlockReg();
+
+	//enable DDR AXI port0 clock and DDR AXI port5 clock
+	mmio_write_32(0x40460204, mmio_read_32(0x40460204) | 0x7f000034);
+
+	//Set ddrc core clock gating circuit bypass
+	mmio_write_32(0x40460070, mmio_read_32(0x40460070) | 0x00800000);
+
+	//enable DDR PLL clock
+	mmio_write_32(0x40460284, mmio_read_32(0x40460284) & ~(0x1));
+
+	//enable DDR core clock
+	mmio_write_32(0x4046020c, mmio_read_32(0x4046020c) | 0x40000000);
+
+	//polling DDR-PLL stable
+	while((mmio_read_32(0x40460250) & 0x00000100) != 0x00000100);
+
+	//exit DDR software self-refresh mode
+	mmio_write_32((UMCTL2_BA + 0x30), mmio_read_32(UMCTL2_BA + 0x30) & ~(0x00000020));
+
+	//wait DDR exit software self-refresh mode
+	while((mmio_read_32((UMCTL2_BA + 0x04)) & 0x30) != 0x00);
+
+	//enable DDR AXI port0, DDR AXI port5, and DDR AXI port6
+	mmio_write_32((UMCTL2_BA + 0x490), 0x00000001);  //AXI port0
+	mmio_write_32((UMCTL2_BA + 0x540), 0x00000001);  //AXI port1
+	mmio_write_32((UMCTL2_BA + 0x5f0), 0x00000001);  //AXI port2
+	mmio_write_32((UMCTL2_BA + 0x6a0), 0x00000001);  //AXI port3
+	mmio_write_32((UMCTL2_BA + 0x750), 0x00000001);  //AXI port4
+	mmio_write_32((UMCTL2_BA + 0x800), 0x00000001);  //AXI port5
+	mmio_write_32((UMCTL2_BA + 0x8b0), 0x00000001);  //AXI port6
+
+	//enable static registers write enable
+	mmio_write_32((UMCTL2_BA + 0x328), 0x00000001);
+
+	//disable dfi_lp_en_sr
+	mmio_write_32((UMCTL2_BA + 0x198), mmio_read_32((UMCTL2_BA + 0x198)) &~(0x00000100));
+
+	//disable static registers write enable
+	mmio_write_32((UMCTL2_BA + 0x328), 0x00000000);
+
+	//enable powerdown_en and selfref_en
+	mmio_write_32((UMCTL2_BA + 0x30), mmio_read_32((UMCTL2_BA + 0x30)) | 0x3);
+
+	//Set ddrc core clock gating circuit enable
+	mmio_write_32((0x40460070), mmio_read_32(0x40460070) & ~(0x00800000));
+
+	ma35d1_LockReg();
+}
+
+void ma35d1_deep_power_down_sw(void)
+{
+	ma35d1_UnlockReg();
+
+	//[31:24]=DDR time out & delay
+	mmio_write_32(SYS_BASE + DDRCQCSR, mmio_read_32(SYS_BASE + DDRCQCSR) | 0x1007f);
+
+	//Disable L2 flush by PMU
+	mmio_write_32(SYS_BASE + PMUCR,
+			mmio_read_32(SYS_BASE + PMUCR) | (1 << 4));
+
+	ma35d1_ddr_pd();
+
+	//[0]=pg_eanble, Enable clock gating
+	mmio_write_32(SYS_BASE + PMUCR,
+			mmio_read_32(SYS_BASE + PMUCR) | (1 << 0));
+
+	//[16]=pd_eanble, Enable PD
+	mmio_write_32(SYS_BASE + PMUCR,
+			mmio_read_32(SYS_BASE + PMUCR) | (1 << 16));
+
+	//[16]=PMUIEN, Enable PD
+	mmio_write_32(SYS_BASE + PMUIEN,
+			mmio_read_32(SYS_BASE + PMUIEN) | (1 << 8));
+
+	mmio_write_32(CLK_PWRCTL, mmio_read_32(CLK_PWRCTL) | 0x00E0F800); // Turn on auto off bits...
+
+	ma35d1_LockReg();
+}
+#endif
+
+static void ma35d1_cpu_standby(plat_local_state_t cpu_state)
+{
+
+	u_register_t scr;
+
+	assert(cpu_state == PLAT_MAX_RET_STATE);
+
+	scr = read_scr_el3();
+	/* Enable PhysicalIRQ bit for NS world to wake the CPU */
+	write_scr_el3(scr | SCR_IRQ_BIT);
+	isb();
+	dsb();
+	wfi();
+
+	/*
+	 * Restore SCR to the original value, synchronisation of scr_el3 is
+	 * done by eret while el3_exit to save some execution cycles.
+	 */
+	write_scr_el3(scr);
+}
+
+static int ma35d1_pwr_domain_on(u_register_t mpidr)
+{
+
+	if (mpidr == 1)
+	{
+		mmio_write_32(SYS_BASE + CA35WRBADR2, ma35d1_sec_entrypoint);
+		sev();
+	}
+	else
+	{
+		mmio_write_32(SYS_BASE + CA35WRBPAR1, 0x7761726D);
+		mmio_write_32(SYS_BASE + CA35WRBADR1, ma35d1_sec_entrypoint);
+	}
+
+	return PSCI_E_SUCCESS;
+}
+
+static void ma35d1_pwr_domain_off(const psci_power_state_t *target_state)
+{
+
+}
+
+static void ma35d1_pwr_domain_suspend(const psci_power_state_t *target_state)
+{
+	unsigned int reg;
+
+	disable_mmu_el3();
+
+	if (mmio_read_32(SYS_BASE+DDRCQCSR)&0x0002FF00) {
+		reg =mmio_read_32(SYS_BASE + DDRCQCSR);
+		mmio_write_32(SYS_BASE + DDRCQCSR,reg);
+	}
+
+	//mmio_write_32(0x2803fd04, 0);
+	mmio_write_32(SYS_BASE + CA35WRBADR1, ma35d1_sec_entrypoint);
+	mmio_write_32(SYS_BASE + CA35WRBPAR1, 0x7761726D);
+#if MA35D1_DDR_HW_POWER_DOWN
+	ma35d1_deep_power_down();
+#else
+	ma35d1_deep_power_down_sw();
+#endif
+}
+
+static void ma35d1_pwr_domain_on_finish(const psci_power_state_t *target_state)
+{
+	plat_arm_gic_init();
+
+	/* Enable the gic cpu interface */
+	gicv2_cpuif_enable();
+	gicv2_pcpu_distif_init();
+	mmio_write_32(SYS_BASE + CA35WRBPAR1, 0x0);
+}
+
+int ma35d1_validate_ns_entrypoint(uintptr_t ns_entrypoint)
+{
+	return PSCI_E_SUCCESS;
+}
+
+
+static void ma35d1_pwr_domain_suspend_finish(const
+			psci_power_state_t * target_state)
+{
+#if !MA35D1_DDR_HW_POWER_DOWN
+	ma35d1_ddr_wk();
+#endif
+	/* Clear poer down flag */
+	mmio_write_32(SYS_BASE + PMUSTS, (1 << 8) | 0x1);
+
+	/* Clear Core 1 Warm-boot */
+	mmio_write_32(SYS_BASE + CA35WRBPAR1, 0);
+
+	plat_arm_gic_init();
+
+	/* Enable the gic cpu interface */
+	gicv2_cpuif_enable();
+	gicv2_pcpu_distif_init();
+
+	/* Disable the Non secure interrupt to wake the CPU */
+	write_scr_el3(read_scr_el3() & ~(SCR_IRQ_BIT | SCR_FIQ_BIT));
+
+	isb();
+	/* dsb is good practice before using wfi to enter low power states */
+	dsb();
+}
+
+/*******************************************************************************
+ * MA35D1 handlers to shutdown/reboot the system
+ ******************************************************************************/
+static void __dead2 ma35d1_system_off(void)
+{
+	while (1)
+		;
+}
+
+
+static void __dead2 ma35d1_system_reset(void)
+{
+	ma35d1_UnlockReg();
+	mmio_write_32(SYS_IPRST0, 0x1);
+	mmio_write_32(SYS_IPRST0, 0x0);
+
+	while (1)
+		;
+}
+
+
+static int ma35d1_validate_power_state(unsigned int power_state,
+					psci_power_state_t * req_state)
+{
+	int pstate = psci_get_pstate_type(power_state);
+	int pwr_lvl = psci_get_pstate_pwrlvl(power_state);
+	int i;
+
+	assert(req_state);
+
+	if (pwr_lvl > PLAT_MAX_PWR_LVL)
+		return PSCI_E_INVALID_PARAMS;
+
+	/* Sanity check the requested state */
+	if (pstate == PSTATE_TYPE_STANDBY) {
+		/*
+		 * It's probably to enter standby only on power level 0
+		 * ignore any other power level.
+		 */
+		if (pwr_lvl != MPIDR_AFFLVL0)
+			return PSCI_E_INVALID_PARAMS;
+
+		req_state->pwr_domain_state[MPIDR_AFFLVL0] = PLAT_MAX_RET_STATE;
+	} else {
+
+		for (i = MPIDR_AFFLVL0; i <= pwr_lvl; i++)
+			req_state->pwr_domain_state[i] = PLAT_MAX_OFF_STATE;
+
+		for (i = (pwr_lvl); i <= PLAT_MAX_PWR_LVL; i++)
+			req_state->pwr_domain_state[i] = PLAT_MAX_RET_STATE;
+	}
+
+	/* We expect the 'state id' to be zero */
+	if (psci_get_pstate_id(power_state))
+		return PSCI_E_INVALID_PARAMS;
+
+	return PSCI_E_SUCCESS;
+}
+
+
+void ma35d1_get_sys_suspend_power_state(psci_power_state_t
+        *req_state)
+{
+	int i;
+
+	for (i = MPIDR_AFFLVL0; i <= PLAT_MAX_PWR_LVL; i++)
+		req_state->pwr_domain_state[i] = PLAT_MAX_OFF_STATE;
+}
+
+
+void __dead2 ma35d1_pwr_domain_pwr_down_wfi(const psci_power_state_t * target_state)
+{
+	u_register_t scr;
+
+	scr = read_scr_el3();
+
+	/* Enable the Non secure interrupt to wake the CPU */
+	write_scr_el3(scr | SCR_IRQ_BIT | SCR_FIQ_BIT);
+	isb();
+	/* dsb is good practice before using wfi to enter low power states */
+	dsb();
+
+	while(1)
+		wfi();
+}
+
+plat_psci_ops_t plat_arm_psci_pm_ops = {
+	.cpu_standby = ma35d1_cpu_standby,
+	.pwr_domain_on = ma35d1_pwr_domain_on,
+	.pwr_domain_off = ma35d1_pwr_domain_off,
+	.validate_ns_entrypoint = ma35d1_validate_ns_entrypoint,
+	.pwr_domain_suspend = ma35d1_pwr_domain_suspend,
+	.pwr_domain_on_finish = ma35d1_pwr_domain_on_finish,
+	.pwr_domain_suspend_finish = ma35d1_pwr_domain_suspend_finish,
+	.system_off = ma35d1_system_off,
+	.system_reset = ma35d1_system_reset,
+	.validate_power_state = ma35d1_validate_power_state,
+	.pwr_domain_pwr_down_wfi = ma35d1_pwr_domain_pwr_down_wfi,
+	.get_sys_suspend_power_state = ma35d1_get_sys_suspend_power_state,
+};
+
+/*******************************************************************************
+ * Export the platform specific power ops.
+ ******************************************************************************/
+int plat_setup_psci_ops(uintptr_t sec_entrypoint,
+			const plat_psci_ops_t ** psci_ops)
+{
+	ma35d1_sec_entrypoint = sec_entrypoint;
+	*psci_ops = &plat_arm_psci_pm_ops;
+
+	mmio_write_32(CLK_BASE, mmio_read_32(CLK_BASE) | (1 << 9));//ICE DB
+	return 0;
+}
diff --git a/plat/nuvoton/ma35d1/ma35d1_private.c b/plat/nuvoton/ma35d1/ma35d1_private.c
new file mode 100644
index 0000000..3a1a62f
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_private.c
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+#include <libfdt.h>
+#include <platform_def.h>
+#include <lib/xlat_tables/xlat_tables_v2.h>
+
+#include "ma35d1_private.h"
+
+#define MAP_SEC_SYSRAM0	MAP_REGION_FLAT(MA35D1_SRAM0_BASE, \
+					MA35D1_SRAM0_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_NS )
+
+#define MAP_SEC_SYSRAM1	MAP_REGION_FLAT(MA35D1_SRAM1_BASE, \
+					MA35D1_SRAM1_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE )
+
+#define MAP_DEVICE1	MAP_REGION_FLAT(MA35D1_REG_BASE, \
+					MA35D1_REG_SIZE, \
+					MT_DEVICE | \
+					MT_RW | \
+					MT_SECURE)
+
+#define MAP_DEVICE2	MAP_REGION_FLAT(MA35D1_DRAM_BASE, \
+					MA35D1_DRAM_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_NS)
+
+#define MAP_DEVICE3	MAP_REGION_FLAT(MA35D1_DRAM_S_BASE, \
+					MA35D1_DRAM_S_SIZE, \
+					MT_MEMORY | \
+					MT_RW | \
+					MT_SECURE)
+
+const mmap_region_t ma35d1_mmap[] = {
+	MAP_SEC_SYSRAM0,
+	MAP_SEC_SYSRAM1,
+	MAP_DEVICE1,
+	MAP_DEVICE2,
+	MAP_DEVICE3,
+	{0}
+};
+
+
+void configure_mmu(void)
+{
+	mmap_add(ma35d1_mmap);
+	init_xlat_tables();
+
+	enable_mmu_el3(0);
+}
+
+
diff --git a/plat/nuvoton/ma35d1/ma35d1_private.h b/plat/nuvoton/ma35d1/ma35d1_private.h
new file mode 100644
index 0000000..030fec9
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_private.h
@@ -0,0 +1,59 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#ifndef MA35D1_PRIVATE_H
+#define MA35D1_PRIVATE_H
+
+#include <plat/arm/common/plat_arm.h>
+
+/*****************************************************************************
+ * Power On Setting
+ *****************************************************************************/
+/* PWRON[11:10] */
+#define PWRON_BOOT_MSK      (0x00000C00)
+#define PWRON_BOOT_USB      (0x00000C00)
+#define PWRON_BOOT_SD       (0x00000400)
+#define PWRON_BOOT_NAND     (0x00000800)
+#define PWRON_BOOT_SPI      (0x00000000)
+
+/* SD boot for MFP */
+#define PWRON_SD0           (0x00000000)
+#define PWRON_SD1           (0x00004000)
+
+/* SPI boot for mode select */
+#define PWRON_SPI_4_NAND    (0x00004000)
+#define PWRON_SPI_1_NAND    (0x00000000)
+#define PWRON_SPI_4_NOR     (0x0000C000)
+#define PWRON_SPI_1_NOR     (0x00008000)
+#define PWRON_SPI_NOR       (0x00008000)
+
+/* PLL Setting */
+#define CPU_PLL_1G          (0x00001000)
+#define CPU_PLL_800         (0x00000800)
+#define CPU_PLL_700         (0x00000700)
+#define CPU_PLL_500         (0x00000500)
+#define CPU_PLL_125         (0x00000125)
+
+/*******************************************************************************
+ * Function and variable prototypes
+ ******************************************************************************/
+
+void ma35d1_config_setup(void);
+void plat_ma35d1_init(void);
+
+void ma35d1_interconnect_init(void);
+void ma35d1_interconnect_enable(void);
+void ma35d1_interconnect_disable(void);
+void ma35d1_timer_init(void);
+void tsp_early_platform_setup(void);
+void ma35d1_io_setup(void);
+
+void configure_mmu(void);
+void ma35d1_ddr_init(void);
+void ma35d1_arch_security_setup(void);
+int32_t ma35d1_change_pll(int pll);
+
+#endif /* MA35D1_PRIVATE_H */
diff --git a/plat/nuvoton/ma35d1/ma35d1_rotpk.S b/plat/nuvoton/ma35d1/ma35d1_rotpk.S
new file mode 100644
index 0000000..e4b8f73
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_rotpk.S
@@ -0,0 +1,15 @@
+/*
+ * Copyright (c) 2018-2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+	.global ma35d1_rotpk_hash
+	.global ma35d1_rotpk_hash_end
+ma35d1_rotpk_hash:
+	/* DER header */
+	.byte 0x30, 0x31, 0x30, 0x0D, 0x06, 0x09, 0x60, 0x86, 0x48
+	.byte 0x01, 0x65, 0x03, 0x04, 0x02, 0x01, 0x05, 0x00, 0x04, 0x20
+	/* SHA256 */
+	.incbin ROTPK_HASH
+ma35d1_rotpk_hash_end:
diff --git a/plat/nuvoton/ma35d1/ma35d1_security.c b/plat/nuvoton/ma35d1/ma35d1_security.c
new file mode 100644
index 0000000..2f1e9d6
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_security.c
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <plat/arm/common/arm_config.h>
+#include <plat/arm/common/plat_arm.h>
+#include <common/debug.h>
+
+/*
+ * We assume that all security programming is done by the primary core.
+ */
+void plat_arm_security_setup(void)
+{
+}
+
+/*******************************************************************************
+ * Initialize the TrustZone Controller. Configure Region 0 with Secure RW access
+ * and allow Non-Secure masters full access.
+ ******************************************************************************/
+static void init_tzc400(void)
+{
+#ifdef MA35D1_LOAD_BL32
+	unsigned long long ddr_s_size = MA35D1_DDR_MAX_SIZE - MA35D1_DRAM_SIZE;
+#endif
+	unsigned int reg = inp32((void *)0x40460204);
+
+	/* SSMCC clock enable */
+	outp32((void *)0x40460204, inp32((void *)0x40460204) | 0x7f7f0000);
+
+	/* TZC2 */
+	tzc400_init(MA35D1_TZC2_BASE);
+	tzc400_disable_filters();
+	/* Region 1 set to cover Non-Secure DRAM at 0x8000_0000 */
+	tzc400_configure_region(MA35D1_FILTER_BIT_ALL, 1,
+				MA35D1_DDR_BASE,
+				MA35D1_DDR_BASE +
+				(MA35D1_DDR_MAX_SIZE - 1U),
+				TZC_REGION_S_NONE,
+				PLAT_ARM_TZC_NS_DEV_ACCESS);
+
+	/* Raise an exception if a NS device tries to access secure memory */
+	tzc400_set_action(TZC_ACTION_ERR);
+	tzc400_enable_filters();
+
+	/* TZC0 */
+	tzc400_init(MA35D1_TZC0_BASE);
+	tzc400_disable_filters();
+
+	/* Region 1 set to cover Non-Secure DRAM at 0x8000_0000 */
+	tzc400_configure_region(MA35D1_FILTER_BIT_ALL, 1,
+				MA35D1_DDR_BASE,
+				MA35D1_DDR_BASE +
+				(MA35D1_DDR_MAX_SIZE - 1U),
+				TZC_REGION_S_NONE,
+				PLAT_ARM_TZC_NS_DEV_ACCESS);
+
+	/* Raise an exception if a NS device tries to access secure memory */
+	tzc400_set_action(TZC_ACTION_ERR);
+	tzc400_enable_filters();
+
+#ifdef MA35D1_LOAD_BL32
+	/* TZC2 */
+	tzc400_init(MA35D1_TZC2_BASE);
+	tzc400_disable_filters();
+	/* Region 2 set to cover Secure DRAM at 0x8f80_0000 */
+	tzc400_configure_region(MA35D1_FILTER_BIT_ALL, 2,
+				MA35D1_DRAM_S_BASE,
+				MA35D1_DRAM_S_BASE +
+				(ddr_s_size - 1U),
+				TZC_REGION_S_RDWR,
+				0);
+
+	/* Raise an exception if a NS device tries to access secure memory */
+	tzc400_set_action(TZC_ACTION_ERR);
+	tzc400_enable_filters();
+
+	/* TZC0 */
+	tzc400_init(MA35D1_TZC0_BASE);
+	tzc400_disable_filters();
+
+	/* Region 2 set to cover Secure DRAM at 0x8f80_0000 */
+	tzc400_configure_region(MA35D1_FILTER_BIT_ALL, 2,
+				MA35D1_DRAM_S_BASE,
+				MA35D1_DRAM_S_BASE +
+				(ddr_s_size - 1U),
+				TZC_REGION_S_RDWR,
+				0);
+
+	/* Raise an exception if a NS device tries to access secure memory */
+	tzc400_set_action(TZC_ACTION_ERR);
+	tzc400_enable_filters();
+#endif
+	outp32((void *)0x40460204, (inp32((void *)0x40460204) & ~0x7f7f0000) | reg);
+
+	/* M4 access DDR enabled */
+	outp32((void *)0x40460070, inp32((void *)0x40460070) | 0x4);
+}
+
+
+/*******************************************************************************
+ * Initialize the TrustZone Controller.
+ * Early initialization create only one region with full access to secure.
+ * This setting is used before and during DDR initialization.
+ ******************************************************************************/
+static void early_init_tzc400(void)
+{
+	unsigned int reg = inp32((void *)0x40460204);
+
+	/* SSMCC clock enable */
+	outp32((void *)0x40460214, inp32((void *)0x40460214) | (1 << 2));
+	outp32((void *)0x40460218, inp32((void *)0x40460218) | (1 << 2));
+	outp32((void *)0x40460204, inp32((void *)0x40460204) | 0x7f7f0000);
+
+	/* TZC2 */
+	tzc400_init(MA35D1_TZC2_BASE);
+	tzc400_configure_region0(TZC_REGION_S_RDWR, PLAT_ARM_TZC_NS_DEV_ACCESS);
+
+	/* Raise an exception if a NS device tries to access secure memory */
+	tzc400_set_action(TZC_ACTION_ERR);
+
+	/* TZC0 */
+	tzc400_init(MA35D1_TZC0_BASE);
+	tzc400_configure_region0(TZC_REGION_S_RDWR, PLAT_ARM_TZC_NS_DEV_ACCESS);
+
+	/* Raise an exception if a NS device tries to access secure memory */
+	tzc400_set_action(TZC_ACTION_ERR);
+
+	outp32((void *)0x40460204, (inp32((void *)0x40460204) & ~0x7f7f0000) | reg);
+
+	/* M4 access DDR enabled */
+	outp32((void *)0x40460070, inp32((void *)0x40460070) | 0x4);
+}
+
+
+/*******************************************************************************
+ * Initialize the secure environment. At this moment only the TrustZone
+ * Controller is initialized.
+ ******************************************************************************/
+void ma35d1_arch_security_setup(void)
+{
+	early_init_tzc400();
+}
+
+/*******************************************************************************
+ * Initialize the secure environment. At this moment only the TrustZone
+ * Controller is initialized.
+ ******************************************************************************/
+void ma35d1_security_setup(void)
+{
+	init_tzc400();
+}
+
diff --git a/plat/nuvoton/ma35d1/ma35d1_sip_svc.c b/plat/nuvoton/ma35d1/ma35d1_sip_svc.c
new file mode 100644
index 0000000..eabb52f
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_sip_svc.c
@@ -0,0 +1,224 @@
+/*
+ * Copyright (C) 2021 Nuvoton Technology Corp.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <assert.h>
+
+#include <common/debug.h>
+#include <common/runtime_svc.h>
+#include <lib/mmio.h>
+#include <drivers/delay_timer.h>
+#include <tools_share/uuid.h>
+
+#include <ma35d1_sip_svc.h>
+#include <drivers/nuvoton/ma35d1_pmic.h>
+#include "ma35d1_private.h"
+#include "include/ma35d1_crypto.h"
+#include "include/tsi_cmd.h"
+
+#pragma weak ma35d1_plat_sip_handler
+
+/* CPU-PLL: 1000MHz 700MHz */
+static unsigned int CAPLL_MODE[5] = {
+	0x000006FA,	/* 1000 MHz */
+	0x00000364,	/* 800 MHz */
+	0x000006AF,	/* 700 MHz */
+	0x0000137D,	/* 500 MHz */
+	0x0000237D,	/* 125 MHz */
+};
+
+static uint32_t eppl_div_restore = 0xFFFFFFFF;
+static uint32_t eppl_ctl1 = 0x1, vppl_ctl1 = 0x1;
+
+uintptr_t ma35d1_plat_sip_handler(uint32_t smc_fid,
+				    u_register_t x1,
+				    u_register_t x2,
+				    u_register_t x3,
+				    u_register_t x4,
+				    void *cookie,
+				    void *handle,
+				    u_register_t flags)
+{
+	ERROR("%s: unhandled SMC (0x%x)\n", __func__, smc_fid);
+	SMC_RET1(handle, SMC_UNK);
+}
+
+/*
+ * This function changes the CPU PLL
+ */
+static int32_t ma35d1_set_cpu_clock(int cpu_freq)
+{
+	uint64_t timeout;
+	uint32_t index = 2; /* 500 MHz */
+
+	/* CA-PLL */
+	switch (cpu_freq) {
+	case CPU_PLL_1G:
+		index = 0;
+		INFO("CA-PLL is 1000 MHz\n");
+		break;
+	case CPU_PLL_800: /* 1.248V */
+		index = 1;
+		INFO("CA-PLL is 800 MHz\n");
+		break;
+	case CPU_PLL_700:
+		index = 2;
+		INFO("CA-PLL is 700 MHz\n");
+		break;
+	case CPU_PLL_500:
+		index = 3;
+		INFO("CA-PLL is 500 MHz\n");
+		break;
+	case CPU_PLL_125:
+		index = 4;
+		INFO("CA-PLL is 125 MHz\n");
+		break;
+	default:
+		WARN("Invaild CA-PLL !!\n");
+		return 1;
+	};
+	/* set CA35 to DDRPLL */
+	outp32((void *)CLK_CLKSEL0, (inp32((void *)CLK_CLKSEL0) & ~0x3) | 0x2);
+
+	outp32((void *)CLK_PLL0CTL0, CAPLL_MODE[index]);
+
+	timeout = timeout_init_us(12000);	/* 1ms */
+	/* check PLL stable */
+	while (1) {
+		if ((inp32((void *)CLK_STATUS) & 0x40) == 0x40)
+			break;
+
+		if (timeout_elapsed(timeout)) {
+			ERROR("PLL wait stable timeout!\n");
+			return 1;
+		}
+	}
+	/* set CA35 to CA-PLL */
+	outp32((void *)CLK_CLKSEL0, (inp32((void *)CLK_CLKSEL0) & ~0x3) | 0x1);
+	return 0;
+}
+
+/*
+ * This function is responsible for handling all SiP calls from the NS world
+ */
+uintptr_t sip_smc_handler(uint32_t smc_fid,
+			  u_register_t x1,
+			  u_register_t x2,
+			  u_register_t x3,
+			  u_register_t x4,
+			  void *cookie,
+			  void *handle,
+			  u_register_t flags)
+{
+	uint32_t ns;
+	uint32_t volt;
+	int ret;
+	int CPU_CLK = 0;
+
+	/* unlock */
+	outp32((void *)SYS_RLKTZS, 0x59);
+	outp32((void *)SYS_RLKTZS, 0x16);
+	outp32((void *)SYS_RLKTZS, 0x88);
+
+	// INFO("TFA SIP - 0x%x, %ld, %ld\n", smc_fid, x1, x2);
+
+	/* Determine which security state this SMC originated from */
+	ns = is_caller_non_secure(flags);
+	if (!ns)
+		SMC_RET1(handle, SMC_UNK);
+
+	switch (smc_fid) {
+	case SIP_SVC_PMIC:
+		if (x1 == 0) {
+			volt = ma35d1_get_pmic(VOL_CPU);
+			ret = 0;
+		}
+		else {
+			volt = x1;
+			if (ma35d1_set_pmic(VOL_CPU, x1) > 0)
+				ret = 0;
+			else
+				ret = -1;
+		}
+		outp32((void *)SYS_RLKTZS, 0);
+		SMC_RET2(handle, ret, volt);
+
+	case SIP_CPU_CLK:
+		if ((uint32_t)x1 == 1000)
+			CPU_CLK = CPU_PLL_1G;
+		else if ((uint32_t)x1 == 800)
+			CPU_CLK = CPU_PLL_800;
+		else if ((uint32_t)x1 == 700)
+			CPU_CLK = CPU_PLL_700;
+		else if ((uint32_t)x1 == 500)
+			CPU_CLK = CPU_PLL_500;
+
+		ret = ma35d1_set_cpu_clock(CPU_CLK);
+		if (ret == 1) {
+			WARN("Set CPU clock %ld Fail !!\n", x1);
+		}
+		outp32((void *)SYS_RLKTZS, 0);
+		SMC_RET1(handle, ret);
+
+	case SIP_SET_EPLL:
+		// INFO("TFA SIP - CLK_PLL4CTL1 = 0x%x, restore = 0x%x\n", inp32((void *)CLK_PLL4CTL1), eppl_div_restore);
+		if (eppl_div_restore == 0xFFFFFFFF)
+			eppl_div_restore = inp32((void *)CLK_PLL4CTL1);
+		if ((uint32_t)x1 == NVT_SIP_SVC_EPLL_DIV_BY_2)
+			outp32((void *)CLK_PLL4CTL1, eppl_div_restore + 0x10);
+		else if ((uint32_t)x1 == NVT_SIP_SVC_EPLL_DIV_BY_4)
+			outp32((void *)CLK_PLL4CTL1, eppl_div_restore + 0x20);
+		else if ((uint32_t)x1 == NVT_SIP_SVC_EPLL_DIV_BY_8)
+			outp32((void *)CLK_PLL4CTL1, eppl_div_restore + 0x30);
+		else {
+			outp32((void *)CLK_PLL4CTL1, eppl_div_restore);
+			eppl_div_restore = 0xFFFFFFFF;
+		}
+		outp32((void *)SYS_RLKTZS, 0);
+		SMC_RET2(handle, 0, inp32((void *)CLK_PLL4CTL1));
+
+	case SIP_LOW_SPEED:
+		if ((uint32_t)x1 == 0) {
+			// INFO("Leave low speed mode\n");
+			ma35d1_set_cpu_clock(CPU_PLL_500);
+			if ((inp32(SYS_CHIPCFG) & (1 << 8)) == 0)
+				TSI_Set_Clock(0x80235A);
+			outp32((void *)CLK_PLL4CTL1, eppl_ctl1);
+			outp32((void *)CLK_PLL5CTL1, vppl_ctl1);
+		} else {
+			// INFO("Enter low speed mode\n");
+			ma35d1_set_cpu_clock(CPU_PLL_125);
+			if ((inp32(SYS_CHIPCFG) & (1 << 8)) == 0)
+				TSI_Set_Clock(0x802312);
+			eppl_ctl1 = inp32((void *)CLK_PLL4CTL1);
+			vppl_ctl1 = inp32((void *)CLK_PLL5CTL1);
+			outp32((void *)CLK_PLL4CTL1, eppl_ctl1 | 0x70);
+			outp32((void *)CLK_PLL5CTL1, vppl_ctl1 | 0x70);
+		}
+		outp32((void *)SYS_RLKTZS, 0);
+		SMC_RET1(handle, 0);
+
+	case SIP_SVC_VERSION:
+		/* Return the version of current implementation */
+		SMC_RET3(handle, 0, NVT_SIP_SVC_VERSION_MAJOR,
+			NVT_SIP_SVC_VERSION_MINOR);
+
+	default:
+		outp32((void *)SYS_RLKTZS, 0);
+		return ma35d1_plat_sip_handler(smc_fid, x1, x2, x3, x4,
+			cookie, handle, flags);
+	};
+
+}
+
+/* Define a runtime service descriptor for fast SMC calls */
+DECLARE_RT_SVC(
+	ma35d1_sip_svc,
+	OEN_SIP_START,
+	OEN_SIP_END,
+	SMC_TYPE_FAST,
+	NULL,
+	sip_smc_handler
+);
diff --git a/plat/nuvoton/ma35d1/ma35d1_topology.c b/plat/nuvoton/ma35d1/ma35d1_topology.c
new file mode 100644
index 0000000..79fb6d5
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_topology.c
@@ -0,0 +1,87 @@
+/*
+ * Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <platform_def.h>
+
+#include <arch.h>
+//#include <drivers/arm/ma35d1/ma35d1_pwrc.h>
+#include <drivers/arm/fvp/fvp_pwrc.h>
+#include <lib/cassert.h>
+#include <plat/arm/common/arm_config.h>
+#include <plat/arm/common/plat_arm.h>
+#include <plat/common/platform.h>
+
+/* The MA35D1 power domain tree descriptor */
+static unsigned char ma35d1_power_domain_tree_desc[MA35D1_CLUSTER_COUNT + 2];
+
+
+CASSERT(((MA35D1_CLUSTER_COUNT > 0) && (MA35D1_CLUSTER_COUNT <= 256)),
+			assert_invalid_ma35d1_cluster_count);
+
+/*******************************************************************************
+ * This function dynamically constructs the topology according to
+ * MA35D1_CLUSTER_COUNT and returns it.
+ ******************************************************************************/
+const unsigned char *plat_get_power_domain_tree_desc(void)
+{
+	int i;
+
+	/*
+	 * The highest level is the system level. The next level is constituted
+	 * by clusters and then cores in clusters.
+	 */
+	ma35d1_power_domain_tree_desc[0] = 1;
+	ma35d1_power_domain_tree_desc[1] = MA35D1_CLUSTER_COUNT;
+
+	for (i = 0; i < MA35D1_CLUSTER_COUNT; i++)
+		ma35d1_power_domain_tree_desc[i + 2] = MA35D1_MAX_CPUS_PER_CLUSTER;
+
+
+	return ma35d1_power_domain_tree_desc;
+}
+
+/*******************************************************************************
+ * This function returns the core count within the cluster corresponding to
+ * `mpidr`.
+ ******************************************************************************/
+unsigned int plat_arm_get_cluster_core_count(u_register_t mpidr)
+{
+	return MA35D1_MAX_CPUS_PER_CLUSTER;
+}
+
+/*******************************************************************************
+ * This function implements a part of the critical interface between the psci
+ * generic layer and the platform that allows the former to query the platform
+ * to convert an MPIDR to a unique linear index. An error code (-1) is returned
+ * in case the MPIDR is invalid.
+ ******************************************************************************/
+int plat_core_pos_by_mpidr(u_register_t mpidr)
+{
+	unsigned int cluster_id, cpu_id;
+
+	mpidr &= MPIDR_AFFINITY_MASK;
+
+	if ((mpidr & ~(MPIDR_CLUSTER_MASK | MPIDR_CPU_MASK)) != 0U) {
+		return -1;
+	}
+
+	cluster_id = (mpidr >> MPIDR_AFF1_SHIFT) & MPIDR_AFFLVL_MASK;
+	cpu_id = (mpidr >> MPIDR_AFF0_SHIFT) & MPIDR_AFFLVL_MASK;
+
+	if (cluster_id >= PLATFORM_CLUSTER_COUNT) {
+		return -1;
+	}
+
+	/*
+	 * Validate cpu_id by checking whether it represents a CPU in one
+	 * of the two clusters present on the platform.
+	 */
+	if (cpu_id >= PLATFORM_CORE_COUNT) {
+		return -1;
+	}
+
+	return (int)cpu_id;
+}
diff --git a/plat/nuvoton/ma35d1/ma35d1_trusted_boot.c b/plat/nuvoton/ma35d1/ma35d1_trusted_boot.c
new file mode 100644
index 0000000..2f9d538
--- /dev/null
+++ b/plat/nuvoton/ma35d1/ma35d1_trusted_boot.c
@@ -0,0 +1,36 @@
+/*
+ * Copyright (c) 2018-2019, ARM Limited and Contributors. All rights reserved.
+ *
+ * SPDX-License-Identifier: BSD-3-Clause
+ */
+
+#include <plat/common/platform.h>
+
+extern char ma35d1_rotpk_hash[], ma35d1_rotpk_hash_end[];
+
+int plat_get_rotpk_info(void *cookie, void **key_ptr, unsigned int *key_len,
+			unsigned int *flags)
+{
+	*key_ptr = ma35d1_rotpk_hash;
+	*key_len = ma35d1_rotpk_hash_end - ma35d1_rotpk_hash;
+	*flags = ROTPK_IS_HASH;
+
+	return 0;
+}
+
+int plat_get_nv_ctr(void *cookie, unsigned int *nv_ctr)
+{
+	*nv_ctr = 0;
+
+	return 0;
+}
+
+int plat_set_nv_ctr(void *cookie, unsigned int nv_ctr)
+{
+	return 1;
+}
+
+int plat_get_mbedtls_heap(void **heap_addr, size_t *heap_size)
+{
+	return get_mbedtls_heap_helper(heap_addr, heap_size);
+}
diff --git a/plat/nuvoton/ma35d1/platform.mk b/plat/nuvoton/ma35d1/platform.mk
new file mode 100644
index 0000000..c8142e5
--- /dev/null
+++ b/plat/nuvoton/ma35d1/platform.mk
@@ -0,0 +1,255 @@
+#
+# Copyright (C) 2020 Nuvoton Technology Corp. All rights reserved.
+#
+# SPDX-License-Identifier: BSD-3-Clause
+#
+
+# Default cluster count for MA35D1
+MA35D1_CLUSTER_COUNT	:= 1
+# Default number of CPUs per cluster on MA35D1
+MA35D1_MAX_CPUS_PER_CLUSTER	:= 2
+# Default number of threads per CPU on MA35D1
+MA35D1_MAX_PE_PER_CPU	:= 1
+
+BL2_AT_EL3		:=	1
+USE_COHERENT_MEM	:=	0
+#ENABLE_PIE		:=	1
+
+# Flags to build TF with Trusted Boot support
+TRUSTED_BOARD_BOOT	:= 0
+
+# Pass MA35D1_CLUSTER_COUNT to the build system.
+$(eval $(call add_define,MA35D1_CLUSTER_COUNT))
+# Pass MA35D1_MAX_CPUS_PER_CLUSTER to the build system.
+$(eval $(call add_define,MA35D1_MAX_CPUS_PER_CLUSTER))
+# Pass MA35D1_MAX_PE_PER_CPU to the build system.
+$(eval $(call add_define,MA35D1_MAX_PE_PER_CPU))
+$(eval $(call add_define,MA35D1_INTERCONNECT_DRIVER))
+
+MA35D1_BL32_BASE ?= 0x8f800000
+$(eval $(call add_define,MA35D1_BL32_BASE))
+
+MA35D1_DRAM_SIZE ?= 0x0f800000
+$(eval $(call add_define,MA35D1_DRAM_SIZE))
+
+MA35D1_DDR_MAX_SIZE ?= 0x10000000
+$(eval $(call add_define,MA35D1_DDR_MAX_SIZE))
+
+MA35D1_DRAM_S_BASE ?= 0x8f800000
+$(eval $(call add_define,MA35D1_DRAM_S_BASE))
+
+# dump the state on crash console
+CRASH_REPORTING		:=	1
+$(eval $(call add_define,CRASH_REPORTING))
+
+# enable assert() for release/debug builds
+ENABLE_ASSERTIONS	:=	1
+PLAT_LOG_LEVEL_ASSERT	:=	50
+$(eval $(call add_define,PLAT_LOG_LEVEL_ASSERT))
+
+# Build option to add debugfs support
+USE_DEBUGFS		:= 1
+DEBUG			:= 1
+LOG_LEVEL		:= 40
+
+# for test suite
+ENABLE_PSCI_STAT		:=	1
+ENABLE_PMF			:=	1
+
+ifeq ($(NEED_SCP_BL2),yes)
+$(eval $(call add_define,MA35D1_LOAD_SCP_BL2))
+endif
+
+ifeq ($(NEED_BL32),yes)
+$(eval $(call add_define,MA35D1_LOAD_BL32))
+endif
+
+# Enable dynamic memory mapping
+PLAT_XLAT_TABLES_DYNAMIC :=	1
+$(eval $(call assert_boolean,PLAT_XLAT_TABLES_DYNAMIC))
+$(eval $(call add_define,PLAT_XLAT_TABLES_DYNAMIC))
+
+
+PLAT_INCLUDES		:=	-Iplat/nuvoton/ma35d1/include		\
+				-Iinclude/plat/arm/common/aarch64
+
+# Device tree
+DTB_FILE_NAME		?=	\
+				ma35d1-cpu1g-wb-256m.dtb \
+                                ma35d1-cpu1g-wb-512m.dtb \
+				\
+				ma35d1-cpu1g-issi-1g.dtb \
+				ma35d1-cpu1g-mc-1g.dtb \
+				ma35d1-cpu1g-zt-1g.dtb \
+				\
+				ma35d1-cpu800-wb-128m.dtb \
+				ma35d1-cpu800-wb-256m.dtb \
+				ma35d1-cpu800-wb-512m.dtb \
+				\
+				ma35d1-cpu800-issi-1g.dtb \
+				ma35d1-cpu800-mc-1g.dtb \
+				ma35d1-cpu800-zt-1g.dtb
+
+FDT_SOURCES		:=	$(addprefix fdts/, $(patsubst %.dtb,%.dts,$(DTB_FILE_NAME)))
+DTC_FLAGS		+=	-Wno-unit_address_vs_reg
+
+# Add `libfdt` and Arm common helpers required for Dynamic Config
+include lib/libfdt/libfdt.mk
+# Firmware Configuration Framework sources
+include lib/fconf/fconf.mk
+
+include lib/debugfs/debugfs.mk
+
+# Include GICv2 driver files
+include drivers/arm/gic/v2/gicv2.mk
+MA35D1_GIC_SOURCES		:=	${GICV2_SOURCES}		\
+					plat/common/plat_gicv2.c	\
+					plat/arm/common/arm_gicv2.c
+
+MA35D1_SECURITY_SOURCES :=	plat/nuvoton/ma35d1/ma35d1_security.c		\
+
+PLAT_BL_COMMON_SOURCES	:=	common/fdt_wrappers.c				\
+				drivers/nuvoton/uart/ma35d1_console.S	\
+				drivers/nuvoton/ddr/ma35d1_ddr.c	\
+				plat/arm/common/arm_common.c			\
+				plat/nuvoton/ma35d1/ma35d1_common.c		\
+				plat/nuvoton/ma35d1/ma35d1_private.c		\
+				plat/nuvoton/ma35d1/ma35d1_platform.c		\
+				drivers/nuvoton/pmic/ma35d1_pmic.c		\
+				plat/nuvoton/ma35d1/drivers/ma35d1_crypto.c	\
+				plat/nuvoton/ma35d1/drivers/tsi_cmd.c	        \
+
+include lib/xlat_tables_v2/xlat_tables.mk
+PLAT_BL_COMMON_SOURCES	+=	${XLAT_TABLES_LIB_SRCS}
+
+PLAT_BL_COMMON_SOURCES	+=	lib/cpus/aarch64/cortex_a35.S			\
+				lib/cpus/${ARCH}/aem_generic.S			\
+				drivers/arm/cci/cci.c				\
+
+PLAT_BL_COMMON_SOURCES	+=	drivers/arm/tzc/tzc400.c			\
+				drivers/delay_timer/delay_timer.c		\
+				drivers/delay_timer/generic_delay_timer.c	\
+				plat/nuvoton/ma35d1/aarch64/ma35d1_helpers.S	\
+
+BL2_SOURCES		+=	common/desc_image_load.c			\
+				drivers/io/io_block.c				\
+				drivers/io/io_fip.c				\
+				drivers/io/io_memmap.c				\
+				drivers/io/io_storage.c				\
+				plat/arm/common/arm_bl2_el3_setup.c		\
+				plat/arm/common/arm_dyn_cfg.c			\
+				plat/arm/common/arm_dyn_cfg_helpers.c		\
+				plat/nuvoton/ma35d1/ma35d1_bl2_setup.c	\
+				plat/nuvoton/ma35d1/ma35d1_io_storage.c	\
+				drivers/nuvoton/nand/ma35d1_nand.c		\
+				drivers/nuvoton/qspi/ma35d1_qspi.c		\
+				drivers/nuvoton/sdhc/ma35d1_sdhc.c		\
+				plat/nuvoton/ma35d1/ma35d1_bl2_el3_setup.c	\
+				plat/nuvoton/ma35d1/ma35d1_bl2_mem_params_desc.c	\
+				plat/nuvoton/ma35d1/ma35d1_image_load.c		\
+				drivers/io/io_semihosting.c			\
+				lib/optee/optee_utils.c				\
+				lib/utils/mem_region.c				\
+				lib/semihosting/semihosting.c			\
+				lib/semihosting/${ARCH}/semihosting_call.S	\
+				${MA35D1_SECURITY_SOURCES}
+
+
+
+
+BL31_SOURCES		+=	drivers/arm/smmu/smmu_v3.c			\
+				drivers/cfi/v2m/v2m_flash.c			\
+				lib/utils/mem_region.c				\
+				plat/nuvoton/ma35d1/ma35d1_bl31_setup.c	\
+				plat/nuvoton/ma35d1/ma35d1_pm.c		\
+				plat/nuvoton/ma35d1/ma35d1_topology.c		\
+				plat/nuvoton/ma35d1/ma35d1_sip_svc.c            \
+				${MA35D1_GIC_SOURCES}				\
+				${MA35D1_SECURITY_SOURCES}			\
+
+BL31_SOURCES		+=	plat/common/plat_psci_common.c
+
+ifeq ($(NEED_BL32),yes)
+include services/spd/opteed/opteed.mk
+endif
+
+override BL1_SOURCES =
+
+# Add the build options to pack Trusted OS Extra1 and Trusted OS Extra2 images
+# in the FIP if the platform requires.
+ifneq ($(BL32_EXTRA1),)
+$(eval $(call TOOL_ADD_IMG,BL32_EXTRA1,--tos-fw-extra1))
+endif
+
+ifeq (${TRUSTED_BOARD_BOOT},1)
+
+USE_TBBR_DEFS		:= 1
+GENERATE_COT		:= 1
+
+NVT_USE_RSA		:= 0
+NVT_USE_ECDSA		:= 1
+
+MBEDTLS_SHA256_SMALLER	:= 0
+
+# Set the default algorithm for the generation of Trusted Board Boot keys
+ifeq (${NVT_USE_RSA},1)
+	KEY_ALG		:= rsa
+endif
+ifeq (${NVT_USE_ECDSA},1)
+	KEY_ALG		:= ecdsa
+endif
+
+MBEDTLS_DIR=../mbedtls-2.18
+
+include drivers/auth/mbedtls/mbedtls_crypto.mk
+include drivers/auth/mbedtls/mbedtls_x509.mk
+
+BL2_SOURCES		+=	drivers/auth/auth_mod.c			\
+				drivers/auth/crypto_mod.c		\
+				drivers/auth/img_parser_mod.c		\
+				drivers/auth/tbbr/tbbr_cot_common.c	\
+				drivers/auth/tbbr/tbbr_cot_bl2.c	\
+				plat/common/tbbr/plat_tbbr.c		\
+				plat/nuvoton/ma35d1/ma35d1_rotpk.S	\
+				plat/nuvoton/ma35d1/ma35d1_trusted_boot.c
+
+ROT_KEY			= $(BUILD_PLAT)/rot_key.pem
+ROTPK_HASH		= $(BUILD_PLAT)/rotpk_sha256.bin
+
+$(eval $(call add_define_val,ROTPK_HASH,'"$(ROTPK_HASH)"'))
+#$(eval $(call MAKE_LIB_DIRS))
+
+$(BUILD_PLAT)/bl2/ma35d1_rotpk.o: $(ROTPK_HASH)
+
+certificates: $(ROT_KEY)
+
+$(ROT_KEY): | $(BUILD_PLAT)
+	@echo "  OPENSSL $@"
+ifeq (${NVT_USE_RSA},1)
+	@if [ ! -f $(ROT_KEY) ]; then \
+		openssl genrsa 2048 > $@ 2>/dev/null; \
+	fi
+endif
+
+ifeq (${NVT_USE_ECDSA},1)
+	@if [ ! -f $(ROT_KEY) ]; then \
+		openssl ecparam -name secp256r1 -genkey -noout > $@ 2>/dev/null; \
+	fi
+endif
+
+$(ROTPK_HASH): $(ROT_KEY)
+	@echo "  OPENSSL $@"
+ifeq (${NVT_USE_RSA},1)
+	$(Q)openssl rsa -in $< -pubout -outform DER 2>/dev/null |\
+	openssl dgst -sha256 -binary > $@ 2>/dev/null
+endif
+
+ifeq (${NVT_USE_ECDSA},1)
+	$(Q)openssl ec -in $< -pubout -outform DER 2>/dev/null |\
+	openssl dgst -sha256 -binary > $@ 2>/dev/null
+endif
+
+endif
+
+
+
-- 
2.38.1

